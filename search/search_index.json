{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#momentgw","title":"momentGW","text":"<p>Implementations of the GW approximation and associated methods, using moment-conserving solutions to the Dyson equation.</p> <p>This repository contains the implementation and data for the paper \"A 'moment-conserving' reformulation of GW theory\".</p>"},{"location":"#installation","title":"Installation","text":"<p>The <code>momentGW</code> package, along with dependencies, can be installed as</p> <pre><code>git clone git@github.com:BoothGroup/momentGW.git\ncd momentGW\npython -m pip install . --user\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>The <code>momentGW</code> classes behave similarly to other post-mean-field method classes in PySCF. The <code>examples</code> directory contains examples for each solver.</p>"},{"location":"reference/","title":"Index","text":""},{"location":"reference/#momentGW--momentgw","title":"momentGW","text":"<p>The <code>momentGW</code> package implements a wide range of GW methods according to the moment-conserving formalism.</p> <p>Examples:</p> <p>Examples of usage can be found in the <code>examples</code> directory of the repository::</p> <pre><code>$ python examples/00-moment_order.py\n</code></pre> Notes <p>Publications using <code>momentGW</code> should cite [1]_.</p> References <p>.. [1] C. J. C. Scott, O. J. Backhouse, and G. H. Booth, 158, 12, 2023.</p>"},{"location":"reference/base/","title":"Base","text":"<p>Base classes for moment-constrained GW solvers.</p>"},{"location":"reference/base/#momentGW.base.Base","title":"<code>momentGW.base.Base(mf, mo_energy=None, mo_coeff=None, mo_occ=None, **kwargs)</code>","text":"<p>Base class.</p> Source code in <code>momentGW/base.py</code> <pre><code>def __init__(\n    self,\n    mf,\n    mo_energy=None,\n    mo_coeff=None,\n    mo_occ=None,\n    **kwargs,\n):\n    # Parameters\n    self._scf = mf\n    self._mo_energy = mo_energy\n    self._mo_coeff = mo_coeff\n    self._mo_occ = mo_occ\n    self.frozen = None\n\n    # Options\n    for key, val in kwargs.items():\n        if not hasattr(self, key):\n            raise AttributeError(f\"{key} is not a valid option for {self.name}\")\n        setattr(self, key, val)\n\n    # Logging\n    init_logging()\n</code></pre>"},{"location":"reference/base/#momentGW.base.Base.mol","title":"<code>momentGW.base.Base.mol</code>  <code>property</code>","text":"<p>Get the molecule object.</p>"},{"location":"reference/base/#momentGW.base.Base.with_df","title":"<code>momentGW.base.Base.with_df</code>  <code>property</code>","text":"<p>Get the density fitting object.</p>"},{"location":"reference/base/#momentGW.base.Base.nao","title":"<code>momentGW.base.Base.nao</code>  <code>property</code>","text":"<p>Get the number of atomic orbitals.</p>"},{"location":"reference/base/#momentGW.base.Base.nmo","title":"<code>momentGW.base.Base.nmo</code>  <code>property</code>","text":"<p>Get the number of molecular orbitals.</p>"},{"location":"reference/base/#momentGW.base.Base.nocc","title":"<code>momentGW.base.Base.nocc</code>  <code>property</code>","text":"<p>Get the number of occupied molecular orbitals.</p>"},{"location":"reference/base/#momentGW.base.Base.active","title":"<code>momentGW.base.Base.active</code>  <code>property</code>","text":"<p>Get the mask to remove frozen orbitals.</p>"},{"location":"reference/base/#momentGW.base.Base.mo_energy","title":"<code>momentGW.base.Base.mo_energy</code>  <code>property</code> <code>writable</code>","text":"<p>Get the molecular orbital energies.</p>"},{"location":"reference/base/#momentGW.base.Base.mo_energy_with_frozen","title":"<code>momentGW.base.Base.mo_energy_with_frozen</code>  <code>property</code>","text":"<p>Get the molecular orbital energies with frozen orbitals.</p>"},{"location":"reference/base/#momentGW.base.Base.mo_coeff","title":"<code>momentGW.base.Base.mo_coeff</code>  <code>property</code> <code>writable</code>","text":"<p>Get the molecular orbital coefficients.</p>"},{"location":"reference/base/#momentGW.base.Base.mo_coeff_with_frozen","title":"<code>momentGW.base.Base.mo_coeff_with_frozen</code>  <code>property</code>","text":"<p>Get the molecular orbital coefficients with frozen orbitals.</p>"},{"location":"reference/base/#momentGW.base.Base.mo_occ","title":"<code>momentGW.base.Base.mo_occ</code>  <code>property</code> <code>writable</code>","text":"<p>Get the molecular orbital occupation numbers.</p>"},{"location":"reference/base/#momentGW.base.Base.mo_occ_with_frozen","title":"<code>momentGW.base.Base.mo_occ_with_frozen</code>  <code>property</code>","text":"<p>Get the molecular orbital occupation numbers with frozen orbitals.</p>"},{"location":"reference/base/#momentGW.base.Base.kernel","title":"<code>momentGW.base.Base.kernel(*args, **kwargs)</code>","text":"<p>Abstract method for the kernel driver function.</p> Source code in <code>momentGW/base.py</code> <pre><code>def kernel(self, *args, **kwargs):\n    \"\"\"Abstract method for the kernel driver function.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/base/#momentGW.base.Base.run","title":"<code>momentGW.base.Base.run(*args, **kwargs)</code>","text":"<p>Alias for <code>kernel</code>, instead returning <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>tuple</code> <p>Positional arguments to pass to <code>kernel</code>.</p> <code>()</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments to pass to <code>kernel</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>self</code> <code>BaseGW</code> <p>The solver object.</p> Source code in <code>momentGW/base.py</code> <pre><code>def run(self, *args, **kwargs):\n    \"\"\"Alias for `kernel`, instead returning `self`.\n\n    Parameters\n    ----------\n    *args : tuple\n        Positional arguments to pass to `kernel`.\n    **kwargs : dict\n        Keyword arguments to pass to `kernel`.\n\n    Returns\n    -------\n    self : BaseGW\n        The solver object.\n    \"\"\"\n    self.kernel(*args, **kwargs)\n    return self\n</code></pre>"},{"location":"reference/base/#momentGW.base.BaseGW","title":"<code>momentGW.base.BaseGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>Base</code></p> <p>Base class for moment-constrained GW solvers.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>SCF</code> <p>PySCF mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required Source code in <code>momentGW/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Attributes\n    self.converged = None\n    self.se = None\n    self.gf = None\n    self._qp_energy = None\n</code></pre>"},{"location":"reference/base/#momentGW.base.BaseGW.name","title":"<code>momentGW.base.BaseGW.name</code>  <code>property</code>","text":"<p>Abstract property for the solver name.</p>"},{"location":"reference/base/#momentGW.base.BaseGW.qp_energy","title":"<code>momentGW.base.BaseGW.qp_energy</code>  <code>property</code>","text":"<p>Get the quasiparticle energies.</p> Notes <p>For most GW methods, this simply consists of the poles of the <code>self.gf</code> that best overlap with the MOs, in order. In some methods such as qsGW, these two quantities are not the same.</p>"},{"location":"reference/base/#momentGW.base.BaseGW.has_fock_loop","title":"<code>momentGW.base.BaseGW.has_fock_loop</code>  <code>property</code>","text":"<p>Get a boolean indicating whether the solver requires a Fock loop.</p> Notes <p>For most GW methods, this is simply <code>self.fock_loop</code>. In some methods such as qsGW, a Fock loop is required with or without <code>self.fock_loop</code> for the quasiparticle self-consistency, with this property acting as a hook to indicate this.</p>"},{"location":"reference/base/#momentGW.base.BaseGW.build_se_static","title":"<code>momentGW.base.BaseGW.build_se_static(*args, **kwargs)</code>","text":"<p>Abstract method for building the static self-energy.</p> Source code in <code>momentGW/base.py</code> <pre><code>def build_se_static(self, *args, **kwargs):\n    \"\"\"Abstract method for building the static self-energy.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/base/#momentGW.base.BaseGW.build_se_moments","title":"<code>momentGW.base.BaseGW.build_se_moments(*args, **kwargs)</code>","text":"<p>Abstract method for building the self-energy moments.</p> Source code in <code>momentGW/base.py</code> <pre><code>def build_se_moments(self, *args, **kwargs):\n    \"\"\"Abstract method for building the self-energy moments.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/base/#momentGW.base.BaseGW.ao2mo","title":"<code>momentGW.base.BaseGW.ao2mo(transform=True)</code>","text":"<p>Abstract method for getting the integrals object.</p> Source code in <code>momentGW/base.py</code> <pre><code>def ao2mo(self, transform=True):\n    \"\"\"Abstract method for getting the integrals object.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/base/#momentGW.base.BaseGW.solve_dyson","title":"<code>momentGW.base.BaseGW.solve_dyson(*args, **kwargs)</code>","text":"<p>Abstract method for solving the Dyson equation.</p> Source code in <code>momentGW/base.py</code> <pre><code>def solve_dyson(self, *args, **kwargs):\n    \"\"\"Abstract method for solving the Dyson equation.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/base/#momentGW.base.BaseGW.kernel","title":"<code>momentGW.base.BaseGW.kernel(nmom_max, moments=None, integrals=None)</code>","text":"<p>Driver for the method.</p> <p>Parameters:</p> Name Type Description Default <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>moments</code> <code>tuple of numpy.ndarray</code> <p>Tuple of (hole, particle) moments, if passed then they will be used instead of calculating them. Default value is <code>None</code>.</p> <code>None</code> <code>integrals</code> <code>BaseIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>converged</code> <code>bool</code> <p>Whether the solver converged. For single-shot calculations, this is always <code>True</code>.</p> <code>gf</code> <code>Lehmann</code> <p>Green's function object.</p> <code>se</code> <code>Lehmann</code> <p>Self-energy object.</p> <code>qp_energy</code> <code>ndarray</code> <p>Quasiparticle energies. For most GW methods, this is <code>None</code>.</p> Source code in <code>momentGW/base.py</code> <pre><code>@logging.with_timer(\"Kernel\")\ndef kernel(\n    self,\n    nmom_max,\n    moments=None,\n    integrals=None,\n):\n    \"\"\"Driver for the method.\n\n    Parameters\n    ----------\n    nmom_max : int\n        Maximum moment number to calculate.\n    moments : tuple of numpy.ndarray, optional\n        Tuple of (hole, particle) moments, if passed then they will\n        be used instead of calculating them. Default value is\n        `None`.\n    integrals : BaseIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    converged : bool\n        Whether the solver converged. For single-shot calculations,\n        this is always `True`.\n    gf : dyson.Lehmann\n        Green's function object.\n    se : dyson.Lehmann\n        Self-energy object.\n    qp_energy : numpy.ndarray\n        Quasiparticle energies. For most GW methods, this is `None`.\n    \"\"\"\n\n    # Start a timer\n    timer = util.Timer()\n\n    # Write the header\n    logging.write(\"\")\n    logging.write(f\"[bold underline]{self.name}[/]\", comment=\"Solver options\")\n    logging.write(\"\")\n    logging.write(self._get_header())\n    logging.write(\"\", comment=f\"Start of {self.name} kernel\")\n    logging.write(f\"Solving for nmom_max = [option]{nmom_max}[/] ({nmom_max + 1} moments)\")\n\n    # Get the integrals\n    if integrals is None:\n        integrals = self.ao2mo()\n\n    # Run the kernel\n    with logging.with_status(f\"Running {self.name} kernel\"):\n        self.converged, self.gf, self.se, self._qp_energy = self._kernel(\n            nmom_max,\n            integrals=integrals,\n            moments=moments,\n        )\n    logging.write(\"\", comment=f\"End of {self.name} kernel\")\n\n    # Print the summary in a panel\n    logging.write(self._get_summary_panel(integrals, timer))\n\n    return self.converged, self.gf, self.se, self.qp_energy\n</code></pre>"},{"location":"reference/bse/","title":"Bse","text":"<p>Spin-restricted Bethe-Salpeter equation (BSE) via self-energy moment constraints for molecular systems.</p>"},{"location":"reference/bse/#momentGW.bse.BSE","title":"<code>momentGW.bse.BSE(gw, **kwargs)</code>","text":"<p>             Bases: <code>Base</code></p> <p>Bethe-Salpeter equation.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseGW</code> <p>GW object.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of `(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is the same as the underling GW object.</p> required <code>excitation</code> <code>str</code> <p>Type of excitation, can be one of <code>(\"singlet\", \"triplet\")</code>. Default value is <code>\"singlet\"</code>.</p> required Source code in <code>momentGW/bse.py</code> <pre><code>def __init__(self, gw, **kwargs):\n    if kwargs.get(\"polariability\") is None:\n        kwargs[\"polarizability\"] = gw.polarizability\n    super().__init__(gw._scf, **kwargs)\n\n    # Parameters\n    self.gw = gw\n\n    # Attributes\n    self.gf = None\n</code></pre>"},{"location":"reference/bse/#momentGW.bse.BSE.name","title":"<code>momentGW.bse.BSE.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/bse/#momentGW.bse.BSE.ao2mo","title":"<code>momentGW.bse.BSE.ao2mo(transform=True)</code>","text":"<p>Get the integrals object.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <code>bool</code> <p>Whether to transform the integrals object.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>integrals</code> <code>BaseIntegrals</code> <p>Integrals object.</p> Source code in <code>momentGW/bse.py</code> <pre><code>@logging.with_timer(\"Integral construction\")\n@logging.with_status(\"Constructing integrals\")\ndef ao2mo(self, transform=True):\n    \"\"\"Get the integrals object.\n\n    Parameters\n    ----------\n    transform : bool, optional\n        Whether to transform the integrals object.\n\n    Returns\n    -------\n    integrals : BaseIntegrals\n        Integrals object.\n    \"\"\"\n\n    # Get the integrals\n    integrals = Integrals(\n        self.with_df,\n        self.mo_coeff,\n        self.mo_occ,\n        compression=self.gw.compression,\n        compression_tol=self.gw.compression_tol,\n        store_full=True,\n    )\n\n    # Check compression\n    compression = integrals._parse_compression()\n    if compression and compression != {\"oo\", \"vv\", \"ov\"}:\n        logging.warn(\n            \"[bad]Running BSE with compression without including all integral blocks \"\n            \"is not recommended[/]. See example 17.\",\n        )\n\n    # Transform the integrals\n    if transform:\n        integrals.transform()\n\n    return integrals\n</code></pre>"},{"location":"reference/bse/#momentGW.bse.BSE.build_dd_moment_inv","title":"<code>momentGW.bse.BSE.build_dd_moment_inv(integrals, **kwargs)</code>","text":"<p>Build the first inverse moment of the density-density response.</p> <p>Parameters:</p> Name Type Description Default <code>integrals</code> <code>BaseIntegrals</code> <p>Integrals object.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to pass to the RPA or TDA solver. See <code>momentGW.tda</code> and <code>momentGW.rpa</code> for options.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>moment</code> <code>ndarray</code> <p>First inverse (<code>n=-1</code>) moment of the density-density response.</p> Source code in <code>momentGW/bse.py</code> <pre><code>def build_dd_moment_inv(self, integrals, **kwargs):\n    \"\"\"\n    Build the first inverse moment of the density-density response.\n\n    Parameters\n    ----------\n    integrals : BaseIntegrals\n        Integrals object.\n    **kwargs : dict, optional\n        Additional keyword arguments to pass to the RPA or TDA\n        solver. See `momentGW.tda` and `momentGW.rpa` for options.\n\n    Returns\n    -------\n    moment : numpy.ndarray\n        First inverse (`n=-1`) moment of the density-density\n        response.\n    \"\"\"\n\n    if self.polarizability == \"drpa\":\n        rpa = dRPA(self.gw, 1, integrals, **kwargs)\n        return rpa.build_dd_moment_inv()\n\n    elif self.polarizability == \"dtda\":\n        tda = dTDA(self.gw, 1, integrals, **kwargs)\n        return tda.build_dd_moment_inv()\n\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/bse/#momentGW.bse.BSE.build_matvec","title":"<code>momentGW.bse.BSE.build_matvec(integrals, moment=None)</code>","text":"<p>Build the matrix-vector product required for the Bethe-Salpeter equation.</p> <p>Parameters:</p> Name Type Description Default <code>integrals</code> <code>BaseIntegrals</code> <p>Integrals object.</p> required <code>moment</code> <code>ndarray</code> <p>First inverse (<code>n=-1</code>) moment of the density-density response. If not provided, calculate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>matvec</code> <code>callable</code> <p>Function that takes a vector <code>x</code> and returns the matrix- vector product <code>xA</code>.</p> Source code in <code>momentGW/bse.py</code> <pre><code>@logging.with_timer(\"Matrix-vector product construction\")\n@logging.with_status(\"Constructing matrix-vector product\")\ndef build_matvec(self, integrals, moment=None):\n    \"\"\"\n    Build the matrix-vector product required for the\n    Bethe-Salpeter equation.\n\n    Parameters\n    ----------\n    integrals : BaseIntegrals\n        Integrals object.\n    moment : numpy.ndarray, optional\n        First inverse (`n=-1`) moment of the density-density\n        response. If not provided, calculate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    matvec : callable\n        Function that takes a vector ``x`` and returns the matrix-\n        vector product ``xA``.\n    \"\"\"\n\n    # Developer note: this is not parallelised much, I just made\n    # sure that it would run through in parallel.\n\n    # Construct the energy differences\n    if not self.gw.converged:\n        logging.warn(\"[red]GW calculation has not converged[/] - using MO energies for BSE\")\n        qp_energy = self.mo_energy\n    else:\n        # Just use the QP energies - we could do the entire BSE in\n        # the basis of the GW solution but that's more annoying\n        qp_energy = self.gw.qp_energy\n\n    # Get the 1h1p energies\n    d = util.build_1h1p_energies(self.mo_energy, self.mo_occ)\n    nocc, nvir = d.shape\n\n    # Get the inverse moment\n    if moment is None:\n        moment = self.build_dd_moment_inv(integrals)\n\n    # Get the integrals\n    p0, p1 = list(mpi_helper.prange(0, integrals.nmo, integrals.nmo))[0]\n    Lpq = np.zeros((integrals.naux, integrals.nmo, integrals.nmo))\n    Lpq_part = integrals.Lpq\n    if integrals._rot is not None:\n        Lpq_part = util.einsum(\"PQ,Pij-&gt;Qij\", integrals._rot, Lpq_part)\n    Lpq[:, :, p0:p1] = Lpq_part\n    Lpq = mpi_helper.allreduce(Lpq)\n    Loo = Lpq[:, :nocc, :nocc]\n    Lvv = Lpq[:, nocc:, nocc:]\n    Lov = Lpq[:, :nocc, nocc:]\n\n    # Intermediates for the screened interaction to reduce the\n    # number of N^4 operations in `matvec`.\n    # TODO: account for this derivation!!\n    # TODO does this also work with RPA-BSE?\n    q_ov = util.einsum(\"Lia,Qia,ia-&gt;LQ\", Lov, Lov, 1.0 / d)\n    eta_aux = util.einsum(\"Px,Qx-&gt;PQ\", integrals.Lia, moment)\n    eta_aux = mpi_helper.allreduce(eta_aux)\n    q_full = q_ov - np.dot(q_ov, eta_aux)\n    q_full = 4.0 * q_full - np.eye(q_full.shape[0])\n    q_full_vv = util.einsum(\"LQ,Qab-&gt;Lab\", q_full, Lvv)\n\n    @logging.with_timer(\"Matrix-vector product\")\n    @logging.with_status(\"Evaluating matrix-vector product\")\n    def matvec(vec):\n        \"\"\"\n        Matrix-vector product. Input matrix should be of shape\n        (aux, occ*vir).\n        \"\"\"\n\n        shape = vec.shape\n        vec = vec.reshape(-1, nocc, nvir)\n        out = np.zeros_like(vec)\n\n        # r_{x, ia} = v_{x, ia} (\u03f5_a - \u03f5_i)\n        out = util.einsum(\"xia,a-&gt;xia\", vec, qp_energy[nocc:])\n        out -= util.einsum(\"xia,i-&gt;xia\", vec, qp_energy[:nocc])\n\n        # r_{x, jb} = v_{x, ia} \u03ba (ia|jb)\n        if self.excitation == \"singlet\":\n            out += util.einsum(\"xia,Lia,Ljb-&gt;xjb\", vec, Lov, Lov) * 2\n\n        # r_{x, jb} = - v_{x, ia} (ab|ij)\n        # r_{x, jb} = -2 v_{x, ia} (ij|kc) [\u03b7^{-1}]_{kc, ld} (ld|ab)\n        # Loop over x avoids possibly big intermediates\n        for x in range(vec.shape[0]):\n            out[x] += util.einsum(\"ia,Lij,Lab-&gt;jb\", vec[x], Loo, q_full_vv)\n\n        return out.reshape(shape)\n\n    return matvec\n</code></pre>"},{"location":"reference/bse/#momentGW.bse.BSE.build_dp_moments","title":"<code>momentGW.bse.BSE.build_dp_moments(nmom_max, integrals, matvec=None)</code>","text":"<p>Build the moments of the dynamic polarizability.</p> <p>Parameters:</p> Name Type Description Default <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>integrals</code> <code>BaseIntegrals</code> <p>Integrals object.</p> required <code>matvec</code> <code>callable</code> <p>Function that computes the matrix-vector product between the Bethe-Salpeter Hamiltonian and a vector. If not provided, calculate using <code>build_matvec</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>moments_dp</code> <code>ndarray</code> <p>Moments of the dynamic polarizability.</p> <code>orth</code> <code>ndarray</code> <p>Orthogonalization matrix. For compatibility with the Chebyshev solver, and is <code>None</code> in this case.</p> Source code in <code>momentGW/bse.py</code> <pre><code>@logging.with_timer(\"Dynamic polarizability moments\")\n@logging.with_status(\"Constructing dynamic polarizability moments\")\ndef build_dp_moments(self, nmom_max, integrals, matvec=None):\n    \"\"\"Build the moments of the dynamic polarizability.\n\n    Parameters\n    ----------\n    nmom_max : int\n        Maximum moment number to calculate.\n    integrals : BaseIntegrals\n        Integrals object.\n    matvec : callable, optional\n        Function that computes the matrix-vector product between\n        the Bethe-Salpeter Hamiltonian and a vector. If not\n        provided, calculate using `build_matvec`. Default value is\n        `None`.\n\n    Returns\n    -------\n    moments_dp : numpy.ndarray\n        Moments of the dynamic polarizability.\n    orth : numpy.ndarray\n        Orthogonalization matrix. For compatibility with the\n        Chebyshev solver, and is `None` in this case.\n    \"\"\"\n\n    # Get the matrix-vector product callable\n    if matvec is None:\n        matvec = self.build_matvec(integrals)\n\n    # Get the dipole matrices\n    with self.mol.with_common_orig((0, 0, 0)):\n        dip = self.mol.intor_symmetric(\"int1e_r\", comp=3)\n\n    # Rotate into ia basis\n    ci = integrals.mo_coeff[:, integrals.mo_occ &gt; 0]\n    ca = integrals.mo_coeff[:, integrals.mo_occ == 0]\n    dip = util.einsum(\"xpq,pi,qa-&gt;xia\", dip, ci.conj(), ca)\n    dip = dip.reshape(3, -1)\n\n    # Get the moments of the dynamic polarizability\n    moments_dp = np.zeros((nmom_max + 1, 3, dip.shape[1]))\n    moments_dp[0] = dip.copy()\n    for n in range(1, nmom_max + 1):\n        moments_dp[n] = matvec(moments_dp[n - 1])\n\n    # Rotate basis\n    moments_dp = util.einsum(\"px,nqx-&gt;npq\", dip.conj(), moments_dp)\n\n    return moments_dp\n</code></pre>"},{"location":"reference/bse/#momentGW.bse.BSE.solve_bse","title":"<code>momentGW.bse.BSE.solve_bse(moments)</code>","text":"<p>Solve the Bethe-Salpeter equation.</p> <p>Parameters:</p> Name Type Description Default <code>moments</code> <code>ndarray</code> <p>Moments of the dynamic polarizability.</p> required <p>Returns:</p> Name Type Description <code>gf</code> <code>Lehmann</code> <p>Green's function object.</p> Source code in <code>momentGW/bse.py</code> <pre><code>def solve_bse(self, moments):\n    \"\"\"Solve the Bethe-Salpeter equation.\n\n    Parameters\n    ----------\n    moments : numpy.ndarray\n        Moments of the dynamic polarizability.\n\n    Returns\n    -------\n    gf : dyson.Lehmann\n        Green's function object.\n    \"\"\"\n\n    solver = MBLGF(np.array(moments))\n    solver.kernel()\n\n    gf = solver.get_greens_function()\n\n    return gf\n</code></pre>"},{"location":"reference/bse/#momentGW.bse.BSE.kernel","title":"<code>momentGW.bse.BSE.kernel(nmom_max, moments=None, integrals=None)</code>","text":"<p>Driver for the method.</p> <p>Parameters:</p> Name Type Description Default <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>moments</code> <code>tuple of numpy.ndarray</code> <p>Chebyshev moments of the dynamic polarizability, if passed then they will be used instead of calculating them. Default value is <code>None</code>.</p> <code>None</code> <code>integrals</code> <code>BaseIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>gf</code> <code>Lehmann</code> <p>Green's function object.</p> Source code in <code>momentGW/bse.py</code> <pre><code>@logging.with_timer(\"Kernel\")\ndef kernel(\n    self,\n    nmom_max,\n    moments=None,\n    integrals=None,\n):\n    \"\"\"Driver for the method.\n\n    Parameters\n    ----------\n    nmom_max : int\n        Maximum moment number to calculate.\n    moments : tuple of numpy.ndarray, optional\n        Chebyshev moments of the dynamic polarizability, if passed\n        then they will be used instead of calculating them. Default\n        value is `None`.\n    integrals : BaseIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    gf : dyson.Lehmann\n        Green's function object.\n    \"\"\"\n\n    # Start a timer\n    timer = util.Timer()\n\n    # Write the header\n    logging.write(\"\")\n    logging.write(f\"[bold underline]{self.name}[/]\", comment=\"Solver options\")\n    logging.write(\"\")\n    logging.write(self._get_header())\n    logging.write(\"\", comment=f\"Start of {self.name} kernel\")\n    logging.write(f\"Solving for nmom_max = [option]{nmom_max}[/] ({nmom_max + 1} moments)\")\n\n    # Get the integrals\n    if integrals is None:\n        integrals = self.ao2mo()\n\n    # Run the kernel\n    logging.write(\"\")\n    with logging.with_status(f\"Running {self.name} kernel\"):\n        self.gf = self._kernel(\n            nmom_max,\n            integrals=integrals,\n            moments=moments,\n        )\n    logging.write(\"\", comment=f\"End of {self.name} kernel\")\n\n    # Print the summary in a panel\n    logging.write(self._get_summary_panel(timer))\n\n    return self.gf\n</code></pre>"},{"location":"reference/bse/#momentGW.bse.cpBSE","title":"<code>momentGW.bse.cpBSE(gw, **kwargs)</code>","text":"<p>             Bases: <code>BSE</code></p> <p>Chebyshev-polynomial Bethe-Salpeter equation.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>SCF</code> <p>PySCF mean-field class.</p> required <code>scale</code> <code>tuple of int</code> <p>Scaling parameters used to scale the spectrum to <code>[-1, 1]</code>, given as <code>(a, b)</code> where</p> <p>.. math::     a = \\frac{\\omega_{\\max} - \\omega_{\\min}}{2 - \\epsilon},     b = \\frac{\\omega_{\\max} + \\omega_{\\min}}{2}.</p> <p>where :math:<code>\\omega_{\\max}</code> and :math:<code>\\omega_{\\min}</code> are the maximum and minimum energies in the spectrum, respectively, and :math:<code>\\epsilon</code> is a small number shifting the spectrum values away from the boundaries.</p> required <code>grid</code> <code>ndarray</code> <p>Grid to plot spectral function on.</p> required <code>eta</code> <code>float</code> <p>Regularisation parameter. Default value is <code>0.1</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>excitation</code> <code>str</code> <p>Type of excitation, can be one of <code>(\"singlet\", \"triplet\")</code>. Default value is <code>\"singlet\"</code>.</p> required Source code in <code>momentGW/bse.py</code> <pre><code>def __init__(self, gw, **kwargs):\n    super().__init__(gw, **kwargs)\n\n    # Check options\n    if self.scale is None:\n        raise ValueError(\"Must provide `scale` parameter.\")\n    if self.grid is None:\n        raise ValueError(\"Must provide `grid` parameter.\")\n</code></pre>"},{"location":"reference/bse/#momentGW.bse.cpBSE.name","title":"<code>momentGW.bse.cpBSE.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/bse/#momentGW.bse.cpBSE.build_dp_moments","title":"<code>momentGW.bse.cpBSE.build_dp_moments(nmom_max, integrals, matvec=None)</code>","text":"<p>Build the moments of the dynamic polarizability.</p> <p>Parameters:</p> Name Type Description Default <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>integrals</code> <code>BaseIntegrals</code> <p>Integrals object.</p> required <code>matvec</code> <code>callable</code> <p>Function that computes the matrix-vector product between the Bethe-Salpeter Hamiltonian and a vector. If not provided, calculate using <code>build_matvec</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>moments_dp</code> <code>ndarray</code> <p>Chebyshev moments of the dynamic polarizability.</p> Source code in <code>momentGW/bse.py</code> <pre><code>@logging.with_timer(\"Dynamic polarizability moments\")\n@logging.with_status(\"Constructing dynamic polarizability moments\")\ndef build_dp_moments(self, nmom_max, integrals, matvec=None):\n    \"\"\"Build the moments of the dynamic polarizability.\n\n    Parameters\n    ----------\n    nmom_max : int\n        Maximum moment number to calculate.\n    integrals : BaseIntegrals\n        Integrals object.\n    matvec : callable, optional\n        Function that computes the matrix-vector product between\n        the Bethe-Salpeter Hamiltonian and a vector. If not\n        provided, calculate using `build_matvec`. Default value is\n        `None`.\n\n    Returns\n    -------\n    moments_dp : numpy.ndarray\n        Chebyshev moments of the dynamic polarizability.\n    \"\"\"\n\n    # Get the matrix-vector product callable\n    if matvec is None:\n        matvec = self.build_matvec(integrals)\n\n    # Scale the matrix-vector product\n    a, b = self.scale\n    matvec_scaled = lambda v: matvec(v) / a - b * v / a\n\n    # Get the dipole matrices\n    with self.mol.with_common_orig((0, 0, 0)):\n        dip = self.mol.intor_symmetric(\"int1e_r\", comp=3)\n\n    # Rotate into ia basis\n    ci = integrals.mo_coeff[:, integrals.mo_occ &gt; 0]\n    ca = integrals.mo_coeff[:, integrals.mo_occ == 0]\n    dip = util.einsum(\"xpq,pi,qa-&gt;xia\", dip, ci.conj(), ca)\n    dip = dip.reshape(3, -1)\n\n    # Get the moments of the dynamic polarizability\n    moments_dp = np.zeros((nmom_max + 1, 3, 3))\n    vecs = (dip, matvec_scaled(dip))\n    moments_dp[0] = np.dot(vecs[0], dip.T)\n    moments_dp[1] = np.dot(vecs[1], dip.T)\n    for i in range(2, nmom_max + 1):\n        vec_next = 2.0 * matvec_scaled(vecs[1]) - vecs[0]\n        moments_dp[i] = np.dot(vec_next, dip.T)\n        vecs = (vecs[1], vec_next)\n\n    return moments_dp\n</code></pre>"},{"location":"reference/bse/#momentGW.bse.cpBSE.solve_bse","title":"<code>momentGW.bse.cpBSE.solve_bse(moments)</code>","text":"<p>Solve the Bethe-Salpeter equation.</p> <p>Parameters:</p> Name Type Description Default <code>moments</code> <code>ndarray</code> <p>Chebyshev moments of the dynamic polarizability.</p> required <p>Returns:</p> Name Type Description <code>gf</code> <code>ndarray</code> <p>Green's function object.</p> Source code in <code>momentGW/bse.py</code> <pre><code>def solve_bse(self, moments):\n    \"\"\"Solve the Bethe-Salpeter equation.\n\n    Parameters\n    ----------\n    moments : numpy.ndarray\n        Chebyshev moments of the dynamic polarizability.\n\n    Returns\n    -------\n    gf : numpy.ndarray\n        Green's function object.\n    \"\"\"\n\n    solver = CPGF(\n        np.array(moments),\n        self.grid,\n        self.scale,\n        eta=self.eta,\n        # Maybe these are unnecessary?\n        trace=False,\n        include_real=True,\n    )\n    gf = solver.kernel()\n\n    return gf\n</code></pre>"},{"location":"reference/bse/#momentGW.bse.kernel","title":"<code>momentGW.bse.kernel(bse, nmom_max, moments=None, integrals=None)</code>","text":"<p>Bethe-Salpeter equation.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseGW</code> <p>GW object.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>moments</code> <code>ndarray</code> <p>Moments of the dynamic polarizability, if passed then they will be used instead of calculating them. Default value is <code>None</code>.</p> <code>None</code> <code>integrals</code> <code>BaseIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>gf</code> <code>Lehmann</code> <p>Green's function object.</p> Source code in <code>momentGW/bse.py</code> <pre><code>def kernel(\n    bse,\n    nmom_max,\n    moments=None,\n    integrals=None,\n):\n    \"\"\"Bethe-Salpeter equation.\n\n    Parameters\n    ----------\n    gw : BaseGW\n        GW object.\n    nmom_max : int\n        Maximum moment number to calculate.\n    moments : numpy.ndarray, optional\n        Moments of the dynamic polarizability, if passed then they will\n        be used instead of calculating them. Default value is `None`.\n    integrals : BaseIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    gf : dyson.Lehmann\n        Green's function object.\n    \"\"\"\n\n    # Get the integrals\n    if integrals is None:\n        integrals = bse.ao2mo()\n\n    # Get the moments of the dynamic polarizability\n    if moments is None:\n        moments = bse.build_dp_moments(nmom_max, integrals)\n\n    # Solve the Bethe-Salpeter equation\n    gf = bse.solve_bse(moments)\n\n    return gf\n</code></pre>"},{"location":"reference/energy/","title":"Energy","text":"<p>Energy functionals.</p>"},{"location":"reference/energy/#momentGW.energy.hartree_fock","title":"<code>momentGW.energy.hartree_fock(rdm1, fock, h1e)</code>","text":"<p>Hartree--Fock energy functional.</p> <p>Parameters:</p> Name Type Description Default <code>rdm1</code> <code>ndarray</code> <p>One-particle reduced density matrix.</p> required <code>fock</code> <code>ndarray</code> <p>Fock matrix.</p> required <code>h1e</code> <code>ndarray</code> <p>One-electron Hamiltonian.</p> required <p>Returns:</p> Name Type Description <code>e_1b</code> <code>float</code> <p>Hartree--Fock energy.</p> Source code in <code>momentGW/energy.py</code> <pre><code>def hartree_fock(rdm1, fock, h1e):\n    \"\"\"Hartree--Fock energy functional.\n\n    Parameters\n    ----------\n    rdm1 : numpy.ndarray\n        One-particle reduced density matrix.\n    fock : numpy.ndarray\n        Fock matrix.\n    h1e : numpy.ndarray\n        One-electron Hamiltonian.\n\n    Returns\n    -------\n    e_1b : float\n        Hartree--Fock energy.\n    \"\"\"\n    return util.einsum(\"ij,ji-&gt;\", rdm1, h1e + fock) * 0.5\n</code></pre>"},{"location":"reference/energy/#momentGW.energy.galitskii_migdal","title":"<code>momentGW.energy.galitskii_migdal(gf, se, flip=False)</code>","text":"<p>Galitskii--Migdal energy functional.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>Lehmann</code> <p>Green's function object.</p> required <code>se</code> <code>Lehmann</code> <p>Self-energy object.</p> required <code>flip</code> <code>bool</code> <p>Default option is to use the occupied Green's function and the virtual self-energy. If <code>flip=True</code>, the virtual Green's function and the occupied self-energy are used instead. Default value is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>e_2b</code> <code>float</code> <p>Galitskii--Migdal energy.</p> Notes <p>This functional is the analytically integrated version of [1]_</p> <p>.. math::     \\frac{\\pi}{4} \\int d\\omega \\mathrm{Tr}[G(i\\omega)     \\Sigma(i\\omega)]</p> <p>in terms of the poles of the Green's function and the self-energy. This scales as :math:<code>\\mathcal{O}(N^4)</code> with system size [2]_.</p> References <p>.. [1] V. M. Galitskii and A. B. Migdal, Sov. Phys. JETP 7, 96,     1958. .. [2] O. J. Backhouse, M. Nusspickel, and G. H. Booth, J. Chem.     Theory Comput. 16, 2, 2020.</p> Source code in <code>momentGW/energy.py</code> <pre><code>def galitskii_migdal(gf, se, flip=False):\n    r\"\"\"Galitskii--Migdal energy functional.\n\n    Parameters\n    ----------\n    gf : dyson.Lehmann\n        Green's function object.\n    se : dyson.Lehmann\n        Self-energy object.\n    flip : bool, optional\n        Default option is to use the occupied Green's function and the\n        virtual self-energy. If `flip=True`, the virtual Green's\n        function and the occupied self-energy are used instead. Default\n        value is `False`.\n\n    Returns\n    -------\n    e_2b : float\n        Galitskii--Migdal energy.\n\n    Notes\n    -----\n    This functional is the analytically integrated version of [1]_\n\n    .. math::\n        \\frac{\\pi}{4} \\int d\\omega \\mathrm{Tr}[G(i\\omega)\n        \\Sigma(i\\omega)]\n\n    in terms of the poles of the Green's function and the self-energy.\n    This scales as :math:`\\mathcal{O}(N^4)` with system size [2]_.\n\n    References\n    ----------\n    .. [1] V. M. Galitskii and A. B. Migdal, Sov. Phys. JETP 7, 96,\n        1958.\n    .. [2] O. J. Backhouse, M. Nusspickel, and G. H. Booth, J. Chem.\n        Theory Comput. 16, 2, 2020.\n    \"\"\"\n\n    # Get the correct Green's function and self-energy sectors\n    if flip:\n        gf = gf.virtual()\n        se = se.occupied()\n    else:\n        gf = gf.occupied()\n        se = se.virtual()\n\n    # Compute the Galitskii--Migdal energy in blocks\n    e_2b = 0.0\n    for p0, p1 in lib.prange(0, se.naux, 256):\n        vu = util.einsum(\"pk,px-&gt;kx\", se.couplings[:, p0:p1], gf.couplings)\n        denom = lib.direct_sum(\"x-k-&gt;kx\", gf.energies, se.energies[p0:p1])\n        e_2b += np.ravel(util.einsum(\"kx,kx,kx-&gt;\", vu, vu.conj(), 1.0 / denom))[0]\n\n    # Apply the factor 2\n    e_2b *= 2.0\n\n    return e_2b\n</code></pre>"},{"location":"reference/energy/#momentGW.energy.galitskii_migdal_g0","title":"<code>momentGW.energy.galitskii_migdal_g0(mo_energy, mo_occ, se, flip=False)</code>","text":"<p>Galitskii--Migdal energy functional for the non-interacting Green's function.</p> <p>Parameters:</p> Name Type Description Default <code>mo_energy</code> <code>ndarray</code> <p>MO energies (poles of the Green's function).</p> required <code>mo_occ</code> <code>ndarray</code> <p>MO occupancies.</p> required <code>se</code> <code>Lehmann</code> <p>Self-energy.</p> required <code>flip</code> <code>bool</code> <p>Default option is to use the occupied Green's function and the virtual self-energy. If <code>flip=True</code>, the virtual Green's function and the occupied self-energy are used instead. Default value is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>e_2b</code> <code>float</code> <p>Galitskii--Migdal energy.</p> Notes <p>This functional is the analytically integrated version of [1]_</p> <p>.. math::     \\frac{\\pi}{4} \\int d\\omega \\         \\mathrm{Tr}[G_{0}(i\\omega) \\Sigma(i\\omega)]</p> <p>in terms of the poles of the mean-field Green's function and the self-energy. This scales as :math:<code>\\mathcal{O}(N^3)</code> with system size [2]_.</p> References <p>.. [1] V. M. Galitskii and A. B. Migdal, Sov. Phys. JETP 7, 96,     1958. .. [2] O. J. Backhouse, M. Nusspickel, and G. H. Booth, J. Chem.     Theory Comput. 16, 2, 2020.</p> Source code in <code>momentGW/energy.py</code> <pre><code>def galitskii_migdal_g0(mo_energy, mo_occ, se, flip=False):\n    r\"\"\"\n    Galitskii--Migdal energy functional for the non-interacting Green's\n    function.\n\n    Parameters\n    ----------\n    mo_energy : numpy.ndarray\n        MO energies (poles of the Green's function).\n    mo_occ : numpy.ndarray\n        MO occupancies.\n    se : dyson.Lehmann\n        Self-energy.\n    flip : bool, optional\n        Default option is to use the occupied Green's function and the\n        virtual self-energy. If `flip=True`, the virtual Green's\n        function and the occupied self-energy are used instead. Default\n        value is `False`.\n\n    Returns\n    -------\n    e_2b : float\n        Galitskii--Migdal energy.\n\n    Notes\n    -----\n    This functional is the analytically integrated version of [1]_\n\n    .. math::\n        \\frac{\\pi}{4} \\int d\\omega \\\\\n            \\mathrm{Tr}[G_{0}(i\\omega) \\Sigma(i\\omega)]\n\n    in terms of the poles of the mean-field Green's function and the\n    self-energy. This scales as :math:`\\mathcal{O}(N^3)` with system\n    size [2]_.\n\n    References\n    ----------\n    .. [1] V. M. Galitskii and A. B. Migdal, Sov. Phys. JETP 7, 96,\n        1958.\n    .. [2] O. J. Backhouse, M. Nusspickel, and G. H. Booth, J. Chem.\n        Theory Comput. 16, 2, 2020.\n    \"\"\"\n\n    # Get the correct Green's function and self-energy sectors\n    if flip:\n        mo = mo_energy[mo_occ == 0]\n        se = se.occupied()\n        se.couplings = se.couplings[mo_occ == 0]\n    else:\n        mo = mo_energy[mo_occ &gt; 0]\n        se = se.virtual()\n        se.couplings = se.couplings[mo_occ &gt; 0]\n\n    # Compute the Galitskii--Migdal energy in blocks\n    denom = lib.direct_sum(\"i-j-&gt;ij\", mo, se.energies)\n    e_2b = np.ravel(util.einsum(\"xk,xk,xk-&gt;\", se.couplings, se.couplings.conj(), 1.0 / denom))[0]\n\n    # Apply the factor 2\n    e_2b *= 2.0\n\n    return e_2b\n</code></pre>"},{"location":"reference/evgw/","title":"Evgw","text":"<p>Spin-restricted eigenvalue self-consistent GW via self-energy moment constraints for molecular systems.</p>"},{"location":"reference/evgw/#momentGW.evgw.evGW","title":"<code>momentGW.evgw.evGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>GW</code></p> <p>Spin-restricted eigenvalue self-consistent GW via self-energy moment constraints for molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>SCF</code> <p>PySCF mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>g0</code> <code>bool</code> <p>If <code>True</code>, do not self-consistently update the eigenvalues in the Green's function. Default value is <code>False</code>.</p> required <code>w0</code> <code>bool</code> <p>If <code>True</code>, do not self-consistently update the eigenvalues in the screened Coulomb interaction. Default value is <code>False</code>.</p> required <code>max_cycle</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>50</code>.</p> required <code>conv_tol</code> <code>float</code> <p>Convergence threshold in the change in the HOMO and LUMO. Default value is <code>1e-8</code>.</p> required <code>conv_tol_moms</code> <code>float</code> <p>Convergence threshold in the change in the moments. Default value is <code>1e-8</code>.</p> required <code>conv_logical</code> <code>callable</code> <p>Function that takes an iterable of booleans as input indicating whether the individual <code>conv_tol</code> and <code>conv_tol_moms</code> have been satisfied, respectively, and returns a boolean indicating overall convergence. For example, the function <code>all</code> requires both metrics to be met, and <code>any</code> requires just one. Default value is <code>all</code>.</p> required <code>diis_space</code> <code>int</code> <p>Size of the DIIS extrapolation space. Default value is <code>8</code>.</p> required <code>damping</code> <code>float</code> <p>Damping parameter. Default value is <code>0.0</code>.</p> required <code>weight_tol</code> <code>float</code> <p>Threshold in physical weight of Green's function poles, below which they are considered zero. Default value is <code>1e-11</code>.</p> required Source code in <code>momentGW/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Attributes\n    self.converged = None\n    self.se = None\n    self.gf = None\n    self._qp_energy = None\n</code></pre>"},{"location":"reference/evgw/#momentGW.evgw.evGW.name","title":"<code>momentGW.evgw.evGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/evgw/#momentGW.evgw.evGW.check_convergence","title":"<code>momentGW.evgw.evGW.check_convergence(mo_energy, mo_energy_prev, th, th_prev, tp, tp_prev)</code>","text":"<p>Check for convergence, and print a summary of changes.</p> <p>Parameters:</p> Name Type Description Default <code>mo_energy</code> <code>ndarray</code> <p>Molecular orbital energies.</p> required <code>mo_energy_prev</code> <code>ndarray</code> <p>Molecular orbital energies from the previous iteration.</p> required <code>th</code> <code>ndarray</code> <p>Moments of the occupied self-energy.</p> required <code>th_prev</code> <code>ndarray</code> <p>Moments of the occupied self-energy from the previous iteration.</p> required <code>tp</code> <code>ndarray</code> <p>Moments of the virtual self-energy.</p> required <code>tp_prev</code> <code>ndarray</code> <p>Moments of the virtual self-energy from the previous iteration.</p> required <p>Returns:</p> Name Type Description <code>conv</code> <code>bool</code> <p>Convergence flag.</p> Source code in <code>momentGW/evgw.py</code> <pre><code>def check_convergence(self, mo_energy, mo_energy_prev, th, th_prev, tp, tp_prev):\n    \"\"\"Check for convergence, and print a summary of changes.\n\n    Parameters\n    ----------\n    mo_energy : numpy.ndarray\n        Molecular orbital energies.\n    mo_energy_prev : numpy.ndarray\n        Molecular orbital energies from the previous iteration.\n    th : numpy.ndarray\n        Moments of the occupied self-energy.\n    th_prev : numpy.ndarray\n        Moments of the occupied self-energy from the previous\n        iteration.\n    tp : numpy.ndarray\n        Moments of the virtual self-energy.\n    tp_prev : numpy.ndarray\n        Moments of the virtual self-energy from the previous iteration.\n\n    Returns\n    -------\n    conv : bool\n        Convergence flag.\n    \"\"\"\n\n    # Get the previous moments\n    if th_prev is None:\n        th_prev = np.zeros_like(th)\n    if tp_prev is None:\n        tp_prev = np.zeros_like(tp)\n\n    # Get the HOMO and LUMO errors\n    error_homo = abs(mo_energy[self.nocc - 1] - mo_energy_prev[self.nocc - 1])\n    error_lumo = abs(mo_energy[self.nocc] - mo_energy_prev[self.nocc])\n\n    # Get the moment errors\n    error_th = self._moment_error(th, th_prev)\n    error_tp = self._moment_error(tp, tp_prev)\n\n    # Print the table\n    style_homo = logging.rate(error_homo, self.conv_tol, self.conv_tol * 1e2)\n    style_lumo = logging.rate(error_lumo, self.conv_tol, self.conv_tol * 1e2)\n    style_th = logging.rate(error_th, self.conv_tol_moms, self.conv_tol_moms * 1e2)\n    style_tp = logging.rate(error_tp, self.conv_tol_moms, self.conv_tol_moms * 1e2)\n    table = logging.Table(title=\"Convergence\")\n    table.add_column(\"Sector\", justify=\"right\")\n    table.add_column(\"\u0394 energy\", justify=\"right\")\n    table.add_column(\"\u0394 moments\", justify=\"right\")\n    table.add_row(\n        \"Hole\", f\"[{style_homo}]{error_homo:.3g}[/]\", f\"[{style_th}]{error_th:.3g}[/]\"\n    )\n    table.add_row(\n        \"Particle\", f\"[{style_lumo}]{error_lumo:.3g}[/]\", f\"[{style_tp}]{error_tp:.3g}[/]\"\n    )\n    logging.write(\"\")\n    logging.write(table)\n\n    return self.conv_logical(\n        (\n            max(error_homo, error_lumo) &lt; self.conv_tol,\n            max(error_th, error_tp) &lt; self.conv_tol_moms,\n        )\n    )\n</code></pre>"},{"location":"reference/evgw/#momentGW.evgw.evGW.remove_unphysical_poles","title":"<code>momentGW.evgw.evGW.remove_unphysical_poles(gf)</code>","text":"<p>Remove unphysical poles from the Green's function to stabilise iterations, according to the threshold <code>self.weight_tol</code>.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>Lehmann</code> <p>Green's function object.</p> required <p>Returns:</p> Name Type Description <code>gf_out</code> <code>Lehmann</code> <p>Green's function, with potentially fewer poles.</p> Source code in <code>momentGW/evgw.py</code> <pre><code>def remove_unphysical_poles(self, gf):\n    \"\"\"\n    Remove unphysical poles from the Green's function to stabilise\n    iterations, according to the threshold `self.weight_tol`.\n\n    Parameters\n    ----------\n    gf : dyson.Lehmann\n        Green's function object.\n\n    Returns\n    -------\n    gf_out : dyson.Lehmann\n        Green's function, with potentially fewer poles.\n    \"\"\"\n    return gf.physical(weight=self.weight_tol)\n</code></pre>"},{"location":"reference/evgw/#momentGW.evgw.kernel","title":"<code>momentGW.evgw.kernel(gw, nmom_max, moments=None, integrals=None)</code>","text":"<p>Moment-constrained eigenvalue self-consistent GW.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseGW</code> <p>GW object.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>moments</code> <code>tuple of numpy.ndarray</code> <p>Tuple of (hole, particle) moments, if passed then they will be used  as the initial guess instead of calculating them. Default value is <code>None</code>.</p> <code>None</code> <code>integrals</code> <code>BaseIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>conv</code> <code>bool</code> <p>Convergence flag.</p> <code>gf</code> <code>Lehmann</code> <p>Green's function object.</p> <code>se</code> <code>Lehmann</code> <p>Self-energy object.</p> <code>qp_energy</code> <code>ndarray</code> <p>Quasiparticle energies. Always None for evGW, returned for compatibility with other evGW methods.</p> Source code in <code>momentGW/evgw.py</code> <pre><code>def kernel(\n    gw,\n    nmom_max,\n    moments=None,\n    integrals=None,\n):\n    \"\"\"\n    Moment-constrained eigenvalue self-consistent GW.\n\n    Parameters\n    ----------\n    gw : BaseGW\n        GW object.\n    nmom_max : int\n        Maximum moment number to calculate.\n    moments : tuple of numpy.ndarray, optional\n        Tuple of (hole, particle) moments, if passed then they will\n        be used  as the initial guess instead of calculating them.\n        Default value is `None`.\n    integrals : BaseIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    conv : bool\n        Convergence flag.\n    gf : dyson.Lehmann\n        Green's function object.\n    se : dyson.Lehmann\n        Self-energy object.\n    qp_energy : numpy.ndarray\n        Quasiparticle energies. Always None for evGW, returned for\n        compatibility with other evGW methods.\n    \"\"\"\n\n    if gw.polarizability.lower() == \"drpa-exact\":\n        raise NotImplementedError(\"%s for polarizability=%s\" % (gw.name, gw.polarizability))\n\n    # Get the integrals\n    if integrals is None:\n        integrals = gw.ao2mo()\n\n    # Initialise the orbitals\n    mo_energy = gw.mo_energy.copy()\n\n    # Get the DIIS object\n    diis = util.DIIS()\n    diis.space = gw.diis_space\n\n    # Get the static part of the SE\n    se_static = gw.build_se_static(integrals)\n\n    # Initialise convergence quantities\n    conv = False\n    th_prev = tp_prev = None\n\n    for cycle in range(1, gw.max_cycle + 1):\n        with logging.with_status(f\"Iteration {cycle}\"):\n            with logging.with_comment(f\"Start of iteration {cycle}\"):\n                logging.write(\"\")\n\n            # Update the moments of the SE\n            if moments is not None and cycle == 1:\n                th, tp = moments\n            else:\n                th, tp = gw.build_se_moments(\n                    nmom_max,\n                    integrals,\n                    mo_energy=dict(\n                        g=mo_energy if not gw.g0 else gw.mo_energy,\n                        w=mo_energy if not gw.w0 else gw.mo_energy,\n                    ),\n                )\n\n            # Extrapolate the moments\n            try:\n                th, tp = diis.update_with_scaling(np.array((th, tp)), (-2, -1))\n            except Exception:\n                logging.warn(f\"DIIS step [red]failed[/] at iteration {cycle}\")\n\n            # Damp the moments\n            if gw.damping != 0.0 and cycle &gt; 1:\n                th = gw.damping * th_prev + (1.0 - gw.damping) * th\n                tp = gw.damping * tp_prev + (1.0 - gw.damping) * tp\n\n            # Solve the Dyson equation\n            gf, se = gw.solve_dyson(th, tp, se_static, integrals=integrals)\n            gf = gw.remove_unphysical_poles(gf)\n\n            # Update the MO energies\n            mo_energy_prev = mo_energy.copy()\n            mo_energy = gw._gf_to_mo_energy(gf)\n\n            # Check for convergence\n            conv = gw.check_convergence(mo_energy, mo_energy_prev, th, th_prev, tp, tp_prev)\n            th_prev = th.copy()\n            tp_prev = tp.copy()\n            with logging.with_comment(f\"End of iteration {cycle}\"):\n                logging.write(\"\")\n            if conv:\n                break\n\n    return conv, gf, se, None\n</code></pre>"},{"location":"reference/fock/","title":"Fock","text":"<p>Fock matrix self-consistent loop.</p>"},{"location":"reference/fock/#momentGW.fock.ChemicalPotentialError","title":"<code>momentGW.fock.ChemicalPotentialError</code>","text":"<p>             Bases: <code>ValueError</code></p> <p>Exception raised when the chemical potential cannot be found.</p>"},{"location":"reference/fock/#momentGW.fock.BaseFockLoop","title":"<code>momentGW.fock.BaseFockLoop(gw, gf=None, se=None, **kwargs)</code>","text":"<p>Base class for Fock loops.</p> Source code in <code>momentGW/fock.py</code> <pre><code>def __init__(self, gw, gf=None, se=None, **kwargs):\n    # Parameters\n    self.gw = gw\n\n    # Options\n    for key, val in kwargs.items():\n        if not hasattr(self, key):\n            raise AttributeError(f\"{key} is not a valid option for {self.name}\")\n        setattr(self, key, val)\n\n    # Attributes\n    self._h1e = None\n    self.converged = None\n    self.gf = gf if gf is not None else gw.init_gf()\n    self.se = se\n\n    # Logging\n    init_logging()\n</code></pre>"},{"location":"reference/fock/#momentGW.fock.BaseFockLoop.h1e","title":"<code>momentGW.fock.BaseFockLoop.h1e</code>  <code>property</code>","text":"<p>Get the core Hamiltonian.</p>"},{"location":"reference/fock/#momentGW.fock.BaseFockLoop.mo_coeff","title":"<code>momentGW.fock.BaseFockLoop.mo_coeff</code>  <code>property</code>","text":"<p>Get the MO coefficients.</p>"},{"location":"reference/fock/#momentGW.fock.BaseFockLoop.nmo","title":"<code>momentGW.fock.BaseFockLoop.nmo</code>  <code>property</code>","text":"<p>Get the number of MOs.</p>"},{"location":"reference/fock/#momentGW.fock.BaseFockLoop.nocc","title":"<code>momentGW.fock.BaseFockLoop.nocc</code>  <code>property</code>","text":"<p>Get the number of occupied MOs.</p>"},{"location":"reference/fock/#momentGW.fock.BaseFockLoop.auxiliary_shift","title":"<code>momentGW.fock.BaseFockLoop.auxiliary_shift(fock=None, se=None)</code>","text":"<p>Optimise a shift in the auxiliary energies to best satisfy the electron number.</p> Source code in <code>momentGW/fock.py</code> <pre><code>def auxiliary_shift(self, fock=None, se=None):\n    \"\"\"\n    Optimise a shift in the auxiliary energies to best satisfy the\n    electron number.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/fock/#momentGW.fock.BaseFockLoop.solve_dyson","title":"<code>momentGW.fock.BaseFockLoop.solve_dyson(fock=None, se=None, chempot=0.0)</code>","text":"<p>Solve the Dyson equation for a given Fock matrix.</p> Source code in <code>momentGW/fock.py</code> <pre><code>def solve_dyson(self, fock=None, se=None, chempot=0.0):\n    \"\"\"Solve the Dyson equation for a given Fock matrix.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/fock/#momentGW.fock.BaseFockLoop.search_chempot","title":"<code>momentGW.fock.BaseFockLoop.search_chempot(gf=None)</code>","text":"<p>Search for a chemical potential.</p> Source code in <code>momentGW/fock.py</code> <pre><code>def search_chempot(self, gf=None):\n    \"\"\"Search for a chemical potential.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/fock/#momentGW.fock.BaseFockLoop.make_rdm1","title":"<code>momentGW.fock.BaseFockLoop.make_rdm1(gf=None)</code>","text":"<p>Get the first-order reduced density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>Lehmann</code> <p>Green's function object. If <code>None</code>, use either <code>self.gf</code>, or the mean-field Green's function. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>rdm1</code> <code>ndarray</code> <p>First-order reduced density matrix.</p> Source code in <code>momentGW/fock.py</code> <pre><code>def make_rdm1(self, gf=None):\n    \"\"\"Get the first-order reduced density matrix.\n\n    Parameters\n    ----------\n    gf : dyson.Lehmann, optional\n        Green's function object. If `None`, use either `self.gf`, or\n        the mean-field Green's function. Default value is `None`.\n\n    Returns\n    -------\n    rdm1 : numpy.ndarray\n        First-order reduced density matrix.\n    \"\"\"\n    if gf is None:\n        gf = self.gf\n    return self.gw.make_rdm1(gf=gf)\n</code></pre>"},{"location":"reference/fock/#momentGW.fock.BaseFockLoop.get_fock","title":"<code>momentGW.fock.BaseFockLoop.get_fock(integrals, rdm1, h1e=None)</code>","text":"<p>Get the Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>integrals</code> <code>BaseIntegrals</code> <p>Integrals object.</p> required <code>rdm1</code> <code>ndarray</code> <p>First-order reduced density matrix.</p> required <code>h1e</code> <code>ndarray</code> <p>Core Hamiltonian. If <code>None</code>, use <code>self.h1e</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>fock</code> <code>ndarray</code> <p>Fock matrix.</p> Source code in <code>momentGW/fock.py</code> <pre><code>def get_fock(self, integrals, rdm1, h1e=None):\n    \"\"\"Get the Fock matrix.\n\n    Parameters\n    ----------\n    integrals : BaseIntegrals\n        Integrals object.\n    rdm1 : numpy.ndarray\n        First-order reduced density matrix.\n    h1e : numpy.ndarray, optional\n        Core Hamiltonian. If `None`, use `self.h1e`. Default value\n        is `None`.\n\n    Returns\n    -------\n    fock : numpy.ndarray\n        Fock matrix.\n    \"\"\"\n    if h1e is None:\n        h1e = self.h1e\n    return integrals.get_fock(rdm1, h1e)\n</code></pre>"},{"location":"reference/fock/#momentGW.fock.FockLoop","title":"<code>momentGW.fock.FockLoop(gw, gf=None, se=None, **kwargs)</code>","text":"<p>             Bases: <code>BaseFockLoop</code></p> <p>Self-consistent loop for the density matrix via the Hartree--Fock self-consistent field for spin-restricted molecular systems.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseGW</code> <p>GW object.</p> required <code>gf</code> <code>Lehmann</code> <p>Initial Green's function object. If <code>None</code>, use <code>gw.init_gf()</code>. Default value is <code>None</code>.</p> <code>None</code> <code>se</code> <code>Lehmann</code> <p>Initial self-energy object. If passed, use as dynamic part of the self-energy. If <code>None</code>, self-energy is assumed to be static and fully defined by the Fock matrix. Default value is <code>None</code>.</p> <code>None</code> <code>fock_diis_space</code> <code>int</code> <p>DIIS space size for the Fock matrix. Default value is <code>10</code>.</p> required <code>fock_diis_min_space</code> <code>int</code> <p>Minimum DIIS space size for the Fock matrix. Default value is <code>1</code>.</p> required <code>conv_tol_nelec</code> <code>float</code> <p>Convergence tolerance for the number of electrons. Default value is <code>1e-6</code>.</p> required <code>conv_tol_rdm1</code> <code>float</code> <p>Convergence tolerance for the density matrix. Default value is <code>1e-8</code>.</p> required <code>max_cycle_inner</code> <code>int</code> <p>Maximum number of inner iterations. Default value is <code>100</code>.</p> required <code>max_cycle_outer</code> <code>int</code> <p>Maximum number of outer iterations. Default value is <code>20</code>.</p> required Source code in <code>momentGW/fock.py</code> <pre><code>def __init__(self, gw, gf=None, se=None, **kwargs):\n    # Parameters\n    self.gw = gw\n\n    # Options\n    for key, val in kwargs.items():\n        if not hasattr(self, key):\n            raise AttributeError(f\"{key} is not a valid option for {self.name}\")\n        setattr(self, key, val)\n\n    # Attributes\n    self._h1e = None\n    self.converged = None\n    self.gf = gf if gf is not None else gw.init_gf()\n    self.se = se\n\n    # Logging\n    init_logging()\n</code></pre>"},{"location":"reference/fock/#momentGW.fock.FockLoop.naux","title":"<code>momentGW.fock.FockLoop.naux</code>  <code>property</code>","text":"<p>Get the number of auxiliary states.</p>"},{"location":"reference/fock/#momentGW.fock.FockLoop.nqmo","title":"<code>momentGW.fock.FockLoop.nqmo</code>  <code>property</code>","text":"<p>Get the number of quasiparticle MOs.</p>"},{"location":"reference/fock/#momentGW.fock.FockLoop.nelec","title":"<code>momentGW.fock.FockLoop.nelec</code>  <code>property</code>","text":"<p>Get the number of electrons.</p>"},{"location":"reference/fock/#momentGW.fock.FockLoop.auxiliary_shift","title":"<code>momentGW.fock.FockLoop.auxiliary_shift(fock, se=None)</code>","text":"<p>Optimise a shift in the auxiliary energies to best satisfy the electron number.</p> <p>Parameters:</p> Name Type Description Default <code>fock</code> <code>ndarray</code> <p>Fock matrix.</p> required <code>se</code> <code>Lehmann</code> <p>Self-energy. If <code>None</code>, use <code>self.se</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>se</code> <code>Lehmann</code> <p>Self-energy.</p> Notes <p>If there is no dynamic part of the self-energy (<code>self.se</code> is <code>None</code>), this method returns <code>None</code>.</p> Source code in <code>momentGW/fock.py</code> <pre><code>def auxiliary_shift(self, fock, se=None):\n    \"\"\"\n    Optimise a shift in the auxiliary energies to best satisfy the\n    electron number.\n\n    Parameters\n    ----------\n    fock : numpy.ndarray\n        Fock matrix.\n    se : dyson.Lehmann, optional\n        Self-energy. If `None`, use `self.se`. Default value is\n        `None`.\n\n    Returns\n    -------\n    se : dyson.Lehmann\n        Self-energy.\n\n    Notes\n    -----\n    If there is no dynamic part of the self-energy (`self.se` is\n    `None`), this method returns `None`.\n    \"\"\"\n\n    # Get the self-energy\n    if se is None:\n        se = self.se\n    if se is None:\n        return None\n\n    # Optimise the shift in the auxiliary energies\n    se, opt = minimize_chempot(\n        se,\n        fock,\n        self.nelec,\n        x0=se.chempot,\n        tol=self.conv_tol_nelec,\n        maxiter=self.max_cycle_inner,\n    )\n\n    return se\n</code></pre>"},{"location":"reference/fock/#momentGW.fock.FockLoop.search_chempot","title":"<code>momentGW.fock.FockLoop.search_chempot(gf=None)</code>","text":"<p>Search for a chemical potential for a given Green's function.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>Lehmann</code> <p>Green's function. If <code>None</code>, use <code>self.gf</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>chempot</code> <code>float</code> <p>Chemical potential.</p> <code>nerr</code> <code>float</code> <p>Error in the number of electrons.</p> Source code in <code>momentGW/fock.py</code> <pre><code>def search_chempot(self, gf=None):\n    \"\"\"Search for a chemical potential for a given Green's function.\n\n    Parameters\n    ----------\n    gf : dyson.Lehmann, optional\n        Green's function. If `None`, use `self.gf`. Default value is\n        `None`.\n\n    Returns\n    -------\n    chempot : float\n        Chemical potential.\n    nerr : float\n        Error in the number of electrons.\n    \"\"\"\n\n    # Get the Green's function\n    if gf is None:\n        gf = self.gf\n\n    # Search for the chemical potential\n    chempot, nerr = search_chempot(gf.energies, gf.couplings, self.nmo, self.nelec)\n    nerr = abs(nerr)\n\n    return chempot, nerr\n</code></pre>"},{"location":"reference/fock/#momentGW.fock.FockLoop.solve_dyson","title":"<code>momentGW.fock.FockLoop.solve_dyson(fock, se=None)</code>","text":"<p>Solve the Dyson equation for a given Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>fock</code> <code>ndarray</code> <p>Fock matrix.</p> required <code>se</code> <code>Lehmann</code> <p>Self-energy. If <code>None</code>, use <code>self.se</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>gf</code> <code>Lehmann</code> <p>Green's function.</p> <code>nerr</code> <code>float</code> <p>Error in the number of electrons.</p> Notes <p>If there is no dynamic part of the self-energy (<code>self.se</code> is <code>None</code>), this method simply diagonalises the Fock matrix and returns the Lehmann representation of the resulting zeroth-order Green's function.</p> Source code in <code>momentGW/fock.py</code> <pre><code>def solve_dyson(self, fock, se=None):\n    \"\"\"Solve the Dyson equation for a given Fock matrix.\n\n    Parameters\n    ----------\n    fock : numpy.ndarray\n        Fock matrix.\n    se : dyson.Lehmann, optional\n        Self-energy. If `None`, use `self.se`. Default value is\n        `None`.\n\n    Returns\n    -------\n    gf : dyson.Lehmann\n        Green's function.\n    nerr : float\n        Error in the number of electrons.\n\n    Notes\n    -----\n    If there is no dynamic part of the self-energy (`self.se` is\n    `None`), this method simply diagonalises the Fock matrix and\n    returns the Lehmann representation of the resulting zeroth-order\n    Green's function.\n    \"\"\"\n\n    # Get the self-energy\n    if se is None:\n        se = self.se\n\n    # Diagonalise the (extended) Fock matrix\n    if se is None:\n        e, c = np.linalg.eigh(fock)\n    else:\n        e, c = se.diagonalise_matrix(fock, chempot=0.0)\n\n    # Broadcast the eigenvalues and eigenvectors in case of\n    # hybrid parallelisation introducing non-determinism\n    e = mpi_helper.bcast(e, root=0)\n    c = mpi_helper.bcast(c, root=0)\n\n    # Construct the Green's function\n    gf = Lehmann(e, c[: self.nmo], chempot=se.chempot if se is not None else 0.0)\n\n    # Search for the chemical potential\n    gf.chempot, nerr = self.search_chempot(gf)\n\n    return gf, nerr\n</code></pre>"},{"location":"reference/fock/#momentGW.fock.FockLoop.kernel","title":"<code>momentGW.fock.FockLoop.kernel(integrals=None)</code>","text":"<p>Driver for the Fock loop.</p> <p>Parameters:</p> Name Type Description Default <code>integrals</code> <code>Integrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>converged</code> <code>bool</code> <p>Whether the loop has converged.</p> <code>gf</code> <code>Lehmann</code> <p>Green's function object.</p> <code>se</code> <code>Lehmann</code> <p>Self-energy object.</p> Source code in <code>momentGW/fock.py</code> <pre><code>@logging.with_timer(\"Fock loop\")\n@logging.with_status(\"Running Fock loop\")\ndef kernel(self, integrals=None):\n    \"\"\"Driver for the Fock loop.\n\n    Parameters\n    ----------\n    integrals : Integrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    converged : bool\n        Whether the loop has converged.\n    gf : dyson.Lehmann\n        Green's function object.\n    se : dyson.Lehmann\n        Self-energy object.\n    \"\"\"\n\n    # Get the kernel\n    if self.se is None:\n        kernel = self._kernel_static\n    else:\n        kernel = self._kernel_dynamic\n\n    # Run the kernel\n    self.converged, self.gf, self.se = kernel(integrals=integrals)\n\n    return self.converged, self.gf, self.se\n</code></pre>"},{"location":"reference/fock/#momentGW.fock.search_chempot","title":"<code>momentGW.fock.search_chempot(w, v, nphys, nelec, occupancy=2)</code>","text":"<p>Search for a chemical potential.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>ndarray</code> <p>Eigenvalues.</p> required <code>v</code> <code>ndarray</code> <p>Eigenvectors.</p> required <code>nphys</code> <code>int</code> <p>Number of physical states.</p> required <code>nelec</code> <code>int</code> <p>Number of electrons.</p> required <code>occupancy</code> <code>int</code> <p>Number of electrons per state. Default value is <code>2</code>.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>chempot</code> <code>float</code> <p>Chemical potential.</p> <code>error</code> <code>float</code> <p>Error in the number of electrons.</p> Source code in <code>momentGW/fock.py</code> <pre><code>def search_chempot(w, v, nphys, nelec, occupancy=2):\n    \"\"\"\n    Search for a chemical potential.\n\n    Parameters\n    ----------\n    w : numpy.ndarray\n        Eigenvalues.\n    v : numpy.ndarray\n        Eigenvectors.\n    nphys : int\n        Number of physical states.\n    nelec : int\n        Number of electrons.\n    occupancy : int, optional\n        Number of electrons per state. Default value is `2`.\n\n    Returns\n    -------\n    chempot : float\n        Chemical potential.\n    error : float\n        Error in the number of electrons.\n    \"\"\"\n\n    if nelec == 0:\n        return w[0] - 1e-6, 0.0\n\n    nmo = v.shape[-1]\n    sum0 = sum1 = 0.0\n\n    for i in range(nmo):\n        n = occupancy * np.dot(v[:nphys, i].conj().T, v[:nphys, i]).real\n        sum0, sum1 = sum1, sum1 + n\n\n        if i &gt; 0 and sum0 &lt;= nelec and nelec &lt;= sum1:\n            break\n\n    if abs(sum0 - nelec) &lt; abs(sum1 - nelec):\n        homo = i - 1\n        error = nelec - sum0\n    else:\n        homo = i\n        error = nelec - sum1\n\n    lumo = homo + 1\n\n    if lumo == len(w):\n        chempot = w[homo] + 1e-6\n    else:\n        chempot = 0.5 * (w[homo] + w[lumo])\n\n    return chempot, error\n</code></pre>"},{"location":"reference/fock/#momentGW.fock.minimize_chempot","title":"<code>momentGW.fock.minimize_chempot(se, fock, nelec, occupancy=2, x0=0.0, tol=1e-06, maxiter=200)</code>","text":"<p>Optimise the shift in auxiliary energies to satisfy the electron number.</p> <p>Parameters:</p> Name Type Description Default <code>se</code> <code>Lehmann</code> <p>Self-energy object.</p> required <code>fock</code> <code>ndarray</code> <p>Fock matrix.</p> required <code>nelec</code> <code>int</code> <p>Number of electrons.</p> required <code>occupancy</code> <code>int</code> <p>Number of electrons per state. Default value is <code>2</code>.</p> <code>2</code> <code>x0</code> <code>float</code> <p>Initial guess value. Default value is <code>0.0</code>.</p> <code>0.0</code> <code>tol</code> <code>float</code> <p>Threshold in the number of electrons. Default value is <code>1e-6</code>.</p> <code>1e-06</code> <code>maxiter</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>200</code>.</p> <code>200</code> <p>Returns:</p> Name Type Description <code>se</code> <code>Lehmann</code> <p>Self-energy object.</p> <code>opt</code> <code>OptimizeResult</code> <p>Result of the optimisation.</p> Source code in <code>momentGW/fock.py</code> <pre><code>@logging.with_timer(\"Chemical potential optimisation\")\n@logging.with_status(\"Optimising chemical potential\")\ndef minimize_chempot(se, fock, nelec, occupancy=2, x0=0.0, tol=1e-6, maxiter=200):\n    \"\"\"\n    Optimise the shift in auxiliary energies to satisfy the electron\n    number.\n\n    Parameters\n    ----------\n    se : dyson.Lehmann\n        Self-energy object.\n    fock : numpy.ndarray\n        Fock matrix.\n    nelec : int\n        Number of electrons.\n    occupancy : int, optional\n        Number of electrons per state. Default value is `2`.\n    x0 : float, optional\n        Initial guess value. Default value is `0.0`.\n    tol : float, optional\n        Threshold in the number of electrons. Default value is `1e-6`.\n    maxiter : int, optional\n        Maximum number of iterations. Default value is `200`.\n\n    Returns\n    -------\n    se : dyson.Lehmann\n        Self-energy object.\n    opt : scipy.optimize.OptimizeResult\n        Result of the optimisation.\n    \"\"\"\n\n    tol = tol**2  # we minimize the squared error\n    dtype = np.result_type(se.dtype, fock.dtype)\n    nphys = se.nphys\n    naux = se.naux\n    buf = np.zeros(((nphys + naux) ** 2,), dtype=dtype)\n    fargs = (se, fock, nelec, occupancy, buf)\n\n    options = dict(maxfun=maxiter, ftol=tol, xtol=tol, gtol=tol)\n    kwargs = dict(x0=x0, method=\"TNC\", jac=True, options=options)\n    fun = _gradient\n\n    opt = scipy.optimize.minimize(fun, args=fargs, **kwargs)\n\n    se.energies -= opt.x\n    w, v = se.diagonalise_matrix(fock)\n    se.chempot = search_chempot(w, v, se.nphys, nelec, occupancy=occupancy)[0]\n\n    return se, opt\n</code></pre>"},{"location":"reference/fsgw/","title":"Fsgw","text":"<p>Spin-restricted Fock matrix self-consistent GW via self-energy moment constraints for molecular systems.</p>"},{"location":"reference/fsgw/#momentGW.fsgw.fsGW","title":"<code>momentGW.fsgw.fsGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>GW</code></p> <p>Spin-restricted Fock matrix self-consistent GW via self-energy moment constraints for molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>SCF</code> <p>PySCF mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>max_cycle</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>50</code>.</p> required <code>conv_tol</code> <code>float</code> <p>Convergence threshold in the change in the HOMO and LUMO. Default value is <code>1e-8</code>.</p> required <code>conv_tol_moms</code> <code>float</code> <p>Convergence threshold in the change in the moments. Default value is <code>1e-8</code>.</p> required <code>conv_logical</code> <code>callable</code> <p>Function that takes an iterable of booleans as input indicating whether the individual <code>conv_tol</code>, <code>conv_tol_moms</code> have been satisfied, respectively, and returns a boolean indicating overall convergence. For example, the function <code>all</code> requires both metrics to be met, and <code>any</code> requires just one. Default value is <code>all</code>.</p> required <code>diis_space</code> <code>int</code> <p>Size of the DIIS extrapolation space. Default value is <code>8</code>.</p> required <code>damping</code> <code>float</code> <p>Damping parameter. Default value is <code>0.0</code>.</p> required <code>solver</code> <code>BaseGW</code> <p>Solver to use to obtain the self-energy. Compatible with any <code>BaseGW</code>-like class. Default value is <code>momentGW.gw.GW</code>.</p> required <code>solver_options</code> <code>dict</code> <p>Keyword arguments to pass to the solver. Default value is an empty <code>dict</code>.</p> required Source code in <code>momentGW/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Attributes\n    self.converged = None\n    self.se = None\n    self.gf = None\n    self._qp_energy = None\n</code></pre>"},{"location":"reference/fsgw/#momentGW.fsgw.fsGW.name","title":"<code>momentGW.fsgw.fsGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/fsgw/#momentGW.fsgw.kernel","title":"<code>momentGW.fsgw.kernel(gw, nmom_max, moments=None, integrals=None)</code>","text":"<p>Moment-constrained Fock matrix self-consistent GW.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseGW</code> <p>GW object.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>moments</code> <code>tuple of numpy.ndarray</code> <p>Tuple of (hole, particle) moments, if passed then they will be used  as the initial guess instead of calculating them. Default value is <code>None</code>.</p> <code>None</code> <code>integrals</code> <code>BaseIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>conv</code> <code>bool</code> <p>Convergence flag.</p> <code>gf</code> <code>Lehmann</code> <p>Green's function object.</p> <code>se</code> <code>Lehmann</code> <p>Self-energy object.</p> <code>qp_energy</code> <code>ndarray</code> <p>Quasiparticle energies.</p> Source code in <code>momentGW/fsgw.py</code> <pre><code>def kernel(\n    gw,\n    nmom_max,\n    moments=None,\n    integrals=None,\n):\n    \"\"\"\n    Moment-constrained Fock matrix self-consistent GW.\n\n    Parameters\n    ----------\n    gw : BaseGW\n        GW object.\n    nmom_max : int\n        Maximum moment number to calculate.\n    moments : tuple of numpy.ndarray, optional\n        Tuple of (hole, particle) moments, if passed then they will\n        be used  as the initial guess instead of calculating them.\n        Default value is `None`.\n    integrals : BaseIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    conv : bool\n        Convergence flag.\n    gf : dyson.Lehmann\n        Green's function object.\n    se : dyson.Lehmann\n        Self-energy object.\n    qp_energy : numpy.ndarray\n        Quasiparticle energies.\n    \"\"\"\n\n    # Get the integrals\n    if integrals is None:\n        integrals = gw.ao2mo()\n\n    # Initialise the orbitals\n    mo_energy = gw.mo_energy.copy()\n    mo_coeff = gw.mo_coeff.copy()\n\n    with util.SilentSCF(gw._scf):\n        # Get the overlap\n        ovlp = gw._scf.get_ovlp()\n\n        # Get the core Hamiltonian\n        h1e_ao = gw._scf.get_hcore()\n        h1e = util.einsum(\"...pq,...pi,...qj-&gt;...ij\", h1e_ao, np.conj(gw.mo_coeff), gw.mo_coeff)\n\n    # Initialise the DIIS object\n    diis = util.DIIS()\n    diis.space = gw.diis_space\n\n    # Get the solver\n    solver_options = {} if not gw.solver_options else gw.solver_options.copy()\n    for key in gw.solver._opts:\n        solver_options[key] = solver_options.get(key, getattr(gw, key, getattr(gw.solver, key)))\n    with logging.with_silent():\n        subgw = gw.solver(gw._scf, **solver_options)\n        subgw.frozen = gw.frozen\n        gf = subgw.init_gf()\n\n    # Initialise convergence quantities\n    conv = False\n    mo_energy_prev = th_prev = tp_prev = None\n\n    for cycle in range(1, gw.max_cycle + 1):\n        with logging.with_comment(f\"Start of iteration {cycle}\"):\n            logging.write(\"\")\n\n        with logging.with_status(f\"Iteration {cycle}\"):\n            # Update the Fock matrix\n            dm = subgw.make_rdm1(gf=gf)\n            fock = integrals.get_fock(dm, h1e)\n            fock = diis.update(fock)\n\n            # Update the MOs\n            mo_energy_prev = mo_energy.copy()\n            mo_energy, u = np.linalg.eigh(fock)\n            u = mpi_helper.bcast(u, root=0)\n            mo_coeff = util.einsum(\"...pi,...ij-&gt;...pj\", gw.mo_coeff, u)\n\n            # Update the self-energy\n            mo_energy_full = gw.mo_energy_with_frozen.copy()\n            mo_energy_full[..., gw.active] = mo_energy\n            subgw.mo_energy = mo_energy_full\n            mo_coeff_full = gw.mo_coeff_with_frozen.copy()\n            mo_coeff_full[..., gw.active] = mo_coeff\n            subgw.mo_coeff = mo_coeff_full\n            subconv, gf, se, _ = subgw._kernel(nmom_max)\n            gf = gw.project_basis(gf, ovlp, mo_coeff, gw.mo_coeff)\n            se = gw.project_basis(se, ovlp, mo_coeff, gw.mo_coeff)\n\n            # Update the moments\n            th, tp = gw.self_energy_to_moments(se, nmom_max)\n\n            # Damp the moments\n            if gw.damping != 0.0 and cycle &gt; 1:\n                th = gw.damping * th_prev + (1.0 - gw.damping) * th\n                tp = gw.damping * tp_prev + (1.0 - gw.damping) * tp\n\n            # Check for convergence\n            conv = gw.check_convergence(mo_energy, mo_energy_prev, th, th_prev, tp, tp_prev)\n            th_prev = th.copy()\n            tp_prev = tp.copy()\n            with logging.with_comment(f\"End of iteration {cycle}\"):\n                logging.write(\"\")\n            if conv:\n                break\n\n    return conv, gf, se, mo_energy\n</code></pre>"},{"location":"reference/gw/","title":"Gw","text":"<p>Spin-restricted one-shot GW via self-energy moment constraints for molecular systems.</p>"},{"location":"reference/gw/#momentGW.gw.GW","title":"<code>momentGW.gw.GW(mf, **kwargs)</code>","text":"<p>             Bases: <code>BaseGW</code></p> <p>Spin-restricted one-shot GW via self-energy moment constraints for molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>SCF</code> <p>PySCF mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required Notes <p>This approach is described in [1]_.</p> References <p>.. [1] C. J. C. Scott, O. J. Backhouse, and G. H. Booth, 158, 12,     2023.</p> Source code in <code>momentGW/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Attributes\n    self.converged = None\n    self.se = None\n    self.gf = None\n    self._qp_energy = None\n</code></pre>"},{"location":"reference/gw/#momentGW.gw.GW.name","title":"<code>momentGW.gw.GW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/gw/#momentGW.gw.GW.build_se_static","title":"<code>momentGW.gw.GW.build_se_static(integrals)</code>","text":"<p>Build the static part of the self-energy, including the Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>integrals</code> <code>Integrals</code> <p>Integrals object.</p> required <p>Returns:</p> Name Type Description <code>se_static</code> <code>ndarray</code> <p>Static part of the self-energy. If <code>self.diagonal_se</code>, non-diagonal elements are set to zero.</p> Source code in <code>momentGW/gw.py</code> <pre><code>@logging.with_timer(\"Static self-energy\")\n@logging.with_status(\"Building static self-energy\")\ndef build_se_static(self, integrals):\n    \"\"\"\n    Build the static part of the self-energy, including the Fock\n    matrix.\n\n    Parameters\n    ----------\n    integrals : Integrals\n        Integrals object.\n\n    Returns\n    -------\n    se_static : numpy.ndarray\n        Static part of the self-energy. If `self.diagonal_se`,\n        non-diagonal elements are set to zero.\n    \"\"\"\n\n    # Get intermediates\n    mask = self.active\n    dm = self._scf.make_rdm1(mo_coeff=self._mo_coeff)\n\n    # Get the contribution from the exchange-correlation potential\n    if getattr(self._scf, \"xc\", \"hf\") == \"hf\":\n        se_static = np.zeros_like(dm)\n        se_static = se_static[..., mask, :][..., :, mask]\n    else:\n        with util.SilentSCF(self._scf):\n            veff = self._scf.get_veff(None, dm)[..., mask, :][..., :, mask]\n            vj = self._scf.get_j(None, dm)[..., mask, :][..., :, mask]\n\n        vhf = integrals.get_veff(dm, j=vj, basis=\"ao\")\n        se_static = vhf - veff\n        se_static = util.einsum(\n            \"...pq,...pi,...qj-&gt;...ij\", se_static, np.conj(self.mo_coeff), self.mo_coeff\n        )\n\n    # If diagonal approximation, set non-diagonal elements to zero\n    if self.diagonal_se:\n        se_static = util.einsum(\"...pq,pq-&gt;...pq\", se_static, np.eye(se_static.shape[-1]))\n\n    # Add the Fock matrix contribution\n    se_static += util.einsum(\"...p,...pq-&gt;...pq\", self.mo_energy, np.eye(se_static.shape[-1]))\n\n    return se_static\n</code></pre>"},{"location":"reference/gw/#momentGW.gw.GW.build_se_moments","title":"<code>momentGW.gw.GW.build_se_moments(nmom_max, integrals, **kwargs)</code>","text":"<p>Build the moments of the self-energy.</p> <p>Parameters:</p> Name Type Description Default <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>integrals</code> <code>Integrals</code> <p>Integrals object.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments passed to polarizability class.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>se_moments_hole</code> <code>ndarray</code> <p>Moments of the hole self-energy. If <code>self.diagonal_se</code>, non-diagonal elements are set to zero.</p> <code>se_moments_part</code> <code>ndarray</code> <p>Moments of the particle self-energy. If <code>self.diagonal_se</code>, non-diagonal elements are set to zero.</p> See Also <p>momentGW.rpa.dRPA momentGW.tda.dTDA momentGW.thc.dTDA</p> Source code in <code>momentGW/gw.py</code> <pre><code>def build_se_moments(self, nmom_max, integrals, **kwargs):\n    \"\"\"Build the moments of the self-energy.\n\n    Parameters\n    ----------\n    nmom_max : int\n        Maximum moment number to calculate.\n    integrals : Integrals\n        Integrals object.\n    **kwargs : dict, optional\n       Additional keyword arguments passed to polarizability class.\n\n    Returns\n    -------\n    se_moments_hole : numpy.ndarray\n        Moments of the hole self-energy. If `self.diagonal_se`,\n        non-diagonal elements are set to zero.\n    se_moments_part : numpy.ndarray\n        Moments of the particle self-energy. If `self.diagonal_se`,\n        non-diagonal elements are set to zero.\n\n    See Also\n    --------\n    momentGW.rpa.dRPA\n    momentGW.tda.dTDA\n    momentGW.thc.dTDA\n    \"\"\"\n\n    if self.polarizability.lower() == \"drpa\":\n        rpa = dRPA(self, nmom_max, integrals, **kwargs)\n        return rpa.kernel()\n\n    elif self.polarizability.lower() == \"drpa-exact\":\n        rpa = dRPA(self, nmom_max, integrals, **kwargs)\n        return rpa.kernel(exact=True)\n\n    elif self.polarizability.lower() == \"dtda\":\n        tda = dTDA(self, nmom_max, integrals, **kwargs)\n        return tda.kernel()\n\n    elif self.polarizability.lower() == \"thc-dtda\":\n        tda = thc.dTDA(self, nmom_max, integrals, **kwargs)\n        return tda.kernel()\n\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/gw/#momentGW.gw.GW.ao2mo","title":"<code>momentGW.gw.GW.ao2mo(transform=True)</code>","text":"<p>Get the integrals object.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <code>bool</code> <p>Whether to transform the integrals object.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>integrals</code> <code>Integrals</code> <p>Integrals object.</p> See Also <p>momentGW.ints.Integrals momentGW.thc.Integrals</p> Source code in <code>momentGW/gw.py</code> <pre><code>@logging.with_timer(\"Integral construction\")\n@logging.with_status(\"Constructing integrals\")\ndef ao2mo(self, transform=True):\n    \"\"\"Get the integrals object.\n\n    Parameters\n    ----------\n    transform : bool, optional\n        Whether to transform the integrals object.\n\n    Returns\n    -------\n    integrals : Integrals\n        Integrals object.\n\n    See Also\n    --------\n    momentGW.ints.Integrals\n    momentGW.thc.Integrals\n    \"\"\"\n\n    # Get the integrals class\n    if self.polarizability.lower().startswith(\"thc\"):\n        cls = thc.Integrals\n        kwargs = self.thc_opts\n    else:\n        cls = Integrals\n        kwargs = dict(\n            compression=self.compression,\n            compression_tol=self.compression_tol,\n            # Note: `pyscf.pbc.df` methods don't use `self.prange`\n            # so the MPI solution won't work. Storing the full\n            # tensor is a workaround.\n            store_full=self.fock_loop or hasattr(self.with_df, \"kpts\"),\n        )\n\n    # Get the integrals\n    integrals = cls(\n        self.with_df,\n        self.mo_coeff,\n        self.mo_occ,\n        **kwargs,\n    )\n\n    # Transform the integrals\n    if transform:\n        integrals.transform()\n\n    return integrals\n</code></pre>"},{"location":"reference/gw/#momentGW.gw.GW.solve_dyson","title":"<code>momentGW.gw.GW.solve_dyson(se_moments_hole, se_moments_part, se_static, integrals=None)</code>","text":"<p>Solve the Dyson equation due to a self-energy resulting from a list of hole and particle moments, along with a static contribution.</p> <p>Also finds a chemical potential best satisfying the physical number of electrons. If <code>self.optimise_chempot</code>, this will shift the self-energy poles relative to the Green's function, which is a partial self-consistency that better conserves the particle number.</p> <p>If <code>self.fock_loop</code>, this function will also require that the outputted Green's function is self-consistent with respect to the corresponding density and Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>se_moments_hole</code> <code>ndarray</code> <p>Moments of the hole self-energy.</p> required <code>se_moments_part</code> <code>ndarray</code> <p>Moments of the particle self-energy.</p> required <code>se_static</code> <code>ndarray</code> <p>Static part of the self-energy.</p> required <code>integrals</code> <code>Integrals</code> <p>Integrals object. Required if <code>self.fock_loop</code> is <code>True</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>gf</code> <code>Lehmann</code> <p>Green's function object.</p> <code>se</code> <code>Lehmann</code> <p>Self-energy object.</p> See Also <p>momentGW.fock.FockLoop</p> Source code in <code>momentGW/gw.py</code> <pre><code>def solve_dyson(self, se_moments_hole, se_moments_part, se_static, integrals=None):\n    \"\"\"\n    Solve the Dyson equation due to a self-energy resulting from a\n    list of hole and particle moments, along with a static\n    contribution.\n\n    Also finds a chemical potential best satisfying the physical\n    number of electrons. If `self.optimise_chempot`, this will\n    shift the self-energy poles relative to the Green's function,\n    which is a partial self-consistency that better conserves the\n    particle number.\n\n    If `self.fock_loop`, this function will also require that the\n    outputted Green's function is self-consistent with respect to\n    the corresponding density and Fock matrix.\n\n    Parameters\n    ----------\n    se_moments_hole : numpy.ndarray\n        Moments of the hole self-energy.\n    se_moments_part : numpy.ndarray\n        Moments of the particle self-energy.\n    se_static : numpy.ndarray\n        Static part of the self-energy.\n    integrals : Integrals\n        Integrals object. Required if `self.fock_loop` is `True`.\n        Default value is `None`.\n\n    Returns\n    -------\n    gf : dyson.Lehmann\n        Green's function object.\n    se : dyson.Lehmann\n        Self-energy object.\n\n    See Also\n    --------\n    momentGW.fock.FockLoop\n    \"\"\"\n\n    # Solve the Dyson equation for the moments\n    with logging.with_modifiers(status=\"Solving Dyson equation\", timer=\"Dyson equation\"):\n        solver_occ = MBLSE(se_static, np.array(se_moments_hole))\n        solver_occ.kernel()\n\n        solver_vir = MBLSE(se_static, np.array(se_moments_part))\n        solver_vir.kernel()\n\n        solver = MixedMBLSE(solver_occ, solver_vir)\n        se = solver.get_self_energy()\n\n    # Initialise the solver\n    solver = FockLoop(self, se=se, **self.fock_opts)\n\n    # Shift the self-energy poles relative to the Green's function\n    # to better conserve the particle number\n    if self.optimise_chempot:\n        se = solver.auxiliary_shift(se_static)\n\n    # Find the error in the moments\n    error = self.moment_error(se_moments_hole, se_moments_part, se)\n    logging.write(\n        f\"Error in moments:  [{logging.rate(sum(error), 1e-12, 1e-8)}]{sum(error):.3e}[/] \"\n        f\"(hole = [{logging.rate(error[0], 1e-12, 1e-8)}]{error[0]:.3e}[/], \"\n        f\"particle = [{logging.rate(error[1], 1e-12, 1e-8)}]{error[1]:.3e}[/])\"\n    )\n\n    # Solve the Dyson equation for the self-energy\n    gf, error = solver.solve_dyson(se_static)\n    se.chempot = gf.chempot\n\n    # Self-consistently renormalise the density matrix\n    if self.fock_loop:\n        logging.write(\"\")\n        solver.gf = gf\n        solver.se = se\n        conv, gf, se = solver.kernel(integrals=integrals)\n        _, error = solver.search_chempot(gf)\n\n    # Print the error in the number of electrons\n    logging.write(\"\")\n    style = logging.rate(\n        abs(error),\n        1e-6,\n        1e-6 if self.fock_loop or self.optimise_chempot else 1e-1,\n    )\n    logging.write(f\"Error in number of electrons:  [{style}]{error:.3e}[/]\")\n    logging.write(f\"Chemical potential:  {gf.chempot:.6f}\")\n\n    return gf, se\n</code></pre>"},{"location":"reference/gw/#momentGW.gw.GW.kernel","title":"<code>momentGW.gw.GW.kernel(nmom_max, moments=None, integrals=None)</code>","text":"<p>Driver for the method.</p> <p>Parameters:</p> Name Type Description Default <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>moments</code> <code>tuple of numpy.ndarray</code> <p>Tuple of (hole, particle) moments, if passed then they will be used instead of calculating them. Default value is <code>None</code>.</p> <code>None</code> <code>integrals</code> <code>Integrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>converged</code> <code>bool</code> <p>Whether the solver converged. For single-shot calculations, this is always <code>True</code>.</p> <code>gf</code> <code>Lehmann</code> <p>Green's function object.</p> <code>se</code> <code>Lehmann</code> <p>Self-energy object.</p> <code>qp_energy</code> <code>NoneType</code> <p>Quasiparticle energies. For most GW methods, this is <code>None</code>.</p> Source code in <code>momentGW/gw.py</code> <pre><code>def kernel(\n    self,\n    nmom_max,\n    moments=None,\n    integrals=None,\n):\n    \"\"\"Driver for the method.\n\n    Parameters\n    ----------\n    nmom_max : int\n        Maximum moment number to calculate.\n    moments : tuple of numpy.ndarray, optional\n        Tuple of (hole, particle) moments, if passed then they will\n        be used instead of calculating them. Default value is\n        `None`.\n    integrals : Integrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    converged : bool\n        Whether the solver converged. For single-shot calculations,\n        this is always `True`.\n    gf : dyson.Lehmann\n        Green's function object.\n    se : dyson.Lehmann\n        Self-energy object.\n    qp_energy : NoneType\n        Quasiparticle energies. For most GW methods, this is `None`.\n    \"\"\"\n    return super().kernel(nmom_max, moments=moments, integrals=integrals)\n</code></pre>"},{"location":"reference/gw/#momentGW.gw.GW.make_rdm1","title":"<code>momentGW.gw.GW.make_rdm1(gf=None)</code>","text":"<p>Get the first-order reduced density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>Lehmann</code> <p>Green's function object. If <code>None</code>, use either <code>self.gf</code>, or the mean-field Green's function. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>rdm1</code> <code>ndarray</code> <p>First-order reduced density matrix.</p> Source code in <code>momentGW/gw.py</code> <pre><code>def make_rdm1(self, gf=None):\n    \"\"\"Get the first-order reduced density matrix.\n\n    Parameters\n    ----------\n    gf : dyson.Lehmann, optional\n        Green's function object. If `None`, use either `self.gf`, or\n        the mean-field Green's function. Default value is `None`.\n\n    Returns\n    -------\n    rdm1 : numpy.ndarray\n        First-order reduced density matrix.\n    \"\"\"\n\n    # Get the Green's function\n    if gf is None:\n        gf = self.gf\n    if gf is None:\n        gf = self.init_gf()\n\n    return gf.occupied().moment(0) * 2.0\n</code></pre>"},{"location":"reference/gw/#momentGW.gw.GW.moment_error","title":"<code>momentGW.gw.GW.moment_error(se_moments_hole, se_moments_part, se)</code>","text":"<p>Return the error in the moments.</p> <p>Parameters:</p> Name Type Description Default <code>se_moments_hole</code> <code>ndarray</code> <p>Moments of the hole self-energy.</p> required <code>se_moments_part</code> <code>ndarray</code> <p>Moments of the particle self-energy.</p> required <code>se</code> <code>Lehmann</code> <p>Self-energy object.</p> required <p>Returns:</p> Name Type Description <code>eh</code> <code>float</code> <p>Error in the hole moments.</p> <code>ep</code> <code>float</code> <p>Error in the particle moments.</p> Source code in <code>momentGW/gw.py</code> <pre><code>def moment_error(self, se_moments_hole, se_moments_part, se):\n    \"\"\"Return the error in the moments.\n\n    Parameters\n    ----------\n    se_moments_hole : numpy.ndarray\n        Moments of the hole self-energy.\n    se_moments_part : numpy.ndarray\n        Moments of the particle self-energy.\n    se : dyson.Lehmann\n        Self-energy object.\n\n    Returns\n    -------\n    eh : float\n        Error in the hole moments.\n    ep : float\n        Error in the particle moments.\n    \"\"\"\n    eh = self._moment_error(\n        se_moments_hole,\n        se.occupied().moment(range(len(se_moments_hole))),\n    )\n    ep = self._moment_error(\n        se_moments_part,\n        se.virtual().moment(range(len(se_moments_part))),\n    )\n    return eh, ep\n</code></pre>"},{"location":"reference/gw/#momentGW.gw.GW.energy_nuc","title":"<code>momentGW.gw.GW.energy_nuc()</code>","text":"<p>Calculate the nuclear repulsion energy.</p> <p>Returns:</p> Name Type Description <code>e_nuc</code> <code>float</code> <p>Nuclear repulsion energy.</p> Source code in <code>momentGW/gw.py</code> <pre><code>def energy_nuc(self):\n    \"\"\"Calculate the nuclear repulsion energy.\n\n    Returns\n    -------\n    e_nuc : float\n        Nuclear repulsion energy.\n    \"\"\"\n    with util.SilentSCF(self._scf):\n        return self._scf.energy_nuc()\n</code></pre>"},{"location":"reference/gw/#momentGW.gw.GW.energy_hf","title":"<code>momentGW.gw.GW.energy_hf(gf=None, integrals=None)</code>","text":"<p>Calculate the one-body (Hartree--Fock) energy.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>Lehmann</code> <p>Green's function object. If <code>None</code>, use either <code>self.gf</code>, or the mean-field Green's function. Default value is <code>None</code>.</p> <code>None</code> <code>integrals</code> <code>Integrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>e_1b</code> <code>float</code> <p>One-body energy.</p> Source code in <code>momentGW/gw.py</code> <pre><code>@logging.with_timer(\"Energy\")\n@logging.with_status(\"Calculating energy\")\ndef energy_hf(self, gf=None, integrals=None):\n    \"\"\"Calculate the one-body (Hartree--Fock) energy.\n\n    Parameters\n    ----------\n    gf : dyson.Lehmann, optional\n        Green's function object. If `None`, use either `self.gf`, or\n        the mean-field Green's function. Default value is `None`.\n    integrals : Integrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    e_1b : float\n        One-body energy.\n    \"\"\"\n\n    # Get the Green's function\n    if gf is None:\n        gf = self.gf\n\n    # Get the integrals\n    if integrals is None:\n        integrals = self.ao2mo()\n\n    # Find the Fock matrix\n    with util.SilentSCF(self._scf):\n        h1e = util.einsum(\n            \"pq,pi,qj-&gt;ij\", self._scf.get_hcore(), self.mo_coeff.conj(), self.mo_coeff\n        )\n    rdm1 = self.make_rdm1(gf=gf)\n    fock = integrals.get_fock(rdm1, h1e)\n\n    return energy.hartree_fock(rdm1, fock, h1e)\n</code></pre>"},{"location":"reference/gw/#momentGW.gw.GW.energy_gm","title":"<code>momentGW.gw.GW.energy_gm(gf=None, se=None, g0=True)</code>","text":"<p>Calculate the two-body (Galitskii--Migdal) energy.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>Lehmann</code> <p>Green's function object. If <code>None</code>, use <code>self.gf</code>. Default value is <code>None</code>.</p> <code>None</code> <code>se</code> <code>Lehmann</code> <p>Self-energy object. If <code>None</code>, use <code>self.se</code>. Default value is <code>None</code>.</p> <code>None</code> <code>g0</code> <code>bool</code> <p>If <code>True</code>, use the mean-field Green's function. Default value is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>e_2b</code> <code>float</code> <p>Two-body energy.</p> Source code in <code>momentGW/gw.py</code> <pre><code>@logging.with_timer(\"Energy\")\n@logging.with_status(\"Calculating energy\")\ndef energy_gm(self, gf=None, se=None, g0=True):\n    r\"\"\"Calculate the two-body (Galitskii--Migdal) energy.\n\n    Parameters\n    ----------\n    gf : dyson.Lehmann, optional\n        Green's function object. If `None`, use `self.gf`. Default\n        value is `None`.\n    se : dyson.Lehmann, optional\n        Self-energy object. If `None`, use `self.se`. Default value\n        is `None`.\n    g0 : bool, optional\n        If `True`, use the mean-field Green's function. Default\n        value is `True`.\n\n    Returns\n    -------\n    e_2b : float\n        Two-body energy.\n    \"\"\"\n\n    # Get the Green's function and self-energy\n    if gf is None:\n        gf = self.gf\n    if se is None:\n        se = self.se\n\n    # Calculate the Galitskii--Migdal energy\n    if g0:\n        e_2b = energy.galitskii_migdal_g0(self.mo_energy, self.mo_occ, se)\n    else:\n        e_2b = energy.galitskii_migdal(gf, se)\n\n    return e_2b\n</code></pre>"},{"location":"reference/gw/#momentGW.gw.GW.init_gf","title":"<code>momentGW.gw.GW.init_gf(mo_energy=None)</code>","text":"<p>Initialise the mean-field Green's function.</p> <p>Parameters:</p> Name Type Description Default <code>mo_energy</code> <code>ndarray</code> <p>Molecular orbital energies. Default value is <code>self.mo_energy</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>gf</code> <code>Lehmann</code> <p>Mean-field Green's function.</p> Source code in <code>momentGW/gw.py</code> <pre><code>def init_gf(self, mo_energy=None):\n    \"\"\"Initialise the mean-field Green's function.\n\n    Parameters\n    ----------\n    mo_energy : numpy.ndarray, optional\n        Molecular orbital energies. Default value is\n        `self.mo_energy`.\n\n    Returns\n    -------\n    gf : dyson.Lehmann\n        Mean-field Green's function.\n    \"\"\"\n\n    # Get the MO energies\n    if mo_energy is None:\n        mo_energy = self.mo_energy\n\n    # Build the Green's function\n    gf = Lehmann(mo_energy, np.eye(self.nmo))\n\n    # Find the chemical potential\n    gf.chempot = search_chempot(gf.energies, gf.couplings, self.nmo, self.nocc * 2)[0]\n\n    return gf\n</code></pre>"},{"location":"reference/gw/#momentGW.gw.kernel","title":"<code>momentGW.gw.kernel(gw, nmom_max, moments=None, integrals=None)</code>","text":"<p>Moment-constrained one-shot GW.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseGW</code> <p>GW object.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>moments</code> <code>tuple of numpy.ndarray</code> <p>Tuple of (hole, particle) moments, if passed then they will be used instead of calculating them. Default value is <code>None</code>.</p> <code>None</code> <code>integrals</code> <code>BaseIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>conv</code> <code>bool</code> <p>Convergence flag. Always <code>True</code> for GW, returned for compatibility with other GW methods.</p> <code>gf</code> <code>Lehmann</code> <p>Green's function object.</p> <code>se</code> <code>Lehmann</code> <p>Self-energy object.</p> <code>qp_energy</code> <code>ndarray</code> <p>Quasiparticle energies. Always <code>None</code> for GW, returned for compatibility with other GW methods.</p> Notes <p>This approach is described in [1]_.</p> References <p>.. [1] C. J. C. Scott, O. J. Backhouse, and G. H. Booth, 158, 12,     2023.</p> Source code in <code>momentGW/gw.py</code> <pre><code>def kernel(\n    gw,\n    nmom_max,\n    moments=None,\n    integrals=None,\n):\n    \"\"\"Moment-constrained one-shot GW.\n\n    Parameters\n    ----------\n    gw : BaseGW\n        GW object.\n    nmom_max : int\n        Maximum moment number to calculate.\n    moments : tuple of numpy.ndarray, optional\n        Tuple of (hole, particle) moments, if passed then they will\n        be used instead of calculating them. Default value is `None`.\n    integrals : BaseIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    conv : bool\n        Convergence flag. Always `True` for GW, returned for\n        compatibility with other GW methods.\n    gf : dyson.Lehmann\n        Green's function object.\n    se : dyson.Lehmann\n        Self-energy object.\n    qp_energy : numpy.ndarray\n        Quasiparticle energies. Always `None` for GW, returned for\n        compatibility with other GW methods.\n\n    Notes\n    -----\n    This approach is described in [1]_.\n\n    References\n    ----------\n    .. [1] C. J. C. Scott, O. J. Backhouse, and G. H. Booth, 158, 12,\n        2023.\n    \"\"\"\n\n    # Get the integrals\n    if integrals is None:\n        integrals = gw.ao2mo()\n\n    # Get the static part of the SE\n    se_static = gw.build_se_static(integrals)\n\n    # Get the moments of the SE\n    if moments is None:\n        th, tp = gw.build_se_moments(\n            nmom_max,\n            integrals,\n            mo_energy=dict(\n                g=gw.mo_energy,\n                w=gw.mo_energy,\n            ),\n        )\n    else:\n        th, tp = moments\n\n    # Solve the Dyson equation\n    gf, se = gw.solve_dyson(th, tp, se_static, integrals=integrals)\n    conv = True\n\n    return conv, gf, se, None\n</code></pre>"},{"location":"reference/ints/","title":"Ints","text":"<p>Integral helpers.</p>"},{"location":"reference/ints/#momentGW.ints.BaseIntegrals","title":"<code>momentGW.ints.BaseIntegrals</code>","text":"<p>Base class for integral containers.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals","title":"<code>momentGW.ints.Integrals(with_df, mo_coeff, mo_occ, compression='ia', compression_tol=1e-10, store_full=False)</code>","text":"<p>             Bases: <code>BaseIntegrals</code></p> <p>Container for the density-fitted integrals required for GW methods.</p> <p>Parameters:</p> Name Type Description Default <code>with_df</code> <code>DF</code> <p>Density fitting object.</p> required <code>mo_coeff</code> <code>ndarray</code> <p>Molecular orbital coefficients.</p> required <code>mo_occ</code> <code>ndarray</code> <p>Molecular orbital occupations.</p> required <code>compression</code> <code>str</code> <p>Compression scheme to use. Default value is <code>'ia'</code>. See <code>momentGW.gw</code> for more details.</p> <code>'ia'</code> <code>compression_tol</code> <code>float</code> <p>Compression tolerance. Default value is <code>1e-10</code>. See <code>momentGW.gw</code> for more details.</p> <code>1e-10</code> <code>store_full</code> <code>bool</code> <p>Store the full MO integrals in memory. Default value is <code>False</code>.</p> <code>False</code> Source code in <code>momentGW/ints.py</code> <pre><code>def __init__(\n    self,\n    with_df,\n    mo_coeff,\n    mo_occ,\n    compression=\"ia\",\n    compression_tol=1e-10,\n    store_full=False,\n):\n    # Parameters\n    self.with_df = with_df\n    self.mo_coeff = mo_coeff\n    self.mo_occ = mo_occ\n\n    # Options\n    self.compression = compression\n    self.compression_tol = compression_tol\n    self.store_full = store_full\n\n    # Logging\n    init_logging()\n\n    # Attributes\n    self._blocks = {}\n    self._mo_coeff_g = None\n    self._mo_coeff_w = None\n    self._mo_occ_w = None\n    self._rot = None\n    self._naux = None\n</code></pre>"},{"location":"reference/ints/#momentGW.ints.Integrals.Lpq","title":"<code>momentGW.ints.Integrals.Lpq</code>  <code>property</code>","text":"<p>Get the full uncompressed <code>(aux, MO, MO)</code> integrals.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.Lpx","title":"<code>momentGW.ints.Integrals.Lpx</code>  <code>property</code>","text":"<p>Get the compressed <code>(aux, MO, G)</code> integrals.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.Lia","title":"<code>momentGW.ints.Integrals.Lia</code>  <code>property</code>","text":"<p>Get the compressed <code>(aux, W occ, W vir)</code> integrals.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.mo_coeff_g","title":"<code>momentGW.ints.Integrals.mo_coeff_g</code>  <code>property</code>","text":"<p>Get the MO coefficients for the Green's function.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.mo_coeff_w","title":"<code>momentGW.ints.Integrals.mo_coeff_w</code>  <code>property</code>","text":"<p>Get the MO coefficients for the screened Coulomb interaction.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.mo_occ_w","title":"<code>momentGW.ints.Integrals.mo_occ_w</code>  <code>property</code>","text":"<p>Get the MO occupation numbers for the screened Coulomb interaction.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.nao","title":"<code>momentGW.ints.Integrals.nao</code>  <code>property</code>","text":"<p>Get the number of AOs.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.nmo","title":"<code>momentGW.ints.Integrals.nmo</code>  <code>property</code>","text":"<p>Get the number of MOs.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.nocc","title":"<code>momentGW.ints.Integrals.nocc</code>  <code>property</code>","text":"<p>Get the number of occupied MOs.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.nvir","title":"<code>momentGW.ints.Integrals.nvir</code>  <code>property</code>","text":"<p>Get the number of virtual MOs.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.nmo_g","title":"<code>momentGW.ints.Integrals.nmo_g</code>  <code>property</code>","text":"<p>Get the number of MOs for the Green's function.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.nmo_w","title":"<code>momentGW.ints.Integrals.nmo_w</code>  <code>property</code>","text":"<p>Get the number of MOs for the screened Coulomb interaction.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.nocc_w","title":"<code>momentGW.ints.Integrals.nocc_w</code>  <code>property</code>","text":"<p>Get the number of occupied MOs for the screened Coulomb interaction.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.nvir_w","title":"<code>momentGW.ints.Integrals.nvir_w</code>  <code>property</code>","text":"<p>Get the number of virtual MOs for the screened Coulomb interaction.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.naux","title":"<code>momentGW.ints.Integrals.naux</code>  <code>property</code>","text":"<p>Get the number of auxiliary basis functions, after the compression.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.naux_full","title":"<code>momentGW.ints.Integrals.naux_full</code>  <code>property</code>","text":"<p>Get the number of auxiliary basis functions, before the compression.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.is_bare","title":"<code>momentGW.ints.Integrals.is_bare</code>  <code>property</code>","text":"<p>Get a boolean flag indicating whether the integrals have no self-consistencies.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.dtype","title":"<code>momentGW.ints.Integrals.dtype</code>  <code>property</code>","text":"<p>Get the dtype of the integrals.</p>"},{"location":"reference/ints/#momentGW.ints.Integrals.get_compression_metric","title":"<code>momentGW.ints.Integrals.get_compression_metric()</code>","text":"<p>Return the compression metric.</p> <p>Returns:</p> Name Type Description <code>rot</code> <code>ndarray</code> <p>Rotation matrix into the compressed auxiliary space.</p> Source code in <code>momentGW/ints.py</code> <pre><code>@logging.with_status(\"Computing compression metric\")\ndef get_compression_metric(self):\n    \"\"\"Return the compression metric.\n\n    Returns\n    -------\n    rot : numpy.ndarray\n        Rotation matrix into the compressed auxiliary space.\n    \"\"\"\n\n    # Get the compression sectors\n    compression = self._parse_compression()\n    if not compression:\n        return None\n\n    # Initialise the inner product matrix\n    prod = np.zeros((self.naux_full, self.naux_full))\n\n    # Loop over required blocks\n    for key in sorted(compression):\n        with logging.with_status(f\"{key} sector\"):\n            # Get the coefficients\n            ci, cj = [\n                {\n                    \"o\": self.mo_coeff[:, self.mo_occ &gt; 0],\n                    \"v\": self.mo_coeff[:, self.mo_occ == 0],\n                    \"i\": self.mo_coeff_w[:, self.mo_occ_w &gt; 0],\n                    \"a\": self.mo_coeff_w[:, self.mo_occ_w == 0],\n                }[k]\n                for k in key\n            ]\n            ni, nj = ci.shape[-1], cj.shape[-1]\n            coeffs = np.concatenate((ci, cj), axis=1)\n\n            # Loop over the blocks\n            for p0, p1 in mpi_helper.prange(0, ni * nj, self.with_df.blockdim):\n                i0, j0 = divmod(p0, nj)\n                i1, j1 = divmod(p1, nj)\n\n                # Build the (L|xy) array\n                Lxy = np.zeros((self.naux_full, p1 - p0))\n                b1 = 0\n                for block in self.with_df.loop():\n                    b0, b1 = b1, b1 + block.shape[0]\n                    progress = (p0 * self.naux_full + b0) / (ni * nj * self.naux_full)\n                    with logging.with_status(f\"block [{p0}:{p1}, {b0}:{b1}] ({progress:.1%})\"):\n                        tmp = _ao2mo.nr_e2(\n                            block,\n                            coeffs,\n                            (i0, i1 + 1, ni, ni + nj),\n                            aosym=\"s2\",\n                            mosym=\"s1\",\n                        )\n                        tmp = tmp.reshape(b1 - b0, -1)\n                        Lxy[b0:b1] = tmp[:, j0 : j0 + (p1 - p0)]\n\n                # Update the inner product matrix\n                prod += np.dot(Lxy, Lxy.T)\n\n    # Reduce the inner product matrix\n    prod = mpi_helper.allreduce(prod, root=0)\n\n    # Diagonalise the inner product matrix\n    if mpi_helper.rank == 0:\n        e, v = np.linalg.eigh(prod)\n        mask = np.abs(e) &gt; self.compression_tol\n        rot = v[:, mask]\n    else:\n        rot = np.zeros((0,))\n    del prod\n\n    # Broadcast the rotation matrix in case of hybrid parallelism\n    # introducing non-determinism\n    rot = mpi_helper.bcast(rot, root=0)\n\n    # Print the compression status\n    if rot.shape[-1] == self.naux_full:\n        logging.write(\"No compression found for auxiliary space\")\n        rot = None\n    else:\n        percent = 100 * rot.shape[-1] / self.naux_full\n        style = logging.rate(percent, 80, 95)\n        logging.write(\n            f\"Compressed auxiliary space from {self.naux_full} to {rot.shape[1]} \"\n            f\"([{style}]{percent:.1f}%)[/]\"\n        )\n\n    return rot\n</code></pre>"},{"location":"reference/ints/#momentGW.ints.Integrals.transform","title":"<code>momentGW.ints.Integrals.transform(do_Lpq=None, do_Lpx=True, do_Lia=True)</code>","text":"<p>Transform the integrals in-place.</p> <p>Parameters:</p> Name Type Description Default <code>do_Lpq</code> <code>bool</code> <p>Whether to compute the full <code>(aux, MO, MO)</code> array. Default value is <code>True</code> if <code>store_full</code> is <code>True</code>, <code>False</code> otherwise.</p> <code>None</code> <code>do_Lpx</code> <code>bool</code> <p>Whether to compute the compressed <code>(aux, MO, MO)</code> array. Default value is <code>True</code>.</p> <code>True</code> <code>do_Lia</code> <code>bool</code> <p>Whether to compute the compressed <code>(aux, occ, vir)</code> array. Default value is <code>True</code>.</p> <code>True</code> Source code in <code>momentGW/ints.py</code> <pre><code>@require_compression_metric()\n@logging.with_status(\"Transforming integrals\")\ndef transform(self, do_Lpq=None, do_Lpx=True, do_Lia=True):\n    \"\"\"\n    Transform the integrals in-place.\n\n    Parameters\n    ----------\n    do_Lpq : bool, optional\n        Whether to compute the full ``(aux, MO, MO)`` array. Default\n        value is `True` if `store_full` is `True`, `False`\n        otherwise.\n    do_Lpx : bool, optional\n        Whether to compute the compressed ``(aux, MO, MO)`` array.\n        Default value is `True`.\n    do_Lia : bool, optional\n        Whether to compute the compressed ``(aux, occ, vir)`` array.\n        Default value is `True`.\n    \"\"\"\n\n    # Get the compression metric\n    rot = self._rot\n    if rot is None:\n        rot = np.eye(self.naux_full)\n\n    # Check which arrays to build\n    do_Lpq = self.store_full if do_Lpq is None else do_Lpq\n    if not any([do_Lpq, do_Lpx, do_Lia]):\n        return\n\n    # Get the slices on the current process and initialise the arrays\n    o0, o1 = list(mpi_helper.prange(0, self.nmo, self.nmo))[0]\n    p0, p1 = list(mpi_helper.prange(0, self.nmo_g, self.nmo_g))[0]\n    q0, q1 = list(mpi_helper.prange(0, self.nocc_w * self.nvir_w, self.nocc_w * self.nvir_w))[0]\n    Lpq = np.zeros((self.naux_full, self.nmo, o1 - o0)) if do_Lpq else None\n    Lpx = np.zeros((self.naux, self.nmo, p1 - p0)) if do_Lpx else None\n    Lia = np.zeros((self.naux, q1 - q0)) if do_Lia else None\n\n    # Build the integrals blockwise\n    b1 = 0\n    for block in self.with_df.loop():\n        b0, b1 = b1, b1 + block.shape[0]\n\n        progress = b1 / self.naux_full\n        with logging.with_status(f\"block [{b0}:{b1}] ({progress:.1%})\"):\n            # If needed, rotate the full (L|pq) array\n            if do_Lpq:\n                _ao2mo.nr_e2(\n                    block,\n                    self.mo_coeff,\n                    (0, self.nmo, o0, o1),\n                    aosym=\"s2\",\n                    mosym=\"s1\",\n                    out=Lpq[b0:b1],\n                )\n\n            # Compress the block\n            block = np.dot(rot[b0:b1].T, block)\n\n            # Build the compressed (L|px) array\n            if do_Lpx:\n                coeffs = np.concatenate((self.mo_coeff, self.mo_coeff_g[:, p0:p1]), axis=1)\n                tmp = _ao2mo.nr_e2(\n                    block,\n                    coeffs,\n                    (0, self.nmo, self.nmo, self.nmo + (p1 - p0)),\n                    aosym=\"s2\",\n                    mosym=\"s1\",\n                )\n                Lpx += tmp.reshape(Lpx.shape)\n\n            # Build the compressed (L|ia) array\n            if do_Lia:\n                i0, a0 = divmod(q0, self.nvir_w)\n                i1, a1 = divmod(q1, self.nvir_w)\n                tmp = _ao2mo.nr_e2(\n                    block,\n                    self.mo_coeff_w,\n                    (i0, i1 + 1, self.nocc_w, self.nmo_w),\n                    aosym=\"s2\",\n                    mosym=\"s1\",\n                )\n                Lia += tmp[:, a0 : a0 + (q1 - q0)]\n\n    # Store the arrays\n    if do_Lpq:\n        self._blocks[\"Lpq\"] = Lpq\n    if do_Lpx:\n        self._blocks[\"Lpx\"] = Lpx\n    if do_Lia:\n        self._blocks[\"Lia\"] = Lia\n</code></pre>"},{"location":"reference/ints/#momentGW.ints.Integrals.update_coeffs","title":"<code>momentGW.ints.Integrals.update_coeffs(mo_coeff_g=None, mo_coeff_w=None, mo_occ_w=None)</code>","text":"<p>Update the MO coefficients in-place for the Green's function and the screened Coulomb interaction.</p> <p>Parameters:</p> Name Type Description Default <code>mo_coeff_g</code> <code>ndarray</code> <p>Coefficients corresponding to the Green's function. Default value is <code>None</code>.</p> <code>None</code> <code>mo_coeff_w</code> <code>ndarray</code> <p>Coefficients corresponding to the screened Coulomb interaction. Default value is <code>None</code>.</p> <code>None</code> <code>mo_occ_w</code> <code>ndarray</code> <p>Occupations corresponding to the screened Coulomb interaction. Default value is <code>None</code>.</p> <code>None</code> Notes <p>If <code>mo_coeff_g</code> is <code>None</code>, the Green's function is assumed to remain in the basis in which it was originally defined, and vice-versa for <code>mo_coeff_w</code> and <code>mo_occ_w</code>. At least one of <code>mo_coeff_g</code> and <code>mo_coeff_w</code> must be provided.</p> Source code in <code>momentGW/ints.py</code> <pre><code>def update_coeffs(self, mo_coeff_g=None, mo_coeff_w=None, mo_occ_w=None):\n    \"\"\"\n    Update the MO coefficients in-place for the Green's function\n    and the screened Coulomb interaction.\n\n    Parameters\n    ----------\n    mo_coeff_g : numpy.ndarray, optional\n        Coefficients corresponding to the Green's function. Default\n        value is `None`.\n    mo_coeff_w : numpy.ndarray, optional\n        Coefficients corresponding to the screened Coulomb\n        interaction. Default value is `None`.\n    mo_occ_w : numpy.ndarray, optional\n        Occupations corresponding to the screened Coulomb\n        interaction. Default value is `None`.\n\n    Notes\n    -----\n    If `mo_coeff_g` is `None`, the Green's function is assumed to\n    remain in the basis in which it was originally defined, and\n    vice-versa for `mo_coeff_w` and `mo_occ_w`. At least one of\n    `mo_coeff_g` and `mo_coeff_w` must be provided.\n    \"\"\"\n\n    # Check the input\n    if any((mo_coeff_w is not None, mo_occ_w is not None)):\n        assert mo_coeff_w is not None and mo_occ_w is not None\n\n    # Update the Green's function coefficients\n    if mo_coeff_g is not None:\n        self._mo_coeff_g = mo_coeff_g\n\n    # Update the screened Coulomb interaction coefficients\n    do_all = False\n    if mo_coeff_w is not None:\n        self._mo_coeff_w = mo_coeff_w\n        self._mo_occ_w = mo_occ_w\n        if \"ia\" in self._parse_compression():\n            do_all = (True,)\n            self._rot = self.get_compression_metric()\n\n    # Transform the integrals\n    self.transform(\n        do_Lpq=self.store_full and do_all,\n        do_Lpx=mo_coeff_g is not None or do_all,\n        do_Lia=mo_coeff_w is not None or do_all,\n    )\n</code></pre>"},{"location":"reference/ints/#momentGW.ints.Integrals.get_j","title":"<code>momentGW.ints.Integrals.get_j(dm, basis='mo', other=None)</code>","text":"<p>Build the J matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix.</p> required <code>basis</code> <code>str</code> <p>Basis in which to build the J matrix. One of <code>(\"ao\", \"mo\")</code>. Default value is <code>\"mo\"</code>.</p> <code>'mo'</code> <code>other</code> <code>BaseIntegrals</code> <p>Integrals object for the ket side. Allows inheritence for mixed-spin evaluations. If <code>None</code>, use <code>self</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>vj</code> <code>ndarray</code> <p>J matrix.</p> Notes <p>The contraction is <code>J[p, q] = self[p, q] * other[r, s] * dm[r, s]</code>, and the bases must reflect shared indices.</p> Source code in <code>momentGW/ints.py</code> <pre><code>@logging.with_timer(\"J matrix\")\n@logging.with_status(\"Building J matrix\")\ndef get_j(self, dm, basis=\"mo\", other=None):\n    \"\"\"Build the J matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix.\n    basis : str, optional\n        Basis in which to build the J matrix. One of\n        `(\"ao\", \"mo\")`. Default value is `\"mo\"`.\n    other : BaseIntegrals, optional\n        Integrals object for the ket side. Allows inheritence for\n        mixed-spin evaluations. If `None`, use `self`. Default\n        value is `None`.\n\n    Returns\n    -------\n    vj : numpy.ndarray\n        J matrix.\n\n    Notes\n    -----\n    The contraction is\n    `J[p, q] = self[p, q] * other[r, s] * dm[r, s]`, and the\n    bases must reflect shared indices.\n    \"\"\"\n\n    # Check the input\n    assert basis in (\"ao\", \"mo\")\n\n    # Get the other integrals\n    if other is None:\n        other = self\n\n    if self.store_full and basis == \"mo\":\n        # Initialise the J matrix\n        p0, p1 = list(mpi_helper.prange(0, self.nmo, self.nmo))[0]\n        vj = np.zeros_like(dm, dtype=np.result_type(dm, self.dtype, other.dtype))\n\n        # Constuct J using the full MO basis integrals\n        tmp = util.einsum(\"Qkl,lk-&gt;Q\", other.Lpq, dm[p0:p1])\n        tmp = mpi_helper.allreduce(tmp)\n        vj[:, p0:p1] = util.einsum(\"Qij,Q-&gt;ij\", self.Lpq, tmp)\n        vj = mpi_helper.allreduce(vj)\n\n    else:\n        # Initialise the J matrix\n        vj = np.zeros((self.nao, self.nao), dtype=np.result_type(dm, self.dtype, other.dtype))\n\n        # Transform the density into the AO basis\n        if basis == \"mo\":\n            dm = util.einsum(\"ij,pi,qj-&gt;pq\", dm, other.mo_coeff, np.conj(other.mo_coeff))\n\n        # Loop over the blocks\n        with patch_df_loop(self.with_df):\n            for block in self.with_df.loop():\n                naux = block.shape[0]\n                if block.size == naux * self.nao * (self.nao + 1) // 2:\n                    block = lib.unpack_tril(block)\n                block = block.reshape(naux, self.nao, self.nao)\n\n                # Construct J for this block\n                tmp = util.einsum(\"Qkl,lk-&gt;Q\", block, dm)\n                vj += util.einsum(\"Qij,Q-&gt;ij\", block, tmp)\n\n        # Reduce the J matrix\n        vj = mpi_helper.allreduce(vj)\n\n        # Transform the J matrix back to the MO basis\n        if basis == \"mo\":\n            vj = util.einsum(\"pq,pi,qj-&gt;ij\", vj, np.conj(self.mo_coeff), self.mo_coeff)\n\n    return vj\n</code></pre>"},{"location":"reference/ints/#momentGW.ints.Integrals.get_k","title":"<code>momentGW.ints.Integrals.get_k(dm, basis='mo')</code>","text":"<p>Build the K matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix.</p> required <code>basis</code> <code>str</code> <p>Basis in which to build the K matrix. One of <code>(\"ao\", \"mo\")</code>. Default value is <code>\"mo\"</code>.</p> <code>'mo'</code> <p>Returns:</p> Name Type Description <code>vk</code> <code>ndarray</code> <p>K matrix.</p> Notes <p>The contraction is <code>K[p, q] = self[r, q] * self[p, r] * dm[q, s]</code>, and the bases must reflect shared indices.</p> Source code in <code>momentGW/ints.py</code> <pre><code>@logging.with_timer(\"K matrix\")\n@logging.with_status(\"Building K matrix\")\ndef get_k(self, dm, basis=\"mo\"):\n    \"\"\"Build the K matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix.\n    basis : str, optional\n        Basis in which to build the K matrix. One of\n        `(\"ao\", \"mo\")`. Default value is `\"mo\"`.\n\n    Returns\n    -------\n    vk : numpy.ndarray\n        K matrix.\n\n    Notes\n    -----\n    The contraction is\n    `K[p, q] = self[r, q] * self[p, r] * dm[q, s]`, and the\n    bases must reflect shared indices.\n    \"\"\"\n\n    # Check the input\n    assert basis in (\"ao\", \"mo\")\n\n    if self.store_full and basis == \"mo\":\n        # Initialise the K matrix\n        p0, p1 = list(mpi_helper.prange(0, self.nmo, self.nmo))[0]\n        vk = np.zeros_like(dm, dtype=np.result_type(dm, self.dtype))\n\n        # Constuct K using the full MO basis integrals\n        tmp = util.einsum(\"Qik,kl-&gt;Qil\", self.Lpq, dm[p0:p1])\n        tmp = mpi_helper.allreduce(tmp)\n        vk[:, p0:p1] = util.einsum(\"Qil,Qlj-&gt;ij\", tmp, self.Lpq)\n        vk = mpi_helper.allreduce(vk)\n\n    else:\n        # Initialise the K matrix\n        vk = np.zeros((self.nao, self.nao), dtype=np.result_type(dm, self.dtype))\n\n        # Transform the density into the AO basis\n        if basis == \"mo\":\n            dm = util.einsum(\"ij,pi,qj-&gt;pq\", dm, self.mo_coeff, np.conj(self.mo_coeff))\n\n        # Loop over the blocks\n        with patch_df_loop(self.with_df):\n            for block in self.with_df.loop():\n                naux = block.shape[0]\n                if block.size == naux * self.nao * (self.nao + 1) // 2:\n                    block = lib.unpack_tril(block)\n                block = block.reshape(naux, self.nao, self.nao)\n\n                # Construct K for this block\n                tmp = util.einsum(\"Qik,kl-&gt;Qil\", block, dm)\n                vk += util.einsum(\"Qil,Qlj-&gt;ij\", tmp, block)\n\n        # Reduce the K matrix\n        vk = mpi_helper.allreduce(vk)\n\n        # Transform the K matrix back to the MO basis\n        if basis == \"mo\":\n            vk = util.einsum(\"pq,pi,qj-&gt;ij\", vk, np.conj(self.mo_coeff), self.mo_coeff)\n\n    return vk\n</code></pre>"},{"location":"reference/ints/#momentGW.ints.Integrals.get_jk","title":"<code>momentGW.ints.Integrals.get_jk(dm, **kwargs)</code>","text":"<p>Build the J and K matrices.</p> <p>Returns:</p> Name Type Description <code>vj</code> <code>ndarray</code> <p>J matrix.</p> <code>vk</code> <code>ndarray</code> <p>K matrix.</p> Notes <p>See <code>get_j</code> and <code>get_k</code> for more information.</p> Source code in <code>momentGW/ints.py</code> <pre><code>def get_jk(self, dm, **kwargs):\n    \"\"\"Build the J and K matrices.\n\n    Returns\n    -------\n    vj : numpy.ndarray\n        J matrix.\n    vk : numpy.ndarray\n        K matrix.\n\n    Notes\n    -----\n    See `get_j` and `get_k` for more information.\n    \"\"\"\n    return self.get_j(dm, **kwargs), self.get_k(dm, **kwargs)\n</code></pre>"},{"location":"reference/ints/#momentGW.ints.Integrals.get_veff","title":"<code>momentGW.ints.Integrals.get_veff(dm, j=None, k=None, **kwargs)</code>","text":"<p>Build the effective potential.</p> <p>Returns:</p> Name Type Description <code>veff</code> <code>ndarray</code> <p>Effective potential.</p> <code>j</code> <code>(ndarray, optional)</code> <p>J matrix. If <code>None</code>, compute it. Default value is <code>None</code>.</p> <code>k</code> <code>(ndarray, optional)</code> <p>K matrix. If <code>None</code>, compute it. Default value is <code>None</code>.</p> Notes <p>See <code>get_jk</code> for more information.</p> Source code in <code>momentGW/ints.py</code> <pre><code>def get_veff(self, dm, j=None, k=None, **kwargs):\n    \"\"\"Build the effective potential.\n\n    Returns\n    -------\n    veff : numpy.ndarray\n        Effective potential.\n    j : numpy.ndarray, optional\n        J matrix. If `None`, compute it. Default value is `None`.\n    k : numpy.ndarray, optional\n        K matrix. If `None`, compute it. Default value is `None`.\n\n    Notes\n    -----\n    See `get_jk` for more information.\n    \"\"\"\n    if j is None and k is None:\n        vj, vk = self.get_jk(dm, **kwargs)\n    elif j is None:\n        vj, vk = self.get_j(dm, **kwargs), k\n    elif k is None:\n        vj, vk = j, self.get_k(dm, **kwargs)\n    return vj - vk * 0.5\n</code></pre>"},{"location":"reference/ints/#momentGW.ints.Integrals.get_fock","title":"<code>momentGW.ints.Integrals.get_fock(dm, h1e, **kwargs)</code>","text":"<p>Build the Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix.</p> required <code>h1e</code> <code>ndarray</code> <p>Core Hamiltonian matrix.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for <code>get_jk</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>fock</code> <code>ndarray</code> <p>Fock matrix.</p> Notes <p>See <code>get_jk</code> for more information. The basis of <code>h1e</code> must be the same as <code>dm</code>.</p> Source code in <code>momentGW/ints.py</code> <pre><code>def get_fock(self, dm, h1e, **kwargs):\n    \"\"\"Build the Fock matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix.\n    h1e : numpy.ndarray\n        Core Hamiltonian matrix.\n    **kwargs : dict, optional\n        Additional keyword arguments for `get_jk`.\n\n    Returns\n    -------\n    fock : numpy.ndarray\n        Fock matrix.\n\n    Notes\n    -----\n    See `get_jk` for more information. The basis of `h1e` must be\n    the same as `dm`.\n    \"\"\"\n    veff = self.get_veff(dm, **kwargs)\n    return h1e + veff\n</code></pre>"},{"location":"reference/ints/#momentGW.ints.patch_df_loop","title":"<code>momentGW.ints.patch_df_loop(with_df)</code>","text":"<p>Context manager for monkey patching PySCF's density fitting objects to loop over blocks of the auxiliary functions distributed over MPI.</p> <p>Parameters:</p> Name Type Description Default <code>with_df</code> <code>DF</code> <p>Density fitting object.</p> required <p>Yields:</p> Name Type Description <code>with_df</code> <code>DF</code> <p>Density fitting object with monkey patched <code>loop</code> method.</p> Source code in <code>momentGW/ints.py</code> <pre><code>@contextlib.contextmanager\ndef patch_df_loop(with_df):\n    \"\"\"\n    Context manager for monkey patching PySCF's density fitting objects\n    to loop over blocks of the auxiliary functions distributed over MPI.\n\n    Parameters\n    ----------\n    with_df : pyscf.df.DF\n        Density fitting object.\n\n    Yields\n    ------\n    with_df : pyscf.df.DF\n        Density fitting object with monkey patched `loop` method.\n    \"\"\"\n\n    def prange(self, start, stop, end):\n        \"\"\"MPI-aware prange function.\"\"\"\n        yield from mpi_helper.prange(start, stop, end)\n\n    # Patch the loop method\n    pre_patch = with_df.prange\n    with_df.prange = types.MethodType(prange, with_df)\n\n    # Transfer control\n    yield with_df\n\n    # Restore the original method\n    with_df.prange = pre_patch\n</code></pre>"},{"location":"reference/ints/#momentGW.ints.require_compression_metric","title":"<code>momentGW.ints.require_compression_metric()</code>","text":"<p>Determine the compression metric before running the function.</p> Source code in <code>momentGW/ints.py</code> <pre><code>def require_compression_metric():\n    \"\"\"Determine the compression metric before running the function.\"\"\"\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if self._rot is None:\n                self._rot = self.get_compression_metric()\n            return func(self, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/logging/","title":"Logging","text":"<p>Logging.</p>"},{"location":"reference/logging/#momentGW.logging.Status","title":"<code>momentGW.logging.Status(msg, *args, **kwargs)</code>","text":"<p>A status spinner with nested status messages.</p> Source code in <code>momentGW/logging.py</code> <pre><code>def __init__(self, msg, *args, **kwargs):\n    self.msg = msg\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.Status.__enter__","title":"<code>momentGW.logging.Status.__enter__()</code>","text":"<p>Enter the context manager.</p> Source code in <code>momentGW/logging.py</code> <pre><code>def __enter__(self):\n    \"\"\"Enter the context manager.\"\"\"\n    if not silent:\n        global LIVE, STATUS, STATUS_MSGS\n        if STATUS is None:\n            STATUS_MSGS = [self.msg]\n            STATUS = _Status(self.msg, console=console)\n        else:\n            STATUS_MSGS.append(self.msg)\n            STATUS.update(\" &gt; \".join(STATUS_MSGS))\n        _update_live()\n    return LIVE\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.Status.__exit__","title":"<code>momentGW.logging.Status.__exit__(*args)</code>","text":"<p>Exit the context manager.</p> Source code in <code>momentGW/logging.py</code> <pre><code>def __exit__(self, *args):\n    \"\"\"Exit the context manager.\"\"\"\n    if not silent:\n        global LIVE, STATUS, STATUS_MSGS\n        STATUS_MSGS = STATUS_MSGS[:-1]\n        if not STATUS_MSGS:\n            STATUS = None\n        else:\n            STATUS.update(\" &gt; \".join(STATUS_MSGS))\n        _update_live()\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.Table","title":"<code>momentGW.logging.Table(*args, **kwargs)</code>","text":"<p>             Bases: <code>Table</code></p> <p>A table with additional context manager methods.</p> Notes <p>Since the <code>Live</code> object is created with <code>transient=True</code>, tables using the context manager will be removed from the display after the context manager is exited. Tables should be manually printed to the console if they are required to be displayed afterwards.</p> Source code in <code>momentGW/logging.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    kwargs[\"show_edge\"] = kwargs.get(\"show_edge\", False)\n    kwargs[\"show_header\"] = kwargs.get(\"show_header\", True)\n    kwargs[\"expand\"] = kwargs.get(\"expand\", False)\n    kwargs[\"title_style\"] = kwargs.get(\"title_style\", \"bold\")\n    kwargs[\"header_style\"] = kwargs.get(\"header_style\", \"\")\n    kwargs[\"box\"] = kwargs.get(\"box\", rich.box.SIMPLE)\n    kwargs[\"padding\"] = kwargs.get(\"padding\", (0, 2))\n    kwargs[\"collapse_padding\"] = kwargs.get(\"collapse_padding\", True)\n\n    super().__init__(*args, **kwargs)\n\n    self._is_live = False\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.Table.add_column","title":"<code>momentGW.logging.Table.add_column(*args, **kwargs)</code>","text":"<p>Add a column to the table.</p> Source code in <code>momentGW/logging.py</code> <pre><code>def add_column(self, *args, **kwargs):\n    \"\"\"Add a column to the table.\"\"\"\n    super().add_column(*args, **kwargs)\n    if self._is_live and not silent:\n        _update_live()\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.Table.add_row","title":"<code>momentGW.logging.Table.add_row(*args, **kwargs)</code>","text":"<p>Add a row to the table.</p> Source code in <code>momentGW/logging.py</code> <pre><code>def add_row(self, *args, **kwargs):\n    \"\"\"Add a row to the table.\"\"\"\n    super().add_row(*args, **kwargs)\n    if self._is_live and not silent:\n        _update_live()\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.Table.__enter__","title":"<code>momentGW.logging.Table.__enter__()</code>","text":"<p>Enter the context manager.</p> Source code in <code>momentGW/logging.py</code> <pre><code>def __enter__(self):\n    \"\"\"Enter the context manager.\"\"\"\n    if not silent:\n        global TABLE\n        TABLE = self\n        self._is_live = True\n        _update_live()\n    return self\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.Table.__exit__","title":"<code>momentGW.logging.Table.__exit__(*args)</code>","text":"<p>Exit the context manager.</p> Source code in <code>momentGW/logging.py</code> <pre><code>def __exit__(self, *args):\n    \"\"\"Exit the context manager.\"\"\"\n    if not silent:\n        global TABLE\n        TABLE = None\n        self._is_live = False\n        _update_live()\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.write","title":"<code>momentGW.logging.write(msg, *args, **kwargs)</code>","text":"<p>Print a message to the console.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to print.</p> required <code>args</code> <code>tuple</code> <p>The arguments to format the message with.</p> <code>()</code> <code>comment</code> <code>str</code> <p>A comment to print alongside the message.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to pass to <code>console.print</code>.</p> <code>{}</code> Source code in <code>momentGW/logging.py</code> <pre><code>def write(msg, *args, **kwargs):\n    \"\"\"Print a message to the console.\n\n    Parameters\n    ----------\n    msg : str\n        The message to print.\n    args : tuple\n        The arguments to format the message with.\n    comment : str, optional\n        A comment to print alongside the message.\n    **kwargs : dict, optional\n        Additional keyword arguments to pass to `console.print`.\n    \"\"\"\n\n    # Check if we need to print the message\n    if silent:\n        return\n\n    # Format the message\n    if isinstance(msg, str) and args:\n        msg = msg % args\n\n    # See if the message has a comment\n    if comment := (kwargs.pop(\"comment\", None) or COMMENT):\n        table = _Table.grid(expand=True)\n        table.add_column(\"\", justify=\"left\")\n        table.add_column(\"\", justify=\"right\", style=\"comment\")\n        table.add_row(msg, comment)\n        msg = table\n\n    # Print the message\n    console.print(msg, **kwargs)\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.warn","title":"<code>momentGW.logging.warn(msg, *args, **kwargs)</code>","text":"<p>Print a message to the console with a warning comment.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to print.</p> required <code>args</code> <code>tuple</code> <p>The arguments to format the message with.</p> <code>()</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to pass to <code>console.print</code>.</p> <code>{}</code> Source code in <code>momentGW/logging.py</code> <pre><code>def warn(msg, *args, **kwargs):\n    \"\"\"Print a message to the console with a warning comment.\n\n    Parameters\n    ----------\n    msg : str\n        The message to print.\n    args : tuple\n        The arguments to format the message with.\n    **kwargs : dict, optional\n        Additional keyword arguments to pass to `console.print`.\n    \"\"\"\n\n    # Add a warning comment\n    kwargs[\"comment\"] = \"[bad]Warning![/]\"\n\n    # Print the message\n    write(msg, *args, **kwargs)\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.rate","title":"<code>momentGW.logging.rate(value, good_threshold, ok_threshold, invert=False)</code>","text":"<p>Return a colour rating based on a value and thresholds.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to rate.</p> required <code>good_threshold</code> <code>float</code> <p>The threshold for a good rating.</p> required <code>ok_threshold</code> <code>float</code> <p>The threshold for an ok rating.</p> required <code>invert</code> <code>bool</code> <p>Invert the rating. Default value is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>style</code> <code>str</code> <p>The style to use for the rating.</p> Source code in <code>momentGW/logging.py</code> <pre><code>def rate(value, good_threshold, ok_threshold, invert=False):\n    \"\"\"Return a colour rating based on a value and thresholds.\n\n    Parameters\n    ----------\n    value : float\n        The value to rate.\n    good_threshold : float\n        The threshold for a good rating.\n    ok_threshold : float\n        The threshold for an ok rating.\n    invert : bool, optional\n        Invert the rating. Default value is `False`.\n\n    Returns\n    -------\n    style : str\n        The style to use for the rating.\n    \"\"\"\n    if value &lt; good_threshold:\n        rating = \"good\" if not invert else \"bad\"\n    elif value &lt; ok_threshold:\n        rating = \"ok\"\n    else:\n        rating = \"bad\" if not invert else \"good\"\n    return rating\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.time","title":"<code>momentGW.logging.time(msg, elapsed)</code>","text":"<p>Record a time.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to record.</p> required <code>elapsed</code> <code>float</code> <p>The time elapsed.</p> required Source code in <code>momentGW/logging.py</code> <pre><code>def time(msg, elapsed):\n    \"\"\"Record a time.\n\n    Parameters\n    ----------\n    msg : str\n        The message to record.\n    elapsed : float\n        The time elapsed.\n    \"\"\"\n    if \"_times\" not in time.__dict__:\n        time._times = {}\n    time._times[msg] = time._times.get(msg, 0) + elapsed\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.dump_times","title":"<code>momentGW.logging.dump_times()</code>","text":"<p>Print a table with the timings.</p> Source code in <code>momentGW/logging.py</code> <pre><code>def dump_times():\n    \"\"\"Print a table with the timings.\"\"\"\n    if \"_times\" in time.__dict__:\n        table = Table(title=\"Timings\")\n        table.add_column(\"Task\", justify=\"right\")\n        table.add_column(\"Time\", justify=\"right\")\n        for msg, elapsed in time._times.items():\n            table.add_row(msg, util.Timer.format_time(elapsed))\n        write(\"\")\n        write(table)\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.init_logging","title":"<code>momentGW.logging.init_logging()</code>","text":"<p>Initialise the logging with a header.</p> Source code in <code>momentGW/logging.py</code> <pre><code>def init_logging():\n    \"\"\"Initialise the logging with a header.\"\"\"\n\n    if globals().get(\"_MOMENTGW_LOG_INITIALISED\", False):\n        return\n\n    # Print header\n    header_size = max([len(line) for line in HEADER.split(\"\\n\")])\n    space = \" \" * (header_size - len(__version__))\n    write(f\"[bold]{HEADER}[/bold]\" % f\"{space}[bold]{__version__}[/bold]\")\n\n    def get_git_hash(directory):\n        \"\"\"Get the git hash of a directory.\"\"\"\n        git_directory = os.path.join(directory, \".git\")\n        cmd = [\"git\", \"--git-dir=%s\" % git_directory, \"rev-parse\", \"--short\", \"HEAD\"]\n        try:\n            git_hash = subprocess.check_output(\n                cmd, universal_newlines=True, stderr=subprocess.STDOUT\n            ).rstrip()\n        except subprocess.CalledProcessError:\n            git_hash = \"N/A\"\n        return git_hash\n\n    import dyson\n    import h5py\n    import numpy\n    import pyscf\n    import rich\n    import scipy\n\n    import momentGW\n\n    packages = [numpy, scipy, h5py, pyscf, dyson, rich, momentGW]\n    if mpi_helper.mpi is not None:\n        import mpi4py\n\n        packages.append(mpi4py)\n\n    for module in packages:\n        write(f\"[bold]{module.__name__}:[/]\")\n        write(f\" &gt; Version:  {getattr(module, '__version__', 'N/A')}\")\n        write(\n            \" &gt; Git hash: %s\",\n            get_git_hash(os.path.join(os.path.dirname(module.__file__), \"..\")),\n        )\n\n    # Environment variables\n    threads = os.environ.get(\"OMP_NUM_THREADS\", 1)\n    write(f\"[bold]OpenMP threads[/]: {threads if threads else 1}\")\n    write(f\"[bold]MPI rank[/]: {mpi_helper.rank} of {mpi_helper.size}\")\n\n    globals()[\"_MOMENTGW_LOG_INITIALISED\"] = True\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.with_timer","title":"<code>momentGW.logging.with_timer(task_name)</code>","text":"<p>Run a function with a timer.</p> Source code in <code>momentGW/logging.py</code> <pre><code>@contextlib.contextmanager\ndef with_timer(task_name):\n    \"\"\"Run a function with a timer.\"\"\"\n    timer = util.Timer()\n    yield\n    time(task_name, timer())\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.with_status","title":"<code>momentGW.logging.with_status(task_name)</code>","text":"<p>Run a function with a status spinner.</p> Source code in <code>momentGW/logging.py</code> <pre><code>@contextlib.contextmanager\ndef with_status(task_name):\n    \"\"\"Run a function with a status spinner.\"\"\"\n    with Status(task_name):\n        yield\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.with_table","title":"<code>momentGW.logging.with_table(**kwargs)</code>","text":"<p>Run a function with a table.</p> Source code in <code>momentGW/logging.py</code> <pre><code>@contextlib.contextmanager\ndef with_table(**kwargs):\n    \"\"\"Run a function with a table.\"\"\"\n    # return Table(**kwargs)\n    with Table(**kwargs) as table:\n        yield table\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.with_comment","title":"<code>momentGW.logging.with_comment(comment)</code>","text":"<p>Run a function with a comment.</p> Source code in <code>momentGW/logging.py</code> <pre><code>@contextlib.contextmanager\ndef with_comment(comment):\n    \"\"\"Run a function with a comment.\"\"\"\n    global COMMENT\n    COMMENT = comment\n    yield\n    COMMENT = \"\"\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.with_silent","title":"<code>momentGW.logging.with_silent()</code>","text":"<p>Run a function silently.</p> Source code in <code>momentGW/logging.py</code> <pre><code>@contextlib.contextmanager\ndef with_silent():\n    \"\"\"Run a function silently.\"\"\"\n    global silent\n    old_silent = silent\n    silent = True\n    yield\n    silent = old_silent\n</code></pre>"},{"location":"reference/logging/#momentGW.logging.with_modifiers","title":"<code>momentGW.logging.with_modifiers(**kwargs)</code>","text":"<p>Run a function with modified logging.</p> Source code in <code>momentGW/logging.py</code> <pre><code>@contextlib.contextmanager\ndef with_modifiers(**kwargs):\n    \"\"\"Run a function with modified logging.\"\"\"\n    functions = {\n        \"status\": with_status,\n        \"timer\": with_timer,\n        \"comment\": with_comment,\n    }\n    with contextlib.ExitStack() as stack:\n        for key, value in kwargs.items():\n            stack.enter_context(functions[key](value))\n        yield\n</code></pre>"},{"location":"reference/mpi_helper/","title":"Mpi helper","text":"<p>Temporary workaround for <code>mpi_helper</code> functions.</p>"},{"location":"reference/qsgw/","title":"Qsgw","text":"<p>Spin-restricted quasiparticle self-consistent GW via self-energy moment constraints for molecular systems.</p>"},{"location":"reference/qsgw/#momentGW.qsgw.qsGW","title":"<code>momentGW.qsgw.qsGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>GW</code></p> <p>Spin-restricted quasiparticle self-consistent GW via self-energy moment constraints for molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>SCF</code> <p>PySCF mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>max_cycle</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>50</code>.</p> required <code>max_cycle_qp</code> <code>int</code> <p>Maximum number of iterations in the quasiparticle equation loop. Default value is <code>50</code>.</p> required <code>conv_tol</code> <code>float</code> <p>Convergence threshold in the change in the HOMO and LUMO. Default value is <code>1e-8</code>.</p> required <code>conv_tol_moms</code> <code>float</code> <p>Convergence threshold in the change in the moments. Default value is <code>1e-8</code>.</p> required <code>conv_tol_qp</code> <code>float</code> <p>Convergence threshold in the change in the density matrix in the quasiparticle equation loop. Default value is <code>1e-8</code>.</p> required <code>conv_logical</code> <code>callable</code> <p>Function that takes an iterable of booleans as input indicating whether the individual <code>conv_tol</code>, <code>conv_tol_moms</code>, <code>conv_tol_qp</code> have been satisfied, respectively, and returns a boolean indicating overall convergence. For example, the function <code>all</code> requires both metrics to be met, and <code>any</code> requires just one. Default value is <code>all</code>.</p> required <code>diis_space</code> <code>int</code> <p>Size of the DIIS extrapolation space. Default value is <code>8</code>.</p> required <code>diis_space_qp</code> <code>int</code> <p>Size of the DIIS extrapolation space in the quasiparticle loop. Default value is <code>8</code>.</p> required <code>damping</code> <code>float</code> <p>Damping parameter. Default value is <code>0.0</code>.</p> required <code>eta</code> <code>float</code> <p>Small value to regularise the self-energy. Default value is <code>1e-1</code>.</p> required <code>srg</code> <code>float</code> <p>If non-zero, use the similarity renormalisation group approach of Marie and Loos in place of the <code>eta</code> regularisation. For value recommendations refer to their paper (arXiv:2303.05984). Default value is <code>0.0</code>.</p> required <code>solver</code> <code>BaseGW</code> <p>Solver to use to obtain the self-energy. Compatible with any <code>BaseGW</code>-like class. Default value is <code>momentGW.gw.GW</code>.</p> required <code>solver_options</code> <code>dict</code> <p>Keyword arguments to pass to the solver. Default value is an empty <code>dict</code>.</p> required Source code in <code>momentGW/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Attributes\n    self.converged = None\n    self.se = None\n    self.gf = None\n    self._qp_energy = None\n</code></pre>"},{"location":"reference/qsgw/#momentGW.qsgw.qsGW.name","title":"<code>momentGW.qsgw.qsGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/qsgw/#momentGW.qsgw.qsGW.has_fock_loop","title":"<code>momentGW.qsgw.qsGW.has_fock_loop</code>  <code>property</code>","text":"<p>Get a boolean indicating whether the solver requires a Fock loop. In qsGW, this is always <code>True</code>.</p>"},{"location":"reference/qsgw/#momentGW.qsgw.qsGW.project_basis","title":"<code>momentGW.qsgw.qsGW.project_basis(matrix, ovlp, mo1, mo2)</code>  <code>staticmethod</code>","text":"<p>Project a matrix from one basis to another.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray or Lehmann</code> <p>Matrix to project. Can also be a <code>dyson.Lehmann</code> or object, in which case the <code>couplings</code> attribute is projected.</p> required <code>ovlp</code> <code>ndarray</code> <p>Overlap matrix in the shared (AO) basis.</p> required <code>mo1</code> <code>ndarray</code> <p>First basis, rotates from the shared (AO) basis into the basis of <code>matrix</code>.</p> required <code>mo2</code> <code>ndarray</code> <p>Second basis, rotates from the shared (AO) basis into the desired basis of the output.</p> required <p>Returns:</p> Name Type Description <code>projected_matrix</code> <code>ndarray or Lehmann</code> <p>Matrix projected into the desired basis.</p> Source code in <code>momentGW/qsgw.py</code> <pre><code>@staticmethod\ndef project_basis(matrix, ovlp, mo1, mo2):\n    \"\"\"Project a matrix from one basis to another.\n\n    Parameters\n    ----------\n    matrix : numpy.ndarray or dyson.Lehmann\n        Matrix to project. Can also be a `dyson.Lehmann` or object, in\n        which case the `couplings` attribute is projected.\n    ovlp : numpy.ndarray\n        Overlap matrix in the shared (AO) basis.\n    mo1 : numpy.ndarray\n        First basis, rotates from the shared (AO) basis into the\n        basis of `matrix`.\n    mo2 : numpy.ndarray\n        Second basis, rotates from the shared (AO) basis into the\n        desired basis of the output.\n\n    Returns\n    -------\n    projected_matrix : numpy.ndarray or dyson.Lehmann\n        Matrix projected into the desired basis.\n    \"\"\"\n\n    # Build the projection matrix\n    proj = util.einsum(\"...pq,...pi,...qj-&gt;...ij\", ovlp, mo1, mo2)\n\n    # Project the matrix\n    if isinstance(matrix, np.ndarray):\n        projected_matrix = util.einsum(\"...pq,...pi,...qj-&gt;...ij\", matrix, proj, proj)\n    else:\n        coupling = util.einsum(\"...pk,...pi-&gt;...ik\", matrix.couplings, proj)\n        projected_matrix = matrix.copy()\n        projected_matrix.couplings = coupling\n\n    return projected_matrix\n</code></pre>"},{"location":"reference/qsgw/#momentGW.qsgw.qsGW.self_energy_to_moments","title":"<code>momentGW.qsgw.qsGW.self_energy_to_moments(se, nmom_max)</code>  <code>staticmethod</code>","text":"<p>Return the hole and particle moments for a self-energy.</p> <p>Parameters:</p> Name Type Description Default <code>se</code> <code>Lehmann</code> <p>Self-energy to compute the moments of.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <p>Returns:</p> Name Type Description <code>th</code> <code>ndarray</code> <p>Hole moments.</p> <code>tp</code> <code>ndarray</code> <p>Particle moments.</p> Source code in <code>momentGW/qsgw.py</code> <pre><code>@staticmethod\ndef self_energy_to_moments(se, nmom_max):\n    \"\"\"Return the hole and particle moments for a self-energy.\n\n    Parameters\n    ----------\n    se : dyson.Lehmann\n        Self-energy to compute the moments of.\n    nmom_max : int\n        Maximum moment number to calculate.\n\n    Returns\n    -------\n    th : numpy.ndarray\n        Hole moments.\n    tp : numpy.ndarray\n        Particle moments.\n    \"\"\"\n    th = se.occupied().moment(range(nmom_max + 1))\n    tp = se.virtual().moment(range(nmom_max + 1))\n    return th, tp\n</code></pre>"},{"location":"reference/qsgw/#momentGW.qsgw.qsGW.build_static_potential","title":"<code>momentGW.qsgw.qsGW.build_static_potential(mo_energy, se)</code>","text":"<p>Build the static potential approximation to the self-energy.</p> <p>Parameters:</p> Name Type Description Default <code>mo_energy</code> <code>ndarray</code> <p>Molecular orbital energies.</p> required <code>se</code> <code>Lehmann</code> <p>Self-energy to approximate.</p> required <p>Returns:</p> Name Type Description <code>se_qp</code> <code>ndarray</code> <p>Static potential approximation to the self-energy.</p> Source code in <code>momentGW/qsgw.py</code> <pre><code>def build_static_potential(self, mo_energy, se):\n    \"\"\"Build the static potential approximation to the self-energy.\n\n    Parameters\n    ----------\n    mo_energy : numpy.ndarray\n        Molecular orbital energies.\n    se : dyson.Lehmann\n        Self-energy to approximate.\n\n    Returns\n    -------\n    se_qp : numpy.ndarray\n        Static potential approximation to the self-energy.\n    \"\"\"\n\n    # Get the static potential\n    if self.srg == 0.0:\n        eta = np.sign(se.energies) * self.eta * 1.0j\n        denom = lib.direct_sum(\"p-q-q-&gt;pq\", mo_energy, se.energies, eta)\n        se_i = util.einsum(\"pk,qk,pk-&gt;pq\", se.couplings, np.conj(se.couplings), 1 / denom)\n        se_j = util.einsum(\"pk,qk,qk-&gt;pq\", se.couplings, np.conj(se.couplings), 1 / denom)\n    else:\n        se_i = np.zeros((mo_energy.size, mo_energy.size), dtype=se.dtype)\n        se_j = np.zeros((mo_energy.size, mo_energy.size), dtype=se.dtype)\n        for k0, k1 in lib.prange(0, se.naux, 120):\n            denom = lib.direct_sum(\"p-k-&gt;pk\", mo_energy, se.energies[k0:k1])\n            d2p = lib.direct_sum(\"pk,qk-&gt;pqk\", denom**2, denom**2)\n            reg = 1 - np.exp(-d2p * self.srg)\n            reg *= lib.direct_sum(\"pk,qk-&gt;pqk\", denom, denom)\n            reg /= d2p\n            v = se.couplings[:, k0:k1]\n            se_i += util.einsum(\"pk,qk,pqk-&gt;pq\", v, np.conj(v), reg)\n            se_j += se_i.T.conj()\n\n    # Find the Hermitian part\n    se_ij = 0.5 * (se_i + se_j)\n\n    # Ensure the static potential is Hermitian\n    if not np.iscomplexobj(se.couplings):\n        se_ij = se_ij.real\n    else:\n        se_ij[np.diag_indices_from(se_ij)] = se_ij[np.diag_indices_from(se_ij)].real\n\n    return se_ij\n</code></pre>"},{"location":"reference/qsgw/#momentGW.qsgw.kernel","title":"<code>momentGW.qsgw.kernel(gw, nmom_max, moments=None, integrals=None)</code>","text":"<p>Moment-constrained quasiparticle self-consistent GW.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseGW</code> <p>GW object.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>moments</code> <code>tuple of numpy.ndarray</code> <p>Tuple of (hole, particle) moments, if passed then they will be used  as the initial guess instead of calculating them. Default value is <code>None</code>.</p> <code>None</code> <code>integrals</code> <code>BaseIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>conv</code> <code>bool</code> <p>Convergence flag.</p> <code>gf</code> <code>Lehmann</code> <p>Green's function object.</p> <code>se</code> <code>Lehmann</code> <p>Self-energy object.</p> <code>qp_energy</code> <code>ndarray</code> <p>Quasiparticle energies.</p> Source code in <code>momentGW/qsgw.py</code> <pre><code>def kernel(\n    gw,\n    nmom_max,\n    moments=None,\n    integrals=None,\n):\n    \"\"\"\n    Moment-constrained quasiparticle self-consistent GW.\n\n    Parameters\n    ----------\n    gw : BaseGW\n        GW object.\n    nmom_max : int\n        Maximum moment number to calculate.\n    moments : tuple of numpy.ndarray, optional\n        Tuple of (hole, particle) moments, if passed then they will\n        be used  as the initial guess instead of calculating them.\n        Default value is `None`.\n    integrals : BaseIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    conv : bool\n        Convergence flag.\n    gf : dyson.Lehmann\n        Green's function object.\n    se : dyson.Lehmann\n        Self-energy object.\n    qp_energy : numpy.ndarray\n        Quasiparticle energies.\n    \"\"\"\n\n    if gw.polarizability.lower() == \"drpa-exact\":\n        raise NotImplementedError(\"%s for polarizability=%s\" % (gw.name, gw.polarizability))\n\n    # Get the integrals\n    if integrals is None:\n        integrals = gw.ao2mo()\n\n    # Initialise the orbital\n    mo_energy = gw.mo_energy.copy()\n    mo_coeff = gw.mo_coeff.copy()\n\n    with util.SilentSCF(gw._scf):\n        # Get the overlap\n        ovlp = gw._scf.get_ovlp()\n        sc = util.einsum(\"...pq,...qi-&gt;...pi\", ovlp, mo_coeff)\n\n        # Get the density matrix\n        dm = gw._scf.make_rdm1(mo_coeff, gw.mo_occ)\n        dm = util.einsum(\"...pq,...pi,...qj-&gt;...ij\", dm, np.conj(sc), sc)\n\n        # Get the core Hamiltonian\n        h1e = gw._scf.get_hcore()\n        h1e = util.einsum(\"...pq,...pi,...qj-&gt;...ij\", h1e, np.conj(mo_coeff), mo_coeff)\n\n    # Initialise the DIIS object\n    diis = util.DIIS()\n    diis.space = gw.diis_space\n\n    # Get the solver\n    solver_options = {} if not gw.solver_options else gw.solver_options.copy()\n    for key in gw.solver._opts:\n        solver_options[key] = solver_options.get(key, getattr(gw, key, getattr(gw.solver, key)))\n    with logging.with_silent():\n        subgw = gw.solver(gw._scf, **solver_options)\n        subgw.frozen = gw.frozen\n\n    # Get the moments\n    subconv, gf, se, _ = subgw._kernel(nmom_max, integrals=integrals)\n    logging.write(\"\")\n    th, tp = gw.self_energy_to_moments(se, nmom_max)\n\n    # Initialise convergence quantities\n    conv = False\n    se_qp = None\n\n    for cycle in range(1, gw.max_cycle + 1):\n        with logging.with_comment(f\"Start of iteration {cycle}\"):\n            logging.write(\"\")\n\n        with logging.with_status(f\"Iteration {cycle}\"):\n            # Build the static potential\n            se_qp_prev = se_qp if cycle &gt; 1 else None\n            se_qp = gw.build_static_potential(mo_energy, se)\n            se_qp = diis.update(se_qp)\n            if gw.damping != 0.0 and cycle &gt; 1:\n                se_qp = (1.0 - gw.damping) * se_qp + gw.damping * se_qp_prev\n\n        # Update the MO energies and orbitals - essentially a Fock\n        # loop using the folded static self-energy.\n        conv_qp = False\n        diis_qp = util.DIIS()\n        diis_qp.space = gw.diis_space_qp\n        mo_energy_prev = mo_energy.copy()\n        with logging.with_table(title=\"Quasiparticle loop\") as table:\n            table.add_column(\"Iter\", justify=\"right\")\n            table.add_column(\"\u0394 (density)\", justify=\"right\")\n\n            for qp_cycle in range(1, gw.max_cycle_qp + 1):\n                with logging.with_status(f\"Iteration [{cycle}, {qp_cycle}]\"):\n                    # Update the Fock matrix\n                    fock = integrals.get_fock(dm, h1e)\n                    fock_eff = fock + se_qp\n                    fock_eff = diis_qp.update(fock_eff)\n                    fock_eff = mpi_helper.bcast(fock_eff, root=0)\n\n                    # Update the MOs\n                    mo_energy, u = np.linalg.eigh(fock_eff)\n                    u = mpi_helper.bcast(u, root=0)\n                    mo_coeff = util.einsum(\"...pq,...qi-&gt;...pi\", gw.mo_coeff, u)\n\n                    # Update the density matrix\n                    dm_prev = dm\n                    dm = gw._scf.make_rdm1(u, gw.mo_occ)\n                    error = np.max(np.abs(dm - dm_prev))\n                    conv_qp = error &lt; gw.conv_tol_qp\n                    if qp_cycle in {1, 5, 10, 50, 100, gw.max_cycle_qp} or conv_qp:\n                        style = logging.rate(error, gw.conv_tol_qp, gw.conv_tol_qp * 1e2)\n                        table.add_row(f\"{qp_cycle}\", f\"[{style}]{error:.3g}[/]\")\n                    if conv_qp:\n                        break\n\n        logging.write(table)\n        logging.write(\"\")\n\n        with logging.with_status(f\"Iteration {cycle}\"):\n            # Update the self-energy\n            mo_energy_full = gw.mo_energy_with_frozen.copy()\n            mo_energy_full[..., gw.active] = mo_energy\n            subgw.mo_energy = mo_energy_full\n            mo_coeff_full = gw.mo_coeff_with_frozen.copy()\n            mo_coeff_full[..., gw.active] = mo_coeff\n            subgw.mo_coeff = mo_coeff_full\n            subconv, gf, se, _ = subgw._kernel(nmom_max)\n            gf = gw.project_basis(gf, ovlp, mo_coeff, gw.mo_coeff)\n            se = gw.project_basis(se, ovlp, mo_coeff, gw.mo_coeff)\n\n            # Update the moments\n            th_prev, tp_prev = th, tp\n            th, tp = gw.self_energy_to_moments(se, nmom_max)\n\n            # Check for convergence\n            conv = gw.check_convergence(mo_energy, mo_energy_prev, th, th_prev, tp, tp_prev)\n            th_prev = th.copy()\n            tp_prev = tp.copy()\n            with logging.with_comment(f\"End of iteration {cycle}\"):\n                logging.write(\"\")\n            if conv:\n                break\n\n    return conv, gf, se, mo_energy\n</code></pre>"},{"location":"reference/rpa/","title":"Rpa","text":"<p>Construct RPA moments.</p>"},{"location":"reference/rpa/#momentGW.rpa.dRPA","title":"<code>momentGW.rpa.dRPA(gw, nmom_max, integrals, mo_energy=None, mo_occ=None)</code>","text":"<p>             Bases: <code>dTDA</code></p> <p>Compute the self-energy moments using dRPA and numerical integration.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseGW</code> <p>GW object.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>integrals</code> <code>BaseIntegrals</code> <p>Integrals object.</p> required <code>mo_energy</code> <code>dict</code> <p>Molecular orbital energies. Keys are \"g\" and \"w\" for the Green's function and screened Coulomb interaction, respectively. If <code>None</code>, use <code>gw.mo_energy</code> for both. Default value is <code>None</code>.</p> <code>None</code> <code>mo_occ</code> <code>dict</code> <p>Molecular orbital occupancies. Keys are \"g\" and \"w\" for the Green's function and screened Coulomb interaction, respectively. If <code>None</code>, use <code>gw.mo_occ</code> for both. Default value is <code>None</code>.</p> <code>None</code> Notes <p>See <code>momentGW.tda.dTDA.__init__</code> for initialisation details and <code>momentGW.tda.dTDA.kernel</code> for calculation run details.</p> Source code in <code>momentGW/tda.py</code> <pre><code>def __init__(\n    self,\n    gw,\n    nmom_max,\n    integrals,\n    mo_energy=None,\n    mo_occ=None,\n):\n    # Attributes\n    self.gw = gw\n    self.nmom_max = nmom_max\n    self.integrals = integrals\n\n    # Get the MO energies for G and W\n    if mo_energy is not None:\n        self.mo_energy_g = mo_energy[\"g\"]\n        self.mo_energy_w = mo_energy[\"w\"]\n    else:\n        self.mo_energy_g = self.mo_energy_w = gw.mo_energy\n\n    # Get the MO occupancies for G and W\n    if mo_occ is not None:\n        self.mo_occ_g = mo_occ[\"g\"]\n        self.mo_occ_w = mo_occ[\"w\"]\n    else:\n        self.mo_occ_g = self.mo_occ_w = gw.mo_occ\n\n    # Options and thresholds\n    self.report_quadrature_error = True\n    if self.gw.compression and \"ia\" in self.gw.compression.split(\",\"):\n        self.compression_tol = gw.compression_tol\n    else:\n        self.compression_tol = None\n</code></pre>"},{"location":"reference/rpa/#momentGW.rpa.dRPA.integrate","title":"<code>momentGW.rpa.dRPA.integrate()</code>","text":"<p>Optimise the quadrature and perform the integration for the zeroth moment.</p> <p>Returns:</p> Name Type Description <code>integral</code> <code>ndarray</code> <p>Integral array, including the offset part.</p> Source code in <code>momentGW/rpa.py</code> <pre><code>@logging.with_timer(\"Numerical integration\")\n@logging.with_status(\"Performing numerical integration\")\ndef integrate(self):\n    \"\"\"Optimise the quadrature and perform the integration for the\n    zeroth moment.\n\n    Returns\n    -------\n    integral : numpy.ndarray\n        Integral array, including the offset part.\n    \"\"\"\n\n    p0, p1 = self.mpi_slice(self.nov)\n\n    # Construct energy differences\n    d_full = util.build_1h1p_energies(self.mo_energy_w, self.mo_occ_w).ravel()\n    d = d_full[p0:p1]\n\n    # Calculate diagonal part of ERI\n    diag_eri = np.zeros((self.nov,))\n    diag_eri[p0:p1] = util.einsum(\"np,np-&gt;p\", self.integrals.Lia, self.integrals.Lia)\n    diag_eri = mpi_helper.allreduce(diag_eri)\n\n    # Get the offset integral quadrature\n    quad = self.optimise_offset_quad(d_full, diag_eri)\n\n    # Perform the offset integral\n    offset = self.eval_offset_integral(quad, d)\n\n    # Get the main integral quadrature\n    quad = self.optimise_main_quad(d_full, diag_eri)\n\n    # Perform the main integral\n    integral = self.eval_main_integral(quad, d)\n\n    # Report quadrature error\n    if self.report_quadrature_error:\n        a = np.sum((integral[0] - integral[2]) ** 2)\n        b = np.sum((integral[0] - integral[1]) ** 2)\n        a, b = mpi_helper.allreduce(np.array([a, b]))\n        a, b = a**0.5, b**0.5\n        err = self.estimate_error_clencur(a, b)\n        style_half = logging.rate(a, 1e-4, 1e-3)\n        style_quar = logging.rate(b, 1e-8, 1e-6)\n        style_full = logging.rate(err, 1e-12, 1e-9)\n        logging.write(\n            f\"Error in integral:  [{style_full}]{err:.3e}[/] \"\n            f\"(half = [{style_half}]{a:.3e}[/], quarter = [{style_quar}]{b:.3e}[/])\",\n        )\n\n    return integral[0] + offset\n</code></pre>"},{"location":"reference/rpa/#momentGW.rpa.dRPA.build_dd_moments","title":"<code>momentGW.rpa.dRPA.build_dd_moments(integral=None)</code>","text":"<p>Build the moments of the density-density response.</p> <p>Parameters:</p> Name Type Description Default <code>integral</code> <code>ndarray</code> <p>Integral array, including the offset part. If <code>None</code>, calculate from scratch. Default is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>moments</code> <code>ndarray</code> <p>Moments of the density-density response.</p> Source code in <code>momentGW/rpa.py</code> <pre><code>@logging.with_timer(\"Density-density moments\")\n@logging.with_status(\"Constructing density-density moments\")\ndef build_dd_moments(self, integral=None):\n    \"\"\"Build the moments of the density-density response.\n\n    Parameters\n    ----------\n    integral : numpy.ndarray, optional\n        Integral array, including the offset part. If `None`,\n        calculate from scratch. Default is `None`.\n\n    Returns\n    -------\n    moments : numpy.ndarray\n        Moments of the density-density response.\n    \"\"\"\n\n    if integral is None:\n        integral = self.integrate()\n\n    p0, p1 = self.mpi_slice(self.nov)\n    moments = np.zeros((self.nmom_max + 1, self.naux, p1 - p0))\n\n    # Construct energy differences\n    d_full = util.build_1h1p_energies(self.mo_energy_w, self.mo_occ_w).ravel()\n    d = d_full[p0:p1]\n\n    # Calculate (L|ia) D_{ia} and (L|ia) D_{ia}^{-1} intermediates\n    Liad = self.integrals.Lia * d[None]\n    Liadinv = self.integrals.Lia / d[None]\n\n    # Construct (A-B)^{-1}\n    u = np.dot(Liadinv, self.integrals.Lia.T) * 4.0  # aux^2 o v\n    u = mpi_helper.allreduce(u)\n    u = np.linalg.inv(np.eye(self.naux) + u)\n\n    # Get the zeroth order moment\n    moments[0] = integral / d[None]\n    tmp = np.linalg.multi_dot((integral, Liadinv.T, u))  # aux^2 o v\n    tmp = mpi_helper.allreduce(tmp)\n    moments[0] -= np.dot(tmp, Liadinv) * 4.0  # aux^2 o v\n    del u, tmp\n\n    # Get the first order moment\n    moments[1] = Liad\n\n    # Get the higher order moments\n    for i in range(2, self.nmom_max + 1):\n        moments[i] = moments[i - 2] * d[None] ** 2\n        tmp = np.dot(moments[i - 2], self.integrals.Lia.T)  # aux^2 o v\n        tmp = mpi_helper.allreduce(tmp)\n        moments[i] += np.dot(tmp, Liad) * 4.0  # aux^2 o v\n        del tmp\n\n    return moments\n</code></pre>"},{"location":"reference/rpa/#momentGW.rpa.dRPA.build_dd_moments_exact","title":"<code>momentGW.rpa.dRPA.build_dd_moments_exact()</code>","text":"<p>Build the exact moments of the density-density response.</p> <p>Returns:</p> Name Type Description <code>moments</code> <code>ndarray</code> <p>Moments of the density-density response.</p> Source code in <code>momentGW/rpa.py</code> <pre><code>@logging.with_timer(\"Density-density moments\")\n@logging.with_status(\"Constructing density-density moments\")\ndef build_dd_moments_exact(self):\n    \"\"\"Build the exact moments of the density-density response.\n\n    Returns\n    -------\n    moments : numpy.ndarray\n        Moments of the density-density response.\n    \"\"\"\n\n    import sys\n\n    sys.argv.append(\"--silent\")\n    from vayesta.rpa import ssRPA\n\n    rpa = ssRPA(self.gw._scf)\n    rpa.kernel()\n\n    rot = np.concatenate([self.integrals.Lia, self.integrals.Lia], axis=-1)\n\n    moments = rpa.gen_moms(self.nmom_max)\n    moments = util.einsum(\"nij,Pi-&gt;nPj\", moments, rot)\n\n    return moments[:, :, : self.nov]\n</code></pre>"},{"location":"reference/rpa/#momentGW.rpa.dRPA.build_dp_moments","title":"<code>momentGW.rpa.dRPA.build_dp_moments()</code>","text":"<p>Build the moments of the dynamic polarizability for optical spectra calculations.</p> <p>Returns:</p> Name Type Description <code>moments</code> <code>ndarray</code> <p>Moments of the dynamic polarizability.</p> Source code in <code>momentGW/rpa.py</code> <pre><code>def build_dp_moments(self):\n    \"\"\"\n    Build the moments of the dynamic polarizability for optical\n    spectra calculations.\n\n    Returns\n    -------\n    moments : numpy.ndarray\n        Moments of the dynamic polarizability.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/rpa/#momentGW.rpa.dRPA.rescale_quad","title":"<code>momentGW.rpa.dRPA.rescale_quad(bare_quad, a)</code>  <code>staticmethod</code>","text":"<p>Rescale quadrature for grid space <code>a</code>.</p> <p>Parameters:</p> Name Type Description Default <code>bare_quad</code> <code>tuple</code> <p>The quadrature points and weights.</p> required <code>a</code> <code>float</code> <p>Grid spacing.</p> required <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>The quadrature points.</p> <code>weights</code> <code>ndarray</code> <p>The quadrature weights.</p> Source code in <code>momentGW/rpa.py</code> <pre><code>@staticmethod\ndef rescale_quad(bare_quad, a):\n    \"\"\"Rescale quadrature for grid space `a`.\n\n    Parameters\n    ----------\n    bare_quad : tuple\n        The quadrature points and weights.\n    a : float\n        Grid spacing.\n\n    Returns\n    -------\n    points : numpy.ndarray\n        The quadrature points.\n    weights : numpy.ndarray\n        The quadrature weights.\n    \"\"\"\n    return bare_quad[0] * a, bare_quad[1] * a\n</code></pre>"},{"location":"reference/rpa/#momentGW.rpa.dRPA.optimise_offset_quad","title":"<code>momentGW.rpa.dRPA.optimise_offset_quad(d, diag_eri, name='offset')</code>","text":"<p>Optimise the grid spacing of Gauss-Laguerre quadrature for the offset integral.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>ndarray</code> <p>Orbital energy differences.</p> required <code>diag_eri</code> <code>ndarray</code> <p>Diagonal of the ERIs.</p> required <code>name</code> <code>str</code> <p>Name of the integral. Default value is <code>\"offset\"</code>.</p> <code>'offset'</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>The quadrature points.</p> <code>weights</code> <code>ndarray</code> <p>The quadrature weights.</p> Source code in <code>momentGW/rpa.py</code> <pre><code>def optimise_offset_quad(self, d, diag_eri, name=\"offset\"):\n    \"\"\"\n    Optimise the grid spacing of Gauss-Laguerre quadrature for the\n    offset integral.\n\n    Parameters\n    ----------\n    d : numpy.ndarray\n        Orbital energy differences.\n    diag_eri : numpy.ndarray\n        Diagonal of the ERIs.\n    name : str, optional\n        Name of the integral. Default value is `\"offset\"`.\n\n    Returns\n    -------\n    points : numpy.ndarray\n        The quadrature points.\n    weights : numpy.ndarray\n        The quadrature weights.\n    \"\"\"\n\n    # Generate the bare quadrature\n    bare_quad = self.gen_gausslag_quad_semiinf()\n\n    # Calculate the exact value of the integral for the diagonal\n    exact = np.dot(1.0 / d, d * diag_eri)\n\n    # Define the integrand\n    integrand = lambda quad: self.eval_diag_offset_integral(quad, d, diag_eri)\n\n    # Get the optimal quadrature\n    quad = self.get_optimal_quad(bare_quad, integrand, exact, name=name)\n\n    return quad\n</code></pre>"},{"location":"reference/rpa/#momentGW.rpa.dRPA.optimise_main_quad","title":"<code>momentGW.rpa.dRPA.optimise_main_quad(d, diag_eri, name='main')</code>","text":"<p>Optimise the grid spacing of Clenshaw-Curtis quadrature for the main integral.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>ndarray</code> <p>Orbital energy differences.</p> required <code>diag_eri</code> <code>ndarray</code> <p>Diagonal of the ERIs.</p> required <code>name</code> <code>str</code> <p>Name of the integral. Default value is <code>\"main\"</code>.</p> <code>'main'</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>The quadrature points.</p> <code>weights</code> <code>ndarray</code> <p>The quadrature weights.</p> Source code in <code>momentGW/rpa.py</code> <pre><code>def optimise_main_quad(self, d, diag_eri, name=\"main\"):\n    \"\"\"\n    Optimise the grid spacing of Clenshaw-Curtis quadrature for the\n    main integral.\n\n    Parameters\n    ----------\n    d : numpy.ndarray\n        Orbital energy differences.\n    diag_eri : numpy.ndarray\n        Diagonal of the ERIs.\n    name : str, optional\n        Name of the integral. Default value is `\"main\"`.\n\n    Returns\n    -------\n    points : numpy.ndarray\n        The quadrature points.\n    weights : numpy.ndarray\n        The quadrature weights.\n    \"\"\"\n\n    # Generate the bare quadrature\n    bare_quad = self.gen_clencur_quad_inf(even=True)\n\n    # Calculate the exact value of the integral for the diagonal\n    exact = np.sum((d * (d + diag_eri)) ** 0.5)\n    exact -= 0.5 * np.dot(1.0 / d, d * diag_eri)\n    exact -= np.sum(d)\n\n    # Define the integrand\n    integrand = lambda quad: self.eval_diag_main_integral(quad, d, diag_eri)\n\n    # Get the optimal quadrature\n    quad = self.get_optimal_quad(bare_quad, integrand, exact, name=name)\n\n    return quad\n</code></pre>"},{"location":"reference/rpa/#momentGW.rpa.dRPA.get_optimal_quad","title":"<code>momentGW.rpa.dRPA.get_optimal_quad(bare_quad, integrand, exact, name=None)</code>","text":"<p>Get the optimal quadrature.</p> <p>Parameters:</p> Name Type Description Default <code>bare_quad</code> <code>tuple</code> <p>The quadrature points and weights.</p> required <code>integrand</code> <code>function</code> <p>The integrand function.</p> required <code>exact</code> <code>float</code> <p>The exact value of the integral.</p> required <code>name</code> <code>str</code> <p>Name of the integral. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>The quadrature points.</p> <code>weights</code> <code>ndarray</code> <p>The quadrature weights.</p> Source code in <code>momentGW/rpa.py</code> <pre><code>def get_optimal_quad(self, bare_quad, integrand, exact, name=None):\n    \"\"\"Get the optimal quadrature.\n\n    Parameters\n    ----------\n    bare_quad : tuple\n        The quadrature points and weights.\n    integrand : function\n        The integrand function.\n    exact : float\n        The exact value of the integral.\n    name : str, optional\n        Name of the integral. Default value is `None`.\n\n    Returns\n    -------\n    points : numpy.ndarray\n        The quadrature points.\n    weights : numpy.ndarray\n        The quadrature weights.\n    \"\"\"\n\n    def diag_err(spacing):\n        \"\"\"Calculate the error in the diagonal integral.\"\"\"\n        return np.abs(integrand(self.rescale_quad(bare_quad, 10**spacing)) - exact)\n\n    # Optimise the grid spacing\n    res = scipy.optimize.minimize_scalar(diag_err, bounds=(-6, 2), method=\"bounded\")\n    if not res.success:\n        raise RuntimeError(\"Could not optimise `a` value.\")\n\n    # Get the scale\n    solve = 10**res.x\n\n    # Report the result\n    full_name = f\"{f'{name} ' if name else ''}quadrature\".capitalize()\n    style = logging.rate(res.fun, 1e-14, 1e-10)\n    logging.write(f\"{full_name} scale:  {solve:.2e} (error = [{style}]{res.fun:.2e}[/])\")\n\n    return self.rescale_quad(bare_quad, solve)\n</code></pre>"},{"location":"reference/rpa/#momentGW.rpa.dRPA.eval_diag_offset_integral","title":"<code>momentGW.rpa.dRPA.eval_diag_offset_integral(quad, d, diag_eri)</code>","text":"<p>Evaluate the diagonal of the offset integral.</p> <p>Parameters:</p> Name Type Description Default <code>quad</code> <code>tuple</code> <p>The quadrature points and weights.</p> required <code>d</code> <code>ndarray</code> <p>Orbital energy differences.</p> required <code>diag_eri</code> <code>ndarray</code> <p>Diagonal of the ERIs.</p> required <p>Returns:</p> Name Type Description <code>integral</code> <code>ndarray</code> <p>Offset integral.</p> Source code in <code>momentGW/rpa.py</code> <pre><code>def eval_diag_offset_integral(self, quad, d, diag_eri):\n    \"\"\"Evaluate the diagonal of the offset integral.\n\n    Parameters\n    ----------\n    quad : tuple\n        The quadrature points and weights.\n    d : numpy.ndarray\n        Orbital energy differences.\n    diag_eri : numpy.ndarray\n        Diagonal of the ERIs.\n\n    Returns\n    -------\n    integral : numpy.ndarray\n        Offset integral.\n    \"\"\"\n\n    # TODO check this: is this still right, does it need a factor 4.0?\n\n    # Calculate the integral for each point\n    integral = 0.0\n    for point, weight in zip(*quad):\n        expval = np.exp(-2 * point * d)\n        res = np.dot(expval, d * diag_eri)\n        integral += res * weight  # aux^2 o v\n\n    return integral\n</code></pre>"},{"location":"reference/rpa/#momentGW.rpa.dRPA.eval_diag_main_integral","title":"<code>momentGW.rpa.dRPA.eval_diag_main_integral(quad, d, diag_eri)</code>","text":"<p>Evaluate the diagonal of the main integral.</p> <p>Parameters:</p> Name Type Description Default <code>quad</code> <code>tuple</code> <p>The quadrature points and weights.</p> required <code>d</code> <code>ndarray</code> <p>Orbital energy differences.</p> required <code>diag_eri</code> <code>ndarray</code> <p>Diagonal of the ERIs.</p> required <p>Returns:</p> Name Type Description <code>integral</code> <code>ndarray</code> <p>Main integral.</p> Source code in <code>momentGW/rpa.py</code> <pre><code>def eval_diag_main_integral(self, quad, d, diag_eri):\n    \"\"\"Evaluate the diagonal of the main integral.\n\n    Parameters\n    ----------\n    quad : tuple\n        The quadrature points and weights.\n    d : numpy.ndarray\n        Orbital energy differences.\n    diag_eri : numpy.ndarray\n        Diagonal of the ERIs.\n\n    Returns\n    -------\n    integral : numpy.ndarray\n        Main integral.\n    \"\"\"\n\n    def diag_contrib(x, freq):\n        \"\"\"Calculate the diagonal contribution to the integral.\"\"\"\n        integral = np.ones_like(x)\n        integral -= freq**2 / (x + freq**2)\n        integral /= np.pi\n        return integral\n\n    # Calculate the integral for each point\n    integral = 0.0\n    for point, weight in zip(*quad):\n        f = 1.0 / (d**2 + point**2)\n\n        contrib = diag_contrib(d * (d + diag_eri), point)\n        contrib -= diag_contrib(d**2, point)\n        contrib = np.sum(contrib)\n        contrib -= point**2 * np.dot(f**2, d * diag_eri) / np.pi\n\n        integral += weight * contrib\n\n    return integral\n</code></pre>"},{"location":"reference/rpa/#momentGW.rpa.dRPA.eval_offset_integral","title":"<code>momentGW.rpa.dRPA.eval_offset_integral(quad, d, Lia=None)</code>","text":"<p>Evaluate the offset integral.</p> <p>Parameters:</p> Name Type Description Default <code>quad</code> <code>tuple</code> <p>The quadrature points and weights.</p> required <code>d</code> <code>ndarray</code> <p>Orbital energy differences.</p> required <code>Lia</code> <code>ndarray</code> <p>The <code>(aux, W occ, W vir)</code> integral array. If <code>None</code>, use <code>self.integrals.Lia</code>. Keyword argument allows for the use of this function with <code>uhf</code> and <code>pbc</code> modules.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>integral</code> <code>ndarray</code> <p>Offset integral.</p> Source code in <code>momentGW/rpa.py</code> <pre><code>def eval_offset_integral(self, quad, d, Lia=None):\n    \"\"\"Evaluate the offset integral.\n\n    Parameters\n    ----------\n    quad : tuple\n        The quadrature points and weights.\n    d : numpy.ndarray\n        Orbital energy differences.\n    Lia : numpy.ndarray, optional\n        The ``(aux, W occ, W vir)`` integral array. If `None`, use\n        `self.integrals.Lia`. Keyword argument allows for the use of\n        this function with `uhf` and `pbc` modules.\n\n    Returns\n    -------\n    integral : numpy.ndarray\n        Offset integral.\n    \"\"\"\n\n    # Get the integral intermediates\n    if Lia is None:\n        Lia = self.integrals.Lia\n    Liad = Lia * d[None]\n\n    # Calculate the integral for each point\n    integral = np.zeros_like(Liad)\n    for point, weight in zip(*quad):\n        expval = np.exp(-point * d)\n        lhs = np.dot(Liad * expval[None], Lia.T)  # aux^2 o v\n        lhs = mpi_helper.allreduce(lhs)\n        rhs = Lia * expval[None]  # aux o v\n        res = np.dot(lhs, rhs)\n        integral += res * weight  # aux^2 o v\n\n    integral *= 4.0\n    integral += Liad\n\n    return integral\n</code></pre>"},{"location":"reference/rpa/#momentGW.rpa.dRPA.eval_main_integral","title":"<code>momentGW.rpa.dRPA.eval_main_integral(quad, d, Lia=None)</code>","text":"<p>Evaluate the main integral.</p> <p>Parameters:</p> Name Type Description Default <code>quad</code> <code>tuple</code> <p>The quadrature points and weights.</p> required <code>d</code> <code>ndarray</code> <p>Orbital energy differences.</p> required <code>Lia</code> <code>ndarray</code> <p>The (aux, W occ, W vir) integral array. If <code>None</code>, use <code>self.integrals.Lia</code>. Keyword argument allows for the use of this function with <code>uhf</code> and <code>pbc</code> modules.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>integral</code> <code>ndarray</code> <p>Offset integral.</p> Source code in <code>momentGW/rpa.py</code> <pre><code>def eval_main_integral(self, quad, d, Lia=None):\n    \"\"\"Evaluate the main integral.\n\n    Parameters\n    ----------\n    quad : tuple\n        The quadrature points and weights.\n    d : numpy.ndarray\n        Orbital energy differences.\n    Lia : numpy.ndarray\n        The (aux, W occ, W vir) integral array. If `None`, use\n        `self.integrals.Lia`. Keyword argument allows for the use of\n        this function with `uhf` and `pbc` modules.\n\n    Returns\n    -------\n    integral : numpy.ndarray\n        Offset integral.\n    \"\"\"\n\n    # Get the integral intermediates\n    if Lia is None:\n        Lia = self.integrals.Lia\n    naux, nov = Lia.shape  # This `nov` is actually self.mpi_size(nov)\n    Liad = Lia * d[None]\n\n    # Initialise the integral\n    dim = 3 if self.report_quadrature_error else 1\n    integral = np.zeros((dim, naux, nov))\n\n    # Calculate the integral for each point\n    for i, (point, weight) in enumerate(zip(*quad)):\n        f = 1.0 / (d**2 + point**2)\n        q = np.dot(Lia * f[None], Liad.T) * 4.0  # aux^2 o v\n        q = mpi_helper.allreduce(q)\n        tmp = np.linalg.inv(np.eye(naux) + q) - np.eye(naux)\n\n        contrib = np.linalg.multi_dot((q, tmp, Lia))  # aux^2 o v\n        contrib = weight * (contrib * f[None] * (point**2 / np.pi))\n\n        integral[0] += contrib\n        if i % 2 == 0 and self.report_quadrature_error:\n            integral[1] += 2 * contrib\n        if i % 4 == 0 and self.report_quadrature_error:\n            integral[2] += 4 * contrib\n\n    return integral\n</code></pre>"},{"location":"reference/rpa/#momentGW.rpa.dRPA.gen_clencur_quad_inf","title":"<code>momentGW.rpa.dRPA.gen_clencur_quad_inf(even=False)</code>","text":"<p>Generate quadrature points and weights for Clenshaw-Curtis quadrature over an <code>(-inf, +inf)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>even</code> <code>bool</code> <p>Whether to assume an even grid. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Quadrature points.</p> <code>weights</code> <code>ndarray</code> <p>Quadrature weights.</p> Source code in <code>momentGW/rpa.py</code> <pre><code>def gen_clencur_quad_inf(self, even=False):\n    \"\"\"\n    Generate quadrature points and weights for Clenshaw-Curtis\n    quadrature over an ``(-inf, +inf)``.\n\n    Parameters\n    ----------\n    even : bool, optional\n        Whether to assume an even grid. Default is `False`.\n\n    Returns\n    -------\n    points : numpy.ndarray\n        Quadrature points.\n    weights : numpy.ndarray\n        Quadrature weights.\n    \"\"\"\n\n    factor = 1 + int(even)\n    tvals = np.arange(1, self.gw.npoints + 1) / self.gw.npoints\n    tvals *= np.pi / factor\n\n    points = 1.0 / np.tan(tvals)\n    weights = np.pi * factor / (2 * self.gw.npoints * np.sin(tvals) ** 2)\n    if even:\n        weights[-1] /= 2\n\n    return points, weights\n</code></pre>"},{"location":"reference/rpa/#momentGW.rpa.dRPA.gen_gausslag_quad_semiinf","title":"<code>momentGW.rpa.dRPA.gen_gausslag_quad_semiinf()</code>","text":"<p>Generate quadrature points and weights for Gauss-Laguerre quadrature over an <code>(0, +inf)</code>.</p> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>Quadrature points.</p> <code>weights</code> <code>ndarray</code> <p>Quadrature weights.</p> Source code in <code>momentGW/rpa.py</code> <pre><code>def gen_gausslag_quad_semiinf(self):\n    \"\"\"\n    Generate quadrature points and weights for Gauss-Laguerre\n    quadrature over an ``(0, +inf)``.\n\n    Returns\n    -------\n    points : numpy.ndarray\n        Quadrature points.\n    weights : numpy.ndarray\n        Quadrature weights.\n    \"\"\"\n    points, weights = np.polynomial.laguerre.laggauss(self.gw.npoints)\n    weights *= np.exp(points)\n    return points, weights\n</code></pre>"},{"location":"reference/rpa/#momentGW.rpa.dRPA.estimate_error_clencur","title":"<code>momentGW.rpa.dRPA.estimate_error_clencur(i4, i2, imag_tol=1e-10)</code>","text":"<p>Estimate the quadrature error for Clenshaw-Curtis quadrature.</p> <p>Parameters:</p> Name Type Description Default <code>i4</code> <code>ndarray</code> <p>Integral at one-quarter the number of points.</p> required <code>i2</code> <code>ndarray</code> <p>Integral at one-half the number of points.</p> required <code>imag_tol</code> <code>float</code> <p>Threshold to consider the imaginary part of a root to be zero. Default value is <code>1e-10</code>.</p> <code>1e-10</code> <p>Returns:</p> Name Type Description <code>error</code> <code>ndarray</code> <p>Estimated error.</p> Source code in <code>momentGW/rpa.py</code> <pre><code>def estimate_error_clencur(self, i4, i2, imag_tol=1e-10):\n    \"\"\"\n    Estimate the quadrature error for Clenshaw-Curtis quadrature.\n\n    Parameters\n    ----------\n    i4 : numpy.ndarray\n        Integral at one-quarter the number of points.\n    i2 : numpy.ndarray\n        Integral at one-half the number of points.\n    imag_tol : float, optional\n        Threshold to consider the imaginary part of a root to be zero.\n        Default value is `1e-10`.\n\n    Returns\n    -------\n    error : numpy.ndarray\n        Estimated error.\n    \"\"\"\n\n    if (i4 - i2) &lt; 1e-14:\n        return 0.0\n\n    # Eq. 103 from https://arxiv.org/abs/2301.09107\n    roots = np.roots([1, 0, i4 / (i4 - i2), -i2 / (i4 - i2)])\n\n    # Require a real root between 0 and 1\n    real_roots = roots[np.abs(roots.imag) &lt; 1e-10].real\n\n    # Check how many there are\n    if len(real_roots) &gt; 1:\n        logging.warn(\n            \"Nested quadrature error estimation gives [bad]%d real roots[/]. \"\n            \"Taking smallest positive root.\" % len(real_roots),\n        )\n    else:\n        logging.write(\n            f\"Nested quadrature error estimation gives {len(real_roots)} \"\n            f\"real root{'s' if len(real_roots) != 1 else ''}.\",\n        )\n\n    # Check if there is a root between 0 and 1\n    if not np.any(np.logical_and(real_roots &gt; 0, real_roots &lt; 1)):\n        logging.warn(\n            \"Nested quadrature error estimation gives [bad]no root between 0 and 1[/].\"\n        )\n        return np.nan\n    else:\n        root = np.min(real_roots[np.logical_and(real_roots &gt; 0, real_roots &lt; 1)])\n\n    # Calculate the error\n    error = i2 / (1.0 + root**-2)\n\n    return error\n</code></pre>"},{"location":"reference/scgw/","title":"Scgw","text":"<p>Spin-restricted self-consistent GW via self-energy moment constraitns for molecular systems.</p>"},{"location":"reference/scgw/#momentGW.scgw.scGW","title":"<code>momentGW.scgw.scGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>evGW</code></p> <p>Spin-restricted self-consistent GW via self-energy moment constraints for molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>SCF</code> <p>PySCF mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>g0</code> <code>bool</code> <p>If <code>True</code>, do not self-consistently update the eigenvalues in the Green's function. Default value is <code>False</code>.</p> required <code>w0</code> <code>bool</code> <p>If <code>True</code>, do not self-consistently update the eigenvalues in the screened Coulomb interaction. Default value is <code>False</code>.</p> required <code>max_cycle</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>50</code>.</p> required <code>conv_tol</code> <code>float</code> <p>Convergence threshold in the change in the HOMO and LUMO. Default value is <code>1e-8</code>.</p> required <code>conv_tol_moms</code> <code>float</code> <p>Convergence threshold in the change in the moments. Default value is <code>1e-8</code>.</p> required <code>diis_space</code> <code>int</code> <p>Size of the DIIS extrapolation space. Default value is <code>8</code>.</p> required <code>damping</code> <code>float</code> <p>Damping parameter. Default value is <code>0.0</code>.</p> required Source code in <code>momentGW/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Attributes\n    self.converged = None\n    self.se = None\n    self.gf = None\n    self._qp_energy = None\n</code></pre>"},{"location":"reference/scgw/#momentGW.scgw.scGW.name","title":"<code>momentGW.scgw.scGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/scgw/#momentGW.scgw.kernel","title":"<code>momentGW.scgw.kernel(gw, nmom_max, moments=None, integrals=None)</code>","text":"<p>Moment-constrained self-consistent GW.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseGW</code> <p>GW object.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>moments</code> <code>tuple of numpy.ndarray</code> <p>Tuple of (hole, particle) moments, if passed then they will be used  as the initial guess instead of calculating them. Default value is <code>None</code>.</p> <code>None</code> <code>integrals</code> <code>BaseIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>conv</code> <code>bool</code> <p>Convergence flag.</p> <code>gf</code> <code>Lehmann</code> <p>Green's function object.</p> <code>se</code> <code>Lehmann</code> <p>Self-energy object.</p> <code>qp_energy</code> <code>ndarray</code> <p>Quasiparticle energies. Always <code>None</code> for scGW, returned for compatibility with other scGW methods.</p> Source code in <code>momentGW/scgw.py</code> <pre><code>def kernel(\n    gw,\n    nmom_max,\n    moments=None,\n    integrals=None,\n):\n    \"\"\"\n    Moment-constrained self-consistent GW.\n\n    Parameters\n    ----------\n    gw : BaseGW\n        GW object.\n    nmom_max : int\n        Maximum moment number to calculate.\n    moments : tuple of numpy.ndarray, optional\n        Tuple of (hole, particle) moments, if passed then they will\n        be used  as the initial guess instead of calculating them.\n        Default value is `None`.\n    integrals : BaseIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    conv : bool\n        Convergence flag.\n    gf : dyson.Lehmann\n        Green's function object.\n    se : dyson.Lehmann\n        Self-energy object.\n    qp_energy : numpy.ndarray\n        Quasiparticle energies. Always `None` for scGW, returned for\n        compatibility with other scGW methods.\n    \"\"\"\n\n    if gw.polarizability.lower() == \"drpa-exact\":\n        raise NotImplementedError(\"%s for polarizability=%s\" % (gw.name, gw.polarizability))\n\n    # Get the integrals\n    if integrals is None:\n        integrals = gw.ao2mo()\n\n    # Initialise the orbitals and the Green's function\n    mo_energy = gw.mo_energy.copy()\n    gf_ref = gf = gw.init_gf(gw.mo_energy)\n\n    # Initialise the DIIS object\n    diis = util.DIIS()\n    diis.space = gw.diis_space\n\n    # Get the static part of the SE\n    se_static = gw.build_se_static(integrals)\n\n    # Initialise convergence quantities\n    conv = False\n    th_prev = tp_prev = None\n\n    for cycle in range(1, gw.max_cycle + 1):\n        with logging.with_status(f\"Iteration {cycle}\"):\n            with logging.with_comment(f\"Start of iteration {cycle}\"):\n                logging.write(\"\")\n\n            if cycle &gt; 1:\n                # Rotate ERIs into (MO, QMO) and (QMO occ, QMO vir)\n                integrals.update_coeffs(\n                    mo_coeff_g=(None if gw.g0 else gw._gf_to_coupling(gf, mo_coeff=gw.mo_coeff)),\n                    mo_coeff_w=(None if gw.w0 else gw._gf_to_coupling(gf, mo_coeff=gw.mo_coeff)),\n                    mo_occ_w=None if gw.w0 else gw._gf_to_occ(gf),\n                )\n\n            # Update the moments of the SE\n            if moments is not None and cycle == 1:\n                th, tp = moments\n            else:\n                th, tp = gw.build_se_moments(\n                    nmom_max,\n                    integrals,\n                    mo_energy=dict(\n                        g=gw._gf_to_energy(gf if not gw.g0 else gf_ref),\n                        w=gw._gf_to_energy(gf if not gw.w0 else gf_ref),\n                    ),\n                    mo_occ=dict(\n                        g=gw._gf_to_occ(gf if not gw.g0 else gf_ref),\n                        w=gw._gf_to_occ(gf if not gw.w0 else gf_ref),\n                    ),\n                )\n\n            # Extrapolate the moments\n            try:\n                th, tp = diis.update_with_scaling(np.array((th, tp)), (-2, -1))\n            except Exception:\n                logging.warn(f\"DIIS step [red]failed[/] at iteration {cycle}\")\n\n            # Damp the moments\n            if gw.damping != 0.0 and cycle &gt; 1:\n                th = gw.damping * th_prev + (1.0 - gw.damping) * th\n                tp = gw.damping * tp_prev + (1.0 - gw.damping) * tp\n\n            # Solve the Dyson equation\n            gf, se = gw.solve_dyson(th, tp, se_static, integrals=integrals)\n            gf = gw.remove_unphysical_poles(gf)\n\n            # Update the MO energies\n            mo_energy_prev = mo_energy.copy()\n            mo_energy = gw._gf_to_mo_energy(gf)\n\n            # Check for convergence\n            conv = gw.check_convergence(mo_energy, mo_energy_prev, th, th_prev, tp, tp_prev)\n            th_prev = th.copy()\n            tp_prev = tp.copy()\n            with logging.with_comment(f\"End of iteration {cycle}\"):\n                logging.write(\"\")\n            if conv:\n                break\n\n    return conv, gf, se, None\n</code></pre>"},{"location":"reference/tda/","title":"Tda","text":"<p>Construct TDA moments.</p>"},{"location":"reference/tda/#momentGW.tda.dTDA","title":"<code>momentGW.tda.dTDA(gw, nmom_max, integrals, mo_energy=None, mo_occ=None)</code>","text":"<p>Compute the self-energy moments using dTDA.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseGW</code> <p>GW object.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>integrals</code> <code>Integrals</code> <p>Integrals object.</p> required <code>mo_energy</code> <code>dict</code> <p>Molecular orbital energies. Keys are \"g\" and \"w\" for the Green's function and screened Coulomb interaction, respectively. If <code>None</code>, use <code>gw.mo_energy</code> for both. Default value is <code>None</code>.</p> <code>None</code> <code>mo_occ</code> <code>dict</code> <p>Molecular orbital occupancies. Keys are \"g\" and \"w\" for the Green's function and screened Coulomb interaction, respectively. If <code>None</code>, use <code>gw.mo_occ</code> for both. Default value is <code>None</code>.</p> <code>None</code> Source code in <code>momentGW/tda.py</code> <pre><code>def __init__(\n    self,\n    gw,\n    nmom_max,\n    integrals,\n    mo_energy=None,\n    mo_occ=None,\n):\n    # Attributes\n    self.gw = gw\n    self.nmom_max = nmom_max\n    self.integrals = integrals\n\n    # Get the MO energies for G and W\n    if mo_energy is not None:\n        self.mo_energy_g = mo_energy[\"g\"]\n        self.mo_energy_w = mo_energy[\"w\"]\n    else:\n        self.mo_energy_g = self.mo_energy_w = gw.mo_energy\n\n    # Get the MO occupancies for G and W\n    if mo_occ is not None:\n        self.mo_occ_g = mo_occ[\"g\"]\n        self.mo_occ_w = mo_occ[\"w\"]\n    else:\n        self.mo_occ_g = self.mo_occ_w = gw.mo_occ\n\n    # Options and thresholds\n    self.report_quadrature_error = True\n    if self.gw.compression and \"ia\" in self.gw.compression.split(\",\"):\n        self.compression_tol = gw.compression_tol\n    else:\n        self.compression_tol = None\n</code></pre>"},{"location":"reference/tda/#momentGW.tda.dTDA.nmo","title":"<code>momentGW.tda.dTDA.nmo</code>  <code>property</code>","text":"<p>Get the number of MOs.</p>"},{"location":"reference/tda/#momentGW.tda.dTDA.naux","title":"<code>momentGW.tda.dTDA.naux</code>  <code>property</code>","text":"<p>Get the number of auxiliaries.</p>"},{"location":"reference/tda/#momentGW.tda.dTDA.nov","title":"<code>momentGW.tda.dTDA.nov</code>  <code>property</code>","text":"<p>Get the number of ov states in the screened Coulomb interaction.</p>"},{"location":"reference/tda/#momentGW.tda.dTDA.build_dd_moments","title":"<code>momentGW.tda.dTDA.build_dd_moments(m0=None)</code>","text":"<p>Build the moments of the density-density response.</p> <p>Parameters:</p> Name Type Description Default <code>m0</code> <code>ndarray</code> <p>The zeroth moment of the density-density response. If <code>None</code>, use <code>self.integrals.Lia</code>. This argument allows for custom starting points in the recursion i.e. in optical spectra calculations. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>moments</code> <code>ndarray</code> <p>Moments of the density-density response.</p> Source code in <code>momentGW/tda.py</code> <pre><code>@logging.with_timer(\"Density-density moments\")\n@logging.with_status(\"Constructing density-density moments\")\ndef build_dd_moments(self, m0=None):\n    \"\"\"Build the moments of the density-density response.\n\n    Parameters\n    ----------\n    m0 : numpy.ndarray, optional\n        The zeroth moment of the density-density response. If\n        `None`, use `self.integrals.Lia`. This argument allows for\n        custom starting points in the recursion i.e. in optical\n        spectra calculations. Default value is `None`.\n\n    Returns\n    -------\n    moments : numpy.ndarray\n        Moments of the density-density response.\n    \"\"\"\n\n    # Initialise the moments\n    naux = self.naux if m0 is None else m0.shape[0]\n    p0, p1 = self.mpi_slice(self.nov)\n    moments = np.zeros((self.nmom_max + 1, naux, p1 - p0))\n\n    # Construct energy differences\n    d = util.build_1h1p_energies(self.mo_energy_w, self.mo_occ_w).ravel()[p0:p1]\n\n    # Get the zeroth order moment\n    moments[0] = m0 if m0 is not None else self.integrals.Lia\n\n    # Get the higher order moments\n    for i in range(1, self.nmom_max + 1):\n        moments[i] = moments[i - 1] * d[None]\n        tmp = np.dot(moments[i - 1], self.integrals.Lia.T)\n        tmp = mpi_helper.allreduce(tmp)\n        moments[i] += np.dot(tmp, self.integrals.Lia) * 2.0\n        del tmp\n\n    return moments\n</code></pre>"},{"location":"reference/tda/#momentGW.tda.dTDA.kernel","title":"<code>momentGW.tda.dTDA.kernel(exact=False)</code>","text":"<p>Run the polarizability calculation to compute moments of the self-energy.</p> <p>Parameters:</p> Name Type Description Default <code>exact</code> <code>bool</code> <p>Has no effect and is only present for compatibility with <code>dRPA</code>. Default value is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>moments_occ</code> <code>ndarray</code> <p>Moments of the occupied self-energy.</p> <code>moments_vir</code> <code>ndarray</code> <p>Moments of the virtual self-energy.</p> Source code in <code>momentGW/tda.py</code> <pre><code>def kernel(self, exact=False):\n    \"\"\"\n    Run the polarizability calculation to compute moments of the\n    self-energy.\n\n    Parameters\n    ----------\n    exact : bool, optional\n        Has no effect and is only present for compatibility with\n        `dRPA`. Default value is `False`.\n\n    Returns\n    -------\n    moments_occ : numpy.ndarray\n        Moments of the occupied self-energy.\n    moments_vir : numpy.ndarray\n        Moments of the virtual self-energy.\n    \"\"\"\n\n    # Build the density-density response moments\n    moments_dd = self.build_dd_moments()\n\n    # Build the self-energy moments\n    moments_occ, moments_vir = self.build_se_moments(moments_dd)\n\n    return moments_occ, moments_vir\n</code></pre>"},{"location":"reference/tda/#momentGW.tda.dTDA.convolve","title":"<code>momentGW.tda.dTDA.convolve(eta, eta_orders=None, mo_energy_g=None, mo_occ_g=None)</code>","text":"<p>Handle the convolution of the moments of the Green's function and screened Coulomb interaction.</p> <p>Parameters:</p> Name Type Description Default <code>eta</code> <code>ndarray</code> <p>Moments of the density-density response partly transformed into moments of the screened Coulomb interaction.</p> required <code>mo_energy_g</code> <code>ndarray</code> <p>Energies of the Green's function. If <code>None</code>, use <code>self.mo_energy_g</code>. Default value is <code>None</code>.</p> <code>None</code> <code>eta_orders</code> <code>list</code> <p>List of orders for the rotated density-density moments in <code>eta</code>. If <code>None</code>, assume it spans all required orders. Default value is <code>None</code>.</p> <code>None</code> <code>mo_occ_g</code> <code>ndarray</code> <p>Occupancies of the Green's function. If <code>None</code>, use <code>self.mo_occ_g</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>moments_occ</code> <code>ndarray</code> <p>Moments of the occupied self-energy.</p> <code>moments_vir</code> <code>ndarray</code> <p>Moments of the virtual self-energy.</p> Source code in <code>momentGW/tda.py</code> <pre><code>@logging.with_timer(\"Moment convolution\")\n@logging.with_status(\"Convoluting moments\")\ndef convolve(self, eta, eta_orders=None, mo_energy_g=None, mo_occ_g=None):\n    \"\"\"\n    Handle the convolution of the moments of the Green's function\n    and screened Coulomb interaction.\n\n    Parameters\n    ----------\n    eta : numpy.ndarray\n        Moments of the density-density response partly transformed\n        into moments of the screened Coulomb interaction.\n    mo_energy_g : numpy.ndarray, optional\n        Energies of the Green's function. If `None`, use\n        `self.mo_energy_g`. Default value is `None`.\n    eta_orders : list, optional\n        List of orders for the rotated density-density moments in\n        `eta`. If `None`, assume it spans all required orders.\n        Default value is `None`.\n    mo_occ_g : numpy.ndarray, optional\n        Occupancies of the Green's function. If `None`, use\n        `self.mo_occ_g`. Default value is `None`.\n\n    Returns\n    -------\n    moments_occ : numpy.ndarray\n        Moments of the occupied self-energy.\n    moments_vir : numpy.ndarray\n        Moments of the virtual self-energy.\n    \"\"\"\n\n    # Get the orbitals\n    if mo_energy_g is None:\n        mo_energy_g = self.mo_energy_g\n    if mo_occ_g is None:\n        mo_occ_g = self.mo_occ_g\n\n    # Setup dependent on diagonal SE\n    q0, q1 = self.mpi_slice(mo_energy_g.size)\n    if self.gw.diagonal_se:\n        pq = \"p\"\n        fproc = lambda x: np.diag(x)\n    else:\n        pq = \"pq\"\n        fproc = lambda x: x\n\n    # Initialise the moments\n    nmo = eta.shape[-1]  # avoiding self.nmo for inheritence\n    moments_occ = np.zeros((self.nmom_max + 1, nmo, nmo))\n    moments_vir = np.zeros((self.nmom_max + 1, nmo, nmo))\n\n    # Get the orders for the moments\n    if eta_orders is None:\n        eta_orders = np.arange(self.nmom_max + 1)\n    eta_orders = np.asarray(eta_orders)\n\n    for n in range(self.nmom_max + 1):\n        # Get the binomial coefficients\n        fp = scipy.special.binom(n, eta_orders)\n        fh = fp * (-1) ** eta_orders\n\n        # Construct the occupied moments for this order\n        if np.any(mo_occ_g[q0:q1] &gt; 0):\n            eo = np.power.outer(mo_energy_g[q0:q1][mo_occ_g[q0:q1] &gt; 0], n - eta_orders)\n            to = util.einsum(f\"t,kt,kt{pq}-&gt;{pq}\", fh, eo, eta[mo_occ_g[q0:q1] &gt; 0])\n            moments_occ[n] += fproc(to)\n\n        # Construct the virtual moments for this order\n        if np.any(mo_occ_g[q0:q1] == 0):\n            ev = np.power.outer(mo_energy_g[q0:q1][mo_occ_g[q0:q1] == 0], n - eta_orders)\n            tv = util.einsum(f\"t,ct,ct{pq}-&gt;{pq}\", fp, ev, eta[mo_occ_g[q0:q1] == 0])\n            moments_vir[n] += fproc(tv)\n\n    # Sum over all processes\n    moments_occ = mpi_helper.allreduce(moments_occ)\n    moments_vir = mpi_helper.allreduce(moments_vir)\n\n    # Numerical integration can lead to small non-hermiticity\n    moments_occ = 0.5 * (moments_occ + moments_occ.swapaxes(1, 2).conj())\n    moments_vir = 0.5 * (moments_vir + moments_vir.swapaxes(1, 2).conj())\n\n    return moments_occ, moments_vir\n</code></pre>"},{"location":"reference/tda/#momentGW.tda.dTDA.build_se_moments","title":"<code>momentGW.tda.dTDA.build_se_moments(moments_dd)</code>","text":"<p>Build the moments of the self-energy via convolution.</p> <p>Parameters:</p> Name Type Description Default <code>moments_dd</code> <code>ndarray</code> <p>Moments of the density-density response.</p> required <p>Returns:</p> Name Type Description <code>moments_occ</code> <code>ndarray</code> <p>Moments of the occupied self-energy.</p> <code>moments_vir</code> <code>ndarray</code> <p>Moments of the virtual self-energy.</p> Source code in <code>momentGW/tda.py</code> <pre><code>@logging.with_timer(\"Self-energy moments\")\n@logging.with_status(\"Constructing self-energy moments\")\ndef build_se_moments(self, moments_dd):\n    \"\"\"Build the moments of the self-energy via convolution.\n\n    Parameters\n    ----------\n    moments_dd : numpy.ndarray\n        Moments of the density-density response.\n\n    Returns\n    -------\n    moments_occ : numpy.ndarray\n        Moments of the occupied self-energy.\n    moments_vir : numpy.ndarray\n        Moments of the virtual self-energy.\n    \"\"\"\n\n    # Setup dependent on diagonal SE\n    q0, q1 = self.mpi_slice(self.mo_energy_g.size)\n    if self.gw.diagonal_se:\n        eta = np.zeros((q1 - q0, self.nmo))\n        pq = p = q = \"p\"\n    else:\n        eta = np.zeros((q1 - q0, self.nmo, self.nmo))\n        pq, p, q = \"pq\", \"p\", \"q\"\n\n    # Initialise output moments\n    moments_occ = np.zeros((self.nmom_max + 1, self.nmo, self.nmo))\n    moments_vir = np.zeros((self.nmom_max + 1, self.nmo, self.nmo))\n\n    # Get the moments in (aux|aux) and rotate to (mo|mo)\n    for n in range(self.nmom_max + 1):\n        eta_aux = np.dot(moments_dd[n], self.integrals.Lia.T)  # aux^2 o v\n        eta_aux = mpi_helper.allreduce(eta_aux)\n        for x in range(q1 - q0):\n            Lp = self.integrals.Lpx[:, :, x]\n            eta[x] = util.einsum(f\"P{p},Q{q},PQ-&gt;{pq}\", Lp, Lp, eta_aux) * 2.0\n\n        # Construct the self-energy moments for this order only to\n        # save memory\n        moments_occ_n, moments_vir_n = self.convolve(eta[:, None], eta_orders=[n])\n        moments_occ += moments_occ_n\n        moments_vir += moments_vir_n\n\n    return moments_occ, moments_vir\n</code></pre>"},{"location":"reference/tda/#momentGW.tda.dTDA.build_dp_moments","title":"<code>momentGW.tda.dTDA.build_dp_moments()</code>","text":"<p>Build the moments of the dynamic polarizability for optical spectra calculations.</p> <p>Returns:</p> Name Type Description <code>moments</code> <code>ndarray</code> <p>Moments of the dynamic polarizability.</p> Source code in <code>momentGW/tda.py</code> <pre><code>@logging.with_timer(\"Dynamic polarizability moments\")\n@logging.with_status(\"Constructing dynamic polarizability moments\")\ndef build_dp_moments(self):\n    \"\"\"\n    Build the moments of the dynamic polarizability for optical\n    spectra calculations.\n\n    Returns\n    -------\n    moments : numpy.ndarray\n        Moments of the dynamic polarizability.\n    \"\"\"\n\n    p0, p1 = self.mpi_slice(self.nov)\n\n    # Get the dipole matrices\n    with self.gw.mol.with_common_orig((0, 0, 0)):\n        dip = self.gw.mol.intor_symmetric(\"int1e_r\", comp=3)\n\n    # Rotate into ia basis\n    ci = self.integrals.mo_coeff_w[:, self.integrals.mo_occ_w &gt; 0]\n    ca = self.integrals.mo_coeff_w[:, self.integrals.mo_occ_w == 0]\n    dip = util.einsum(\"xpq,pi,qa-&gt;xia\", dip, ci.conj(), ca)\n    dip = dip.reshape(3, -1)\n\n    # Get the density-density response moments\n    moments_dd = self.build_dd_moments(m0=dip[:, p0:p1])\n\n    # Get the moments of the dynamic polarizability\n    moments_dp = util.einsum(\"px,nqx-&gt;npq\", dip[:, p0:p1], moments_dd)\n\n    return moments_dp\n</code></pre>"},{"location":"reference/tda/#momentGW.tda.dTDA.build_dd_moment_inv","title":"<code>momentGW.tda.dTDA.build_dd_moment_inv()</code>","text":"<p>Build the first inverse (<code>n=-1</code>) moment of the density-density response.</p> <p>Returns:</p> Name Type Description <code>moment</code> <code>ndarray</code> <p>First inverse (<code>n=-1</code>) moment of the density-density response.</p> Notes <p>This is not the full <code>n=-1</code> moment, which is</p> <p>.. math::     D^{-1} - D^{-1} V^\\dagger (I + V D^{-1} V^\\dagger)^{-1} \\             V D^{-1}</p> <p>but rather</p> <p>.. math:: (I + V D^{-1} V^\\dagger)^{-1} V D^{-1}</p> <p>which ensures that the function scales properly. The final contractions are done when constructing the matrix-vector product.</p> Source code in <code>momentGW/tda.py</code> <pre><code>@logging.with_timer(\"Inverse density-density moment\")\n@logging.with_status(\"Constructing inverse density-density moment\")\ndef build_dd_moment_inv(self):\n    r\"\"\"\n    Build the first inverse (`n=-1`) moment of the density-density\n    response.\n\n    Returns\n    -------\n    moment : numpy.ndarray\n        First inverse (`n=-1`) moment of the density-density\n        response.\n\n    Notes\n    -----\n    This is not the full `n=-1` moment, which is\n\n    .. math::\n        D^{-1} - D^{-1} V^\\dagger (I + V D^{-1} V^\\dagger)^{-1} \\\\\n                V D^{-1}\n\n    but rather\n\n    .. math:: (I + V D^{-1} V^\\dagger)^{-1} V D^{-1}\n\n    which ensures that the function scales properly. The final\n    contractions are done when constructing the matrix-vector\n    product.\n    \"\"\"\n\n    # Initialise the moment\n    p0, p1 = self.mpi_slice(self.nov)\n    moment = np.zeros((self.nov, p1 - p0))\n\n    # Construct energy differences\n    d_full = lib.direct_sum(\n        \"a-i-&gt;ia\",\n        self.mo_energy_w[self.mo_occ_w == 0],\n        self.mo_energy_w[self.mo_occ_w &gt; 0],\n    ).ravel()\n    d = d_full[p0:p1]\n\n    # Get the first inverse moment\n    Liadinv = self.integrals.Lia / d[None]\n    u = np.dot(Liadinv, self.integrals.Lia.T)\n    u = mpi_helper.allreduce(u)\n    u = np.linalg.inv(np.eye(self.naux) + u)\n    moment = np.dot(u, Liadinv)\n\n    return moment\n</code></pre>"},{"location":"reference/tda/#momentGW.tda.dTDA.mpi_slice","title":"<code>momentGW.tda.dTDA.mpi_slice(n)</code>","text":"<p>Return the start and end index for the current process for total size <code>n</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Total size.</p> required <p>Returns:</p> Name Type Description <code>p0</code> <code>int</code> <p>Start index for current process.</p> <code>p1</code> <code>int</code> <p>End index for current process.</p> Source code in <code>momentGW/tda.py</code> <pre><code>def mpi_slice(self, n):\n    \"\"\"\n    Return the start and end index for the current process for total\n    size `n`.\n\n    Parameters\n    ----------\n    n : int\n        Total size.\n\n    Returns\n    -------\n    p0 : int\n        Start index for current process.\n    p1 : int\n        End index for current process.\n    \"\"\"\n    return list(mpi_helper.prange(0, n, n))[0]\n</code></pre>"},{"location":"reference/tda/#momentGW.tda.dTDA.mpi_size","title":"<code>momentGW.tda.dTDA.mpi_size(n)</code>","text":"<p>Return the number of states in the current process for total size <code>n</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Total size.</p> required <p>Returns:</p> Name Type Description <code>size</code> <code>int</code> <p>Number of states in current process.</p> Source code in <code>momentGW/tda.py</code> <pre><code>def mpi_size(self, n):\n    \"\"\"\n    Return the number of states in the current process for total size\n    `n`.\n\n    Parameters\n    ----------\n    n : int\n        Total size.\n\n    Returns\n    -------\n    size : int\n        Number of states in current process.\n    \"\"\"\n    p0, p1 = self.mpi_slice(n)\n    return p1 - p0\n</code></pre>"},{"location":"reference/thc/","title":"Thc","text":"<p>Tensor hyper-contraction.</p>"},{"location":"reference/thc/#momentGW.thc.Integrals","title":"<code>momentGW.thc.Integrals(with_df, mo_coeff, mo_occ, file_path=None)</code>","text":"<p>             Bases: <code>Integrals</code></p> <p>Container for the tensor-hypercontracted integrals required for GW methods.</p> <p>Parameters:</p> Name Type Description Default <code>with_df</code> <code>DF</code> <p>Density fitting object.</p> required <code>mo_coeff</code> <code>ndarray</code> <p>Molecular orbital coefficients.</p> required <code>mo_occ</code> <code>ndarray</code> <p>Molecular orbital occupations.</p> required <code>file_path</code> <code>str</code> <p>Path to the HDF5 file containing the integrals. Default value is <code>None</code>.</p> <code>None</code> Source code in <code>momentGW/thc.py</code> <pre><code>def __init__(\n    self,\n    with_df,\n    mo_coeff,\n    mo_occ,\n    file_path=None,\n):\n    # Parameters\n    self.with_df = with_df\n    self.mo_coeff = mo_coeff\n    self.mo_occ = mo_occ\n    self.file_path = file_path\n\n    # Options\n    self.compression = None\n\n    # Logging\n    init_logging()\n\n    # Attributes\n    self._blocks = {}\n    self._blocks[\"coll\"] = None\n    self._blocks[\"cou\"] = None\n    self._mo_coeff_g = None\n    self._mo_coeff_w = None\n    self._mo_occ_w = None\n    self._rot = None\n</code></pre>"},{"location":"reference/thc/#momentGW.thc.Integrals.coll","title":"<code>momentGW.thc.Integrals.coll</code>  <code>property</code>","text":"<p>Get the <code>(aux, MO)</code> collocation array.</p>"},{"location":"reference/thc/#momentGW.thc.Integrals.cou","title":"<code>momentGW.thc.Integrals.cou</code>  <code>property</code>","text":"<p>Get the <code>(aux, aux)</code> Coulomb array.</p>"},{"location":"reference/thc/#momentGW.thc.Integrals.Lp","title":"<code>momentGW.thc.Integrals.Lp</code>  <code>property</code>","text":"<p>Get the <code>(aux, MO)</code> array.</p>"},{"location":"reference/thc/#momentGW.thc.Integrals.Lx","title":"<code>momentGW.thc.Integrals.Lx</code>  <code>property</code>","text":"<p>Get the <code>(aux, MO)</code> array.</p>"},{"location":"reference/thc/#momentGW.thc.Integrals.Li","title":"<code>momentGW.thc.Integrals.Li</code>  <code>property</code>","text":"<p>Get the <code>(aux, W occ)</code> array.</p>"},{"location":"reference/thc/#momentGW.thc.Integrals.La","title":"<code>momentGW.thc.Integrals.La</code>  <code>property</code>","text":"<p>Get the <code>(aux, W vir)</code> array.</p>"},{"location":"reference/thc/#momentGW.thc.Integrals.get_compression_metric","title":"<code>momentGW.thc.Integrals.get_compression_metric()</code>","text":"<p>Return the compression metric - not currently used in THC.</p> Source code in <code>momentGW/thc.py</code> <pre><code>def get_compression_metric(self):\n    \"\"\"Return the compression metric - not currently used in THC.\"\"\"\n    return None\n</code></pre>"},{"location":"reference/thc/#momentGW.thc.Integrals.import_thc_components","title":"<code>momentGW.thc.Integrals.import_thc_components()</code>","text":"<p>Import a HDF5 file containing a dictionary. The keys <code>\"collocation_matrix\"</code> and a <code>\"coulomb_matrix\"</code> must exist, with shapes <code>(MO, aux)</code> and <code>(aux, aux)</code>, respectively.</p> Source code in <code>momentGW/thc.py</code> <pre><code>def import_thc_components(self):\n    \"\"\"\n    Import a HDF5 file containing a dictionary. The keys\n    `\"collocation_matrix\"` and a `\"coulomb_matrix\"` must exist, with\n    shapes ``(MO, aux)`` and ``(aux, aux)``, respectively.\n    \"\"\"\n\n    if self.file_path is None:\n        raise ValueError(\"file path cannot be None for THC implementation\")\n\n    thc_eri = h5py.File(self.file_path, \"r\")\n    coll = np.array(thc_eri[\"collocation_matrix\"])[..., 0].T\n    cou = np.array(thc_eri[\"coulomb_matrix\"])[0, ..., 0]\n    self._blocks[\"coll\"] = coll\n    self._blocks[\"cou\"] = cou\n\n    self._naux = self.cou.shape[0]\n</code></pre>"},{"location":"reference/thc/#momentGW.thc.Integrals.transform","title":"<code>momentGW.thc.Integrals.transform(do_Lpq=True, do_Lpx=True, do_Lia=True)</code>","text":"<p>Transform the integrals in-place.</p> <p>Parameters:</p> Name Type Description Default <code>do_Lpq</code> <code>bool</code> <p>Whether the <code>(aux, MO, MO)</code> array is required. In THC, this requires the <code>Lp</code> array. Default value is <code>True</code>.</p> <code>True</code> <code>do_Lpx</code> <code>bool</code> <p>Whether the <code>(aux, MO, MO)</code> array is required. In THC, this requires the <code>Lx</code> array. Default value is <code>True</code>.</p> <code>True</code> <code>do_Lia</code> <code>bool</code> <p>Whether the <code>(aux, occ, vir)</code> array is required. In THC, this requires the <code>Li</code> and <code>La</code> arrays. Default value is <code>True</code>.</p> <code>True</code> Source code in <code>momentGW/thc.py</code> <pre><code>@logging.with_status(\"Transforming integrals\")\ndef transform(self, do_Lpq=True, do_Lpx=True, do_Lia=True):\n    \"\"\"\n    Transform the integrals in-place.\n\n    Parameters\n    ----------\n    do_Lpq : bool, optional\n        Whether the ``(aux, MO, MO)`` array is required. In THC,\n        this requires the `Lp` array. Default value is `True`.\n    do_Lpx : bool, optional\n        Whether the ``(aux, MO, MO)`` array is required. In THC,\n        this requires the `Lx` array. Default value is `True`.\n    do_Lia : bool, optional\n        Whether the ``(aux, occ, vir)`` array is required. In THC,\n        this requires the `Li` and `La` arrays. Default value is\n        `True`.\n    \"\"\"\n\n    # Check if any arrays are required\n    if not any([do_Lpq, do_Lpx, do_Lia]):\n        return\n\n    # Import THC components\n    if self.coll is None and self.cou is None:\n        self.import_thc_components()\n\n    # Transform the (L|pq) array\n    if do_Lpq:\n        Lp = util.einsum(\"Lp,pq-&gt;Lq\", self.coll, self.mo_coeff)\n        self._blocks[\"Lp\"] = Lp\n\n    # Transform the (L|px) array\n    if do_Lpx:\n        Lx = util.einsum(\"Lp,pq-&gt;Lq\", self.coll, self.mo_coeff_g)\n        self._blocks[\"Lx\"] = Lx\n\n    # Transform the (L|ia) and (L|ai) arrays\n    if do_Lia:\n        ci = self.mo_coeff_w[:, self.mo_occ_w &gt; 0]\n        ca = self.mo_coeff_w[:, self.mo_occ_w == 0]\n\n        Li = util.einsum(\"Lp,pi-&gt;Li\", self.coll, ci)\n        La = util.einsum(\"Lp,pa-&gt;La\", self.coll, ca)\n\n        self._blocks[\"Li\"] = Li\n        self._blocks[\"La\"] = La\n</code></pre>"},{"location":"reference/thc/#momentGW.thc.Integrals.get_j","title":"<code>momentGW.thc.Integrals.get_j(dm, basis='mo')</code>","text":"<p>Build the J matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix.</p> required <code>basis</code> <code>str</code> <p>Basis in which to build the J matrix. One of <code>(\"ao\", \"mo\")</code>. Default value is <code>\"mo\"</code>.</p> <code>'mo'</code> <p>Returns:</p> Name Type Description <code>vj</code> <code>ndarray</code> <p>J matrix.</p> Notes <p>The basis of <code>dm</code> must be the same as <code>basis</code>.</p> Source code in <code>momentGW/thc.py</code> <pre><code>@logging.with_timer(\"J matrix\")\n@logging.with_status(\"Building J matrix\")\ndef get_j(self, dm, basis=\"mo\"):\n    \"\"\"Build the J matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix.\n    basis : str, optional\n        Basis in which to build the J matrix. One of\n        `(\"ao\", \"mo\")`. Default value is `\"mo\"`.\n\n    Returns\n    -------\n    vj : numpy.ndarray\n        J matrix.\n\n    Notes\n    -----\n    The basis of `dm` must be the same as `basis`.\n    \"\"\"\n\n    # Check the input\n    assert basis in (\"ao\", \"mo\")\n\n    # Get the components\n    if basis == \"ao\":\n        if self.coll is None and self.cou is None:\n            self.import_thc_components()\n        Lp = self.coll\n        cou = self.cou\n    else:\n        Lp = self.Lp\n        cou = self.cou\n\n    # Build the J matrix\n    tmp = util.einsum(\"pq,Kp,Kq-&gt;K\", dm, Lp, Lp)\n    tmp = util.einsum(\"K,KL-&gt;L\", tmp, cou)\n    vj = util.einsum(\"L,Lr,Ls-&gt;rs\", tmp, Lp, Lp)\n\n    return vj\n</code></pre>"},{"location":"reference/thc/#momentGW.thc.Integrals.get_k","title":"<code>momentGW.thc.Integrals.get_k(dm, basis='mo')</code>","text":"<p>Build the K matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix.</p> required <code>basis</code> <code>str</code> <p>Basis in which to build the K matrix. One of <code>(\"ao\", \"mo\")</code>. Default value is <code>\"mo\"</code>.</p> <code>'mo'</code> <p>Returns:</p> Name Type Description <code>vk</code> <code>ndarray</code> <p>K matrix.</p> Notes <p>The basis of <code>dm</code> must be the same as <code>basis</code>.</p> Source code in <code>momentGW/thc.py</code> <pre><code>@logging.with_timer(\"K matrix\")\n@logging.with_status(\"Building K matrix\")\ndef get_k(self, dm, basis=\"mo\"):\n    \"\"\"Build the K matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix.\n    basis : str, optional\n        Basis in which to build the K matrix. One of\n        `(\"ao\", \"mo\")`. Default value is `\"mo\"`.\n\n    Returns\n    -------\n    vk : numpy.ndarray\n        K matrix.\n\n    Notes\n    -----\n    The basis of `dm` must be the same as `basis`.\n    \"\"\"\n\n    # Check the input\n    assert basis in (\"ao\", \"mo\")\n\n    # Get the components\n    if basis == \"ao\":\n        if self.coll is None and self.cou is None:\n            self.import_thc_components()\n        Lp = self.coll\n        cou = self.cou\n    else:\n        Lp = self.Lp\n        cou = self.cou\n\n    # Build the K matrix\n    tmp = util.einsum(\"pq,Kp-&gt;Kq\", dm, Lp)\n    tmp = util.einsum(\"Kq,Lq-&gt;KL\", tmp, Lp)\n    tmp = util.einsum(\"KL,KL-&gt;KL\", tmp, cou)\n    tmp = util.einsum(\"KL,Ks-&gt;Ls\", tmp, Lp)\n    vk = util.einsum(\"Ls,Lr-&gt;rs\", tmp, Lp)\n\n    return vk\n</code></pre>"},{"location":"reference/thc/#momentGW.thc.dTDA","title":"<code>momentGW.thc.dTDA(gw, nmom_max, integrals, mo_energy=None, mo_occ=None)</code>","text":"<p>             Bases: <code>dTDA</code></p> <p>Compute the self-energy moments using dTDA and numerical integration with tensor-hypercontraction.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseGW</code> <p>GW object.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>integrals</code> <code>BaseIntegrals</code> <p>Integrals object.</p> required <code>mo_energy</code> <code>numpy.ndarray or tuple of numpy.ndarray</code> <p>Molecular orbital energies. If a tuple is passed, the first element corresponds to the Green's function basis and the second to the screened Coulomb interaction. Default value is that of <code>gw.mo_energy</code>.</p> <code>None</code> <code>mo_occ</code> <code>numpy.ndarray or tuple of numpy.ndarray</code> <p>Molecular orbital occupancies. If a tuple is passed, the first element corresponds to the Green's function basis and the second to the screened Coulomb interaction. Default value is that of <code>gw.mo_occ</code>.</p> <code>None</code> Source code in <code>momentGW/tda.py</code> <pre><code>def __init__(\n    self,\n    gw,\n    nmom_max,\n    integrals,\n    mo_energy=None,\n    mo_occ=None,\n):\n    # Attributes\n    self.gw = gw\n    self.nmom_max = nmom_max\n    self.integrals = integrals\n\n    # Get the MO energies for G and W\n    if mo_energy is not None:\n        self.mo_energy_g = mo_energy[\"g\"]\n        self.mo_energy_w = mo_energy[\"w\"]\n    else:\n        self.mo_energy_g = self.mo_energy_w = gw.mo_energy\n\n    # Get the MO occupancies for G and W\n    if mo_occ is not None:\n        self.mo_occ_g = mo_occ[\"g\"]\n        self.mo_occ_w = mo_occ[\"w\"]\n    else:\n        self.mo_occ_g = self.mo_occ_w = gw.mo_occ\n\n    # Options and thresholds\n    self.report_quadrature_error = True\n    if self.gw.compression and \"ia\" in self.gw.compression.split(\",\"):\n        self.compression_tol = gw.compression_tol\n    else:\n        self.compression_tol = None\n</code></pre>"},{"location":"reference/thc/#momentGW.thc.dTDA.Li","title":"<code>momentGW.thc.dTDA.Li</code>  <code>property</code>","text":"<p>Get the <code>(aux, W occ)</code> array.</p>"},{"location":"reference/thc/#momentGW.thc.dTDA.La","title":"<code>momentGW.thc.dTDA.La</code>  <code>property</code>","text":"<p>Get the <code>(aux, W vir)</code> array.</p>"},{"location":"reference/thc/#momentGW.thc.dTDA.cou","title":"<code>momentGW.thc.dTDA.cou</code>  <code>property</code>","text":"<p>Get the <code>(aux, aux)</code> Coulomb array.</p>"},{"location":"reference/thc/#momentGW.thc.dTDA.build_dd_moments","title":"<code>momentGW.thc.dTDA.build_dd_moments()</code>","text":"<p>Build the moments of the density-density response using tensor-hypercontraction.</p> <p>Returns:</p> Name Type Description <code>moments</code> <code>ndarray</code> <p>Moments of the density-density response.</p> Notes <p>Unlike the standard <code>momentGW.tda</code> implementation, this method scales as :math:<code>O(N^3)</code> with system size instead of :math:<code>O(N^4)</code>.</p> Source code in <code>momentGW/thc.py</code> <pre><code>@logging.with_timer(\"Density-density moments\")\n@logging.with_status(\"Constructing density-density moments\")\ndef build_dd_moments(self):\n    \"\"\"\n    Build the moments of the density-density response using\n    tensor-hypercontraction.\n\n    Returns\n    -------\n    moments : numpy.ndarray\n        Moments of the density-density response.\n\n    Notes\n    -----\n    Unlike the standard `momentGW.tda` implementation, this method\n    scales as :math:`O(N^3)` with system size instead of\n    :math:`O(N^4)`.\n    \"\"\"\n\n    # Initialise the moments\n    zeta = np.zeros((self.nmom_max + 1, self.naux, self.naux))\n    ei = self.mo_energy_w[self.mo_occ_w &gt; 0]\n    ea = self.mo_energy_w[self.mo_occ_w == 0]\n\n    # Get the zeroth order moment\n    cou_occ = np.dot(self.Li, self.Li.T)\n    cou_vir = np.dot(self.La, self.La.T)\n    zeta[0] = cou_occ * cou_vir\n\n    # Initialise intermediate arrays\n    cou_d_left = np.zeros((self.nmom_max + 1, self.naux, self.naux))\n    cou_d_only = np.zeros((self.nmom_max + 1, self.naux, self.naux))\n    cou_left = np.eye(self.naux)\n    cou_square = np.dot(self.cou, zeta[0])\n\n    for i in range(1, self.nmom_max + 1):\n        # Update intermediate arrays\n        cou_d_left[0] = cou_left\n        cou_d_left = np.roll(cou_d_left, 1, axis=0)\n        cou_left = np.dot(cou_square, cou_left) * 2.0\n\n        cou_ei_max = util.einsum(\"i,Pi,Qi-&gt;PQ\", ei**i, self.Li, self.Li) * pow(-1, i)\n        cou_ea_max = util.einsum(\"a,Pa,Qa-&gt;PQ\", ea**i, self.La, self.La)\n        cou_d_only[i] = cou_ea_max * cou_occ + cou_ei_max * cou_vir\n\n        for j in range(1, i):\n            cou_ei = util.einsum(\"i,Pi,Qi-&gt;PQ\", ei**j, self.Li, self.Li) * pow(-1, j)\n            cou_ea = util.einsum(\"a,Pa,Qa-&gt;PQ\", ea ** (i - j), self.La, self.La) * binom(i, j)\n            cou_d_only[i] += cou_ei * cou_ea\n            if j == (i - 1):\n                cou_left += np.dot(self.cou, cou_d_only[j]) * 2.0\n            else:\n                cou_left += (\n                    np.linalg.multi_dot((self.cou, cou_d_only[i - 1 - j], cou_d_left[i - j]))\n                    * 2.0\n                )\n\n            zeta[i] += np.dot(cou_d_only[j], cou_d_left[j])\n\n        zeta[i] += cou_d_only[i]\n        zeta[i] += np.dot(zeta[0], cou_left)\n\n    return zeta\n</code></pre>"},{"location":"reference/thc/#momentGW.thc.dTDA.build_se_moments","title":"<code>momentGW.thc.dTDA.build_se_moments(zeta)</code>","text":"<p>Build the moments of the self-energy via convolution with tensor-hypercontraction.</p> <p>Parameters:</p> Name Type Description Default <code>moments_dd</code> <code>ndarray</code> <p>Moments of the density-density response.</p> required <p>Returns:</p> Name Type Description <code>moments_occ</code> <code>ndarray</code> <p>Moments of the occupied self-energy.</p> <code>moments_vir</code> <code>ndarray</code> <p>Moments of the virtual self-energy.</p> Source code in <code>momentGW/thc.py</code> <pre><code>@logging.with_timer(\"Self-energy moments\")\n@logging.with_status(\"Constructing self-energy moments\")\ndef build_se_moments(self, zeta):\n    \"\"\"\n    Build the moments of the self-energy via convolution with\n    tensor-hypercontraction.\n\n    Parameters\n    ----------\n    moments_dd : numpy.ndarray\n        Moments of the density-density response.\n\n    Returns\n    -------\n    moments_occ : numpy.ndarray\n        Moments of the occupied self-energy.\n    moments_vir : numpy.ndarray\n        Moments of the virtual self-energy.\n    \"\"\"\n\n    # Setup dependent on diagonal SE\n    q0, q1 = self.mpi_slice(self.mo_energy_g.size)\n    if self.gw.diagonal_se:\n        eta = np.zeros((q1 - q0, self.nmom_max + 1, self.nmo))\n        pq = p = q = \"p\"\n    else:\n        eta = np.zeros((q1 - q0, self.nmom_max + 1, self.nmo, self.nmo))\n        pq, p, q = \"pq\", \"p\", \"q\"\n\n    # Get the moments in (aux|aux) and rotate to (mo|mo)\n    for n in range(self.nmom_max + 1):\n        zeta_prime = np.linalg.multi_dot((self.cou, zeta[n], self.cou))\n        for x in range(q1 - q0):\n            Lpx = util.einsum(\"Pp,P-&gt;Pp\", self.integrals.Lp, self.integrals.Lx[:, x + q0])\n            eta[x, n] = util.einsum(f\"P{p},Q{q},PQ-&gt;{pq}\", Lpx, Lpx, zeta_prime) * 2.0\n\n    # Construct the self-energy moments\n    moments_occ, moments_vir = self.convolve(eta)\n\n    return moments_occ, moments_vir\n</code></pre>"},{"location":"reference/util/","title":"Util","text":"<p>Utility functions.</p>"},{"location":"reference/util/#momentGW.util.Timer","title":"<code>momentGW.util.Timer()</code>","text":"<p>Timer class.</p> Source code in <code>momentGW/util.py</code> <pre><code>def __init__(self):\n    self.t_init = time.perf_counter()\n    self.t_prev = time.perf_counter()\n    self.t_curr = time.perf_counter()\n</code></pre>"},{"location":"reference/util/#momentGW.util.Timer.lap","title":"<code>momentGW.util.Timer.lap()</code>","text":"<p>Return the time since the last call to <code>lap</code>.</p> <p>Returns:</p> Name Type Description <code>lap</code> <code>float</code> <p>Lap time.</p> Source code in <code>momentGW/util.py</code> <pre><code>def lap(self):\n    \"\"\"Return the time since the last call to `lap`.\n\n    Returns\n    -------\n    lap : float\n        Lap time.\n    \"\"\"\n    self.t_prev, self.t_curr = self.t_curr, time.perf_counter()\n    return self.t_curr - self.t_prev\n</code></pre>"},{"location":"reference/util/#momentGW.util.Timer.total","title":"<code>momentGW.util.Timer.total()</code>","text":"<p>Return the total time since initialization.</p> <p>Returns:</p> Name Type Description <code>total</code> <code>float</code> <p>Total time.</p> Source code in <code>momentGW/util.py</code> <pre><code>def total(self):\n    \"\"\"Return the total time since initialization.\n\n    Returns\n    -------\n    total : float\n        Total time.\n    \"\"\"\n    return time.perf_counter() - self.t_init\n</code></pre>"},{"location":"reference/util/#momentGW.util.Timer.format_time","title":"<code>momentGW.util.Timer.format_time(seconds, precision=2)</code>  <code>staticmethod</code>","text":"<p>Return a formatted time.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Time in seconds.</p> required <code>precision</code> <code>int</code> <p>Number of time units to display. Default is <code>2</code>.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>formatted</code> <code>str</code> <p>Formatted time.</p> Source code in <code>momentGW/util.py</code> <pre><code>@staticmethod\ndef format_time(seconds, precision=2):\n    \"\"\"Return a formatted time.\n\n    Parameters\n    ----------\n    seconds : float\n        Time in seconds.\n    precision : int, optional\n        Number of time units to display. Default is `2`.\n\n    Returns\n    -------\n    formatted : str\n        Formatted time.\n    \"\"\"\n\n    # Get the time in hours, minutes, seconds, and milliseconds\n    seconds, milliseconds = divmod(seconds, 1)\n    milliseconds *= 1000\n    minutes, seconds = divmod(seconds, 60)\n    hours, minutes = divmod(minutes, 60)\n\n    # Format the time\n    out = []\n    if hours:\n        out.append(\"%3d h\" % hours)\n    if minutes:\n        out.append(\"%2d m\" % minutes)\n    if seconds:\n        out.append(\"%2d s\" % seconds)\n    if milliseconds:\n        out.append(\"%3d ms\" % milliseconds)\n\n    return \" \".join(out[-max(precision, len(out)) :])\n</code></pre>"},{"location":"reference/util/#momentGW.util.DIIS","title":"<code>momentGW.util.DIIS</code>","text":"<p>             Bases: <code>DIIS</code></p> <p>Direct inversion of the iterative subspace (DIIS).</p> Notes <p>For some reason, the default pyscf DIIS object can result in fully linearly dependent error vectors in high-moment self-consistent calculations. This class is a drop-in replacement with a fallback in this case.</p> See Also <p>pyscf.lib.diis.DIIS : PySCF DIIS object which this class extends.</p>"},{"location":"reference/util/#momentGW.util.DIIS.update_with_scaling","title":"<code>momentGW.util.DIIS.update_with_scaling(x, axis, xerr=None)</code>","text":"<p>Scales the arrays, according to the maximum absolute value along given axis, executes DIIS, and then rescales the output.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Array to update with DIIS.</p> required <code>axis</code> <code>int or tuple</code> <p>Axis or axes along which to scale.</p> required <code>xerr</code> <code>ndarray</code> <p>Error metric for the array. Default is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>x</code> <code>ndarray</code> <p>Updated array.</p> Notes <p>This function is useful for extrapolations on moments which span several orders of magnitude.</p> Source code in <code>momentGW/util.py</code> <pre><code>def update_with_scaling(self, x, axis, xerr=None):\n    \"\"\"\n    Scales the arrays, according to the maximum absolute value along\n    given axis, executes DIIS, and then rescales the output.\n\n    Parameters\n    ----------\n    x : numpy.ndarray\n        Array to update with DIIS.\n    axis : int or tuple\n        Axis or axes along which to scale.\n    xerr : numpy.ndarray, optional\n        Error metric for the array. Default is `None`.\n\n    Returns\n    -------\n    x : numpy.ndarray\n        Updated array.\n\n    Notes\n    -----\n    This function is useful for extrapolations on moments which span\n    several orders of magnitude.\n    \"\"\"\n\n    # Find the scale of the matrices\n    scale = np.max(np.abs(x), axis=axis, keepdims=True)\n    scale[scale == 0] = 1\n\n    # Scale\n    x = x / scale\n    if xerr:\n        xerr = xerr / scale\n\n    # Execute DIIS\n    x = self.update(x, xerr=xerr)\n\n    # Rescale\n    x = x * scale\n\n    return x\n</code></pre>"},{"location":"reference/util/#momentGW.util.DIIS.update_with_complex_unravel","title":"<code>momentGW.util.DIIS.update_with_complex_unravel(x, xerr=None)</code>","text":"<p>Execute DIIS where the error vectors are unravelled to concatenate the real and imaginary parts.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Array to update with DIIS.</p> required <code>xerr</code> <code>ndarray</code> <p>Error metric for the array. Default is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>x</code> <code>ndarray</code> <p>Updated array.</p> Source code in <code>momentGW/util.py</code> <pre><code>def update_with_complex_unravel(self, x, xerr=None):\n    \"\"\"\n    Execute DIIS where the error vectors are unravelled to\n    concatenate the real and imaginary parts.\n\n    Parameters\n    ----------\n    x : numpy.ndarray\n        Array to update with DIIS.\n    xerr : numpy.ndarray, optional\n        Error metric for the array. Default is `None`.\n\n    Returns\n    -------\n    x : numpy.ndarray\n        Updated array.\n    \"\"\"\n\n    # Check if the object is complex\n    if not np.iscomplexobj(x):\n        return self.update(x, xerr=xerr)\n\n    # Get the shape\n    shape = x.shape\n    size = x.size\n\n    # Concatenate\n    x = np.concatenate([np.real(x).ravel(), np.imag(x).ravel()])\n    if xerr is not None:\n        xerr = np.concatenate([np.real(xerr).ravel(), np.imag(xerr).ravel()])\n\n    # Execute DIIS\n    x = self.update(x, xerr=xerr)\n\n    # Unravel\n    x = x[:size] + 1j * x[size:]\n    x = x.reshape(shape)\n\n    return x\n</code></pre>"},{"location":"reference/util/#momentGW.util.DIIS.extrapolate","title":"<code>momentGW.util.DIIS.extrapolate(nd=None)</code>","text":"<p>Extrapolate the DIIS vectors.</p> <p>Parameters:</p> Name Type Description Default <code>nd</code> <code>int</code> <p>Number of vectors to extrapolate. Default is <code>None</code>, which extrapolates all vectors.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>xnew</code> <code>ndarray</code> <p>Extrapolated vector.</p> Notes <p>This function improves the robustness of the DIIS procedure in the event of linear dependencies.</p> See Also <p>pyscf.lib.diis.DIIS.extrapolate :     PySCF DIIS extrapolation which this function refactors.</p> Source code in <code>momentGW/util.py</code> <pre><code>def extrapolate(self, nd=None):\n    \"\"\"\n    Extrapolate the DIIS vectors.\n\n    Parameters\n    ----------\n    nd : int, optional\n        Number of vectors to extrapolate. Default is `None`, which\n        extrapolates all vectors.\n\n    Returns\n    -------\n    xnew : numpy.ndarray\n        Extrapolated vector.\n\n    Notes\n    -----\n    This function improves the robustness of the DIIS procedure in\n    the event of linear dependencies.\n\n    See Also\n    --------\n    pyscf.lib.diis.DIIS.extrapolate :\n        PySCF DIIS extrapolation which this function refactors.\n    \"\"\"\n\n    # Get the number of vectors\n    if nd is None:\n        nd = self.get_num_vec()\n    if nd == 0:\n        raise RuntimeError(\"No vector found in DIIS object.\")\n\n    # Get the Hessian\n    h = self._H[: nd + 1, : nd + 1]\n    g = np.zeros(nd + 1, h.dtype)\n    g[0] = 1\n\n    # Solve the linear system\n    w, v = scipy.linalg.eigh(h)\n    if np.any(abs(w) &lt; 1e-14):\n        idx = abs(w) &gt; 1e-14\n        c = np.dot(v[:, idx] * (1.0 / w[idx]), np.dot(v[:, idx].T.conj(), g))\n    else:\n        try:\n            c = np.linalg.solve(h, g)\n        except np.linalg.linalg.LinAlgError as e:\n            raise np.linalg.linalg.LinAlgError(\"DIIS matrix is singular.\") from e\n\n    # Check for linear dependencies\n    if np.all(abs(c) &lt; 1e-14):\n        raise np.linalg.linalg.LinAlgError(\"DIIS vectors are fully linearly dependent.\")\n\n    # Extrapolate\n    xnew = 0.0\n    for i, ci in enumerate(c[1:]):\n        xnew += self.get_vec(i) * ci\n\n    return xnew\n</code></pre>"},{"location":"reference/util/#momentGW.util.SilentSCF","title":"<code>momentGW.util.SilentSCF(mf)</code>","text":"<p>Context manager to shut PySCF's SCF classes up.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>SCF</code> <p>SCF object to silence.</p> required Source code in <code>momentGW/util.py</code> <pre><code>def __init__(self, mf):\n    self.mf = mf\n    self._cache = {}\n</code></pre>"},{"location":"reference/util/#momentGW.util.SilentSCF.__enter__","title":"<code>momentGW.util.SilentSCF.__enter__()</code>","text":"<p>Return the SCF object with verbosity set to zero.</p> Source code in <code>momentGW/util.py</code> <pre><code>def __enter__(self):\n    \"\"\"\n    Return the SCF object with verbosity set to zero.\n    \"\"\"\n\n    self._cache[\"config\"] = _pyscf_config.VERBOSE\n    _pyscf_config.VERBOSE = 0\n\n    self._cache[\"mol\"] = self.mf.mol.verbose\n    self.mf.mol.verbose = 0\n\n    self._cache[\"mf\"] = self.mf.verbose\n    self.mf.verbose = 0\n\n    if getattr(self.mf, \"with_df\", None):\n        self._cache[\"df\"] = self.mf.with_df.verbose\n        self.mf.with_df.verbose = 0\n\n    return self.mf\n</code></pre>"},{"location":"reference/util/#momentGW.util.SilentSCF.__exit__","title":"<code>momentGW.util.SilentSCF.__exit__(exc_type, exc_value, traceback)</code>","text":"<p>Reset the verbosity of the SCF object.</p> Source code in <code>momentGW/util.py</code> <pre><code>def __exit__(self, exc_type, exc_value, traceback):\n    \"\"\"\n    Reset the verbosity of the SCF object.\n    \"\"\"\n    _pyscf_config.VERBOSE = self._cache[\"config\"]\n    self.mf.mol.verbose = self._cache[\"mol\"]\n    self.mf.verbose = self._cache[\"mf\"]\n    if getattr(self.mf, \"with_df\", None):\n        self.mf.with_df.verbose = self._cache[\"df\"]\n</code></pre>"},{"location":"reference/util/#momentGW.util.list_union","title":"<code>momentGW.util.list_union(*args)</code>","text":"<p>Find the union of a list of lists, with the elements sorted by their first occurrence.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list of list</code> <p>Lists to find the union of.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>out</code> <code>list</code> <p>Union of the lists.</p> Source code in <code>momentGW/util.py</code> <pre><code>def list_union(*args):\n    \"\"\"\n    Find the union of a list of lists, with the elements sorted\n    by their first occurrence.\n\n    Parameters\n    ----------\n    args : list of list\n        Lists to find the union of.\n\n    Returns\n    -------\n    out : list\n        Union of the lists.\n    \"\"\"\n    cache = set()\n    out = []\n    for arg in args:\n        for x in arg:\n            if x not in cache:\n                cache.add(x)\n                out.append(x)\n    return out\n</code></pre>"},{"location":"reference/util/#momentGW.util.build_1h1p_energies","title":"<code>momentGW.util.build_1h1p_energies(mo_energy, mo_occ)</code>","text":"<p>Construct an array of 1h1p energies where elements are</p> <p>.. math::    \\Delta_{ij} = \\epsilon_i - \\epsilon_j</p> <p>Parameters:</p> Name Type Description Default <code>mo_energy</code> <code>numpy.ndarray or tuple of numpy.ndarray</code> <p>Molecular orbital energies. If a tuple, the first element is used for occupied orbitals and the second element is used for virtual orbitals.</p> required <code>mo_occ</code> <code>numpy.ndarray or tuple of numpy.ndarray</code> <p>Molecular orbital occupancies. If a tuple, the first element is used for occupied orbitals and the second element is used for virtual orbitals.</p> required <p>Returns:</p> Name Type Description <code>d</code> <code>ndarray</code> <p>1h1p energies.</p> Source code in <code>momentGW/util.py</code> <pre><code>def build_1h1p_energies(mo_energy, mo_occ):\n    r\"\"\"\n    Construct an array of 1h1p energies where elements are\n\n    .. math::\n       \\\\Delta_{ij} = \\\\epsilon_i - \\\\epsilon_j\n\n    Parameters\n    ----------\n    mo_energy : numpy.ndarray or tuple of numpy.ndarray\n        Molecular orbital energies. If a tuple, the first element\n        is used for occupied orbitals and the second element is used\n        for virtual orbitals.\n    mo_occ : numpy.ndarray or tuple of numpy.ndarray\n        Molecular orbital occupancies. If a tuple, the first element\n        is used for occupied orbitals and the second element is used\n        for virtual orbitals.\n\n    Returns\n    -------\n    d : numpy.ndarray\n        1h1p energies.\n    \"\"\"\n\n    # Check if the input is a tuple\n    if not isinstance(mo_energy, tuple):\n        mo_energy = (mo_energy, mo_energy)\n    if not isinstance(mo_occ, tuple):\n        mo_occ = (mo_occ, mo_occ)\n\n    # Get the occupied and virtual energies\n    e_occ = mo_energy[0][mo_occ[0] &gt; 0]\n    e_vir = mo_energy[1][mo_occ[1] == 0]\n\n    # Construct the energy differences\n    d = lib.direct_sum(\"a-i-&gt;ia\", e_vir, e_occ)\n\n    return d\n</code></pre>"},{"location":"reference/util/#momentGW.util.einsum","title":"<code>momentGW.util.einsum(*operands, **kwargs)</code>","text":"<p>Evaluate an Einstein summation convention on the operands.</p> <p>Using the Einstein summation convention, many common multi-dimensional, linear algebraic array operations can be represented in a simple fashion. In implicit mode <code>einsum</code> computes these values.</p> <p>In explicit mode, <code>einsum</code> provides further flexibility to compute other array operations that might not be considered classical Einstein summation operations, by disabling, or forcing summation over specified subscript labels.</p> <p>See the <code>numpy.einsum</code> documentation for clarification.</p> <p>Parameters:</p> Name Type Description Default <code>operands</code> <code>list</code> <p>Any valid input to <code>numpy.einsum</code>.</p> <code>()</code> <code>out</code> <code>ndarray</code> <p>If provided, the calculation is done into this array.</p> required <code>contract</code> <code>callable</code> <p>The function to use for contraction. Default value is <code>_contract</code>.</p> required <code>optimize</code> <code>bool</code> <p>If <code>True</code>, use the <code>numpy.einsum_path</code> to optimize the contraction. Default value is <code>True</code>.</p> required <p>Returns:</p> Name Type Description <code>output</code> <code>ndarray</code> <p>The calculation based on the Einstein summation convention.</p> See Also <p>numpy.einsum : NumPy's <code>einsum</code> function.</p> Source code in <code>momentGW/util.py</code> <pre><code>def einsum(*operands, **kwargs):\n    \"\"\"\n    Evaluate an Einstein summation convention on the operands.\n\n    Using the Einstein summation convention, many common\n    multi-dimensional, linear algebraic array operations can be\n    represented in a simple fashion. In *implicit* mode `einsum`\n    computes these values.\n\n    In *explicit* mode, `einsum` provides further flexibility to compute\n    other array operations that might not be considered classical\n    Einstein summation operations, by disabling, or forcing summation\n    over specified subscript labels.\n\n    See the `numpy.einsum` documentation for clarification.\n\n    Parameters\n    ----------\n    operands : list\n        Any valid input to `numpy.einsum`.\n    out : numpy.ndarray, optional\n        If provided, the calculation is done into this array.\n    contract : callable, optional\n        The function to use for contraction. Default value is\n        `_contract`.\n    optimize : bool, optional\n        If `True`, use the `numpy.einsum_path` to optimize the\n        contraction. Default value is `True`.\n\n    Returns\n    -------\n    output : numpy.ndarray\n        The calculation based on the Einstein summation convention.\n\n    See Also\n    --------\n    numpy.einsum : NumPy's `einsum` function.\n    \"\"\"\n\n    # Parse the input\n    inp, out, args = np.core.einsumfunc._parse_einsum_input(operands)\n    subscript = f\"{inp}-&gt;{out}\"\n    contract = kwargs.pop(\"contract\", _contract)\n\n    # If it's just a transpose, fallback to NumPy\n    if len(args) &lt; 2:\n        return np.einsum(subscript, *args, **kwargs)\n\n    # If it's a single contraction, call the contract function directly\n    if len(args) == 2:\n        return contract(subscript, *args, **kwargs)\n\n    # Otherwise, use the `einsum_path` to optimize the contraction\n    contractions = np.einsum_path(\n        subscript,\n        *args,\n        optimize=kwargs.get(\"optimize\", True),\n        einsum_call=True,\n    )[1]\n\n    # Execute the contractions in order\n    args = list(args)\n    for i, (inds, idx_rm, einsum_str, remaining, _) in enumerate(contractions):\n        operands = [args.pop(x) for x in inds]\n\n        # Output should only be provided for the last contraction\n        tmp_kwargs = kwargs.copy()\n        if i != len(contractions) - 1:\n            tmp_kwargs[\"out\"] = None\n\n        # Execute the contraction\n        out = contract(einsum_str, *operands, **tmp_kwargs)\n        args.append(out)\n\n    return out\n</code></pre>"},{"location":"reference/pbc/","title":"Index","text":"<p>Methods for periodic systems.</p>"},{"location":"reference/pbc/base/","title":"Base","text":"<p>Base class for moment-constrained GW solvers with periodic boundary conditions.</p>"},{"location":"reference/pbc/base/#momentGW.pbc.base.BaseKGW","title":"<code>momentGW.pbc.base.BaseKGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>BaseGW</code></p> <p>Base class for moment-constrained GW solvers for periodic systems.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>KSCF</code> <p>PySCF periodic mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.pbc.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>fc</code> <code>bool</code> <p>If <code>True</code>, apply finite size corrections. Default value is <code>False</code>.</p> required Source code in <code>momentGW/pbc/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Options\n    self.fc = False\n\n    # Attributes\n    self._kpts = KPoints(self.cell, getattr(mf, \"kpts\", np.zeros((1, 3))))\n</code></pre>"},{"location":"reference/pbc/base/#momentGW.pbc.base.BaseKGW.cell","title":"<code>momentGW.pbc.base.BaseKGW.cell</code>  <code>property</code>","text":"<p>Get the unit cell.</p>"},{"location":"reference/pbc/base/#momentGW.pbc.base.BaseKGW.mol","title":"<code>momentGW.pbc.base.BaseKGW.mol</code>  <code>property</code>","text":"<p>Alias for <code>self.cell</code>.</p>"},{"location":"reference/pbc/base/#momentGW.pbc.base.BaseKGW.nmo","title":"<code>momentGW.pbc.base.BaseKGW.nmo</code>  <code>property</code>","text":"<p>Get the number of molecular orbitals.</p>"},{"location":"reference/pbc/base/#momentGW.pbc.base.BaseKGW.kpts","title":"<code>momentGW.pbc.base.BaseKGW.kpts</code>  <code>property</code>","text":"<p>Get the k-points.</p>"},{"location":"reference/pbc/base/#momentGW.pbc.base.BaseKGW.nkpts","title":"<code>momentGW.pbc.base.BaseKGW.nkpts</code>  <code>property</code>","text":"<p>Get the number of k-points.</p>"},{"location":"reference/pbc/evgw/","title":"Evgw","text":"<p>Spin-restricted eigenvalue self-consistent GW via self-energy moment constraints for periodic systems.</p>"},{"location":"reference/pbc/evgw/#momentGW.pbc.evgw.evKGW","title":"<code>momentGW.pbc.evgw.evKGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>KGW</code>, <code>evGW</code></p> <p>Spin-restricted eigenvalue self-consistent GW via self-energy moment constraints for periodic systems.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>KSCF</code> <p>PySCF periodic mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>fc</code> <code>bool</code> <p>If <code>True</code>, apply finite size corrections. Default value is <code>False</code>.</p> required <code>g0</code> <code>bool</code> <p>If <code>True</code>, do not self-consistently update the eigenvalues in the Green's function. Default value is <code>False</code>.</p> required <code>w0</code> <code>bool</code> <p>If <code>True</code>, do not self-consistently update the eigenvalues in the screened Coulomb interaction. Default value is <code>False</code>.</p> required <code>max_cycle</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>50</code>.</p> required <code>conv_tol</code> <code>float</code> <p>Convergence threshold in the change in the HOMO and LUMO. Default value is <code>1e-8</code>.</p> required <code>conv_tol_moms</code> <code>float</code> <p>Convergence threshold in the change in the moments. Default value is <code>1e-8</code>.</p> required <code>conv_logical</code> <code>callable</code> <p>Function that takes an iterable of booleans as input indicating whether the individual <code>conv_tol</code> and <code>conv_tol_moms</code> have been satisfied, respectively, and returns a boolean indicating overall convergence. For example, the function <code>all</code> requires both metrics to be met, and <code>any</code> requires just one. Default value is <code>all</code>.</p> required <code>diis_space</code> <code>int</code> <p>Size of the DIIS extrapolation space. Default value is <code>8</code>.</p> required <code>damping</code> <code>float</code> <p>Damping parameter. Default value is <code>0.0</code>.</p> required <code>weight_tol</code> <code>float</code> <p>Threshold in physical weight of Green's function poles, below which they are considered zero. Default value is <code>1e-11</code>.</p> required Source code in <code>momentGW/pbc/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Options\n    self.fc = False\n\n    # Attributes\n    self._kpts = KPoints(self.cell, getattr(mf, \"kpts\", np.zeros((1, 3))))\n</code></pre>"},{"location":"reference/pbc/evgw/#momentGW.pbc.evgw.evKGW.name","title":"<code>momentGW.pbc.evgw.evKGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/pbc/evgw/#momentGW.pbc.evgw.evKGW.check_convergence","title":"<code>momentGW.pbc.evgw.evKGW.check_convergence(mo_energy, mo_energy_prev, th, th_prev, tp, tp_prev)</code>","text":"<p>Check for convergence, and print a summary of changes.</p> <p>Parameters:</p> Name Type Description Default <code>mo_energy</code> <code>ndarray</code> <p>Molecular orbital energies at each k-point.</p> required <code>mo_energy_prev</code> <code>ndarray</code> <p>Molecular orbital energies from the previous iteration at each k-point.</p> required <code>th</code> <code>ndarray</code> <p>Moments of the occupied self-energy at each k-point.</p> required <code>th_prev</code> <code>ndarray</code> <p>Moments of the occupied self-energy from the previous iteration at each k-point.</p> required <code>tp</code> <code>ndarray</code> <p>Moments of the virtual self-energy at each k-point.</p> required <code>tp_prev</code> <code>ndarray</code> <p>Moments of the virtual self-energy from the previous iteration at each k-point.</p> required <p>Returns:</p> Name Type Description <code>conv</code> <code>bool</code> <p>Convergence flag.</p> Source code in <code>momentGW/pbc/evgw.py</code> <pre><code>def check_convergence(self, mo_energy, mo_energy_prev, th, th_prev, tp, tp_prev):\n    \"\"\"Check for convergence, and print a summary of changes.\n\n    Parameters\n    ----------\n    mo_energy : numpy.ndarray\n        Molecular orbital energies at each k-point.\n    mo_energy_prev : numpy.ndarray\n        Molecular orbital energies from the previous iteration at\n        each k-point.\n    th : numpy.ndarray\n        Moments of the occupied self-energy at each k-point.\n    th_prev : numpy.ndarray\n        Moments of the occupied self-energy from the previous\n        iteration at each k-point.\n    tp : numpy.ndarray\n        Moments of the virtual self-energy at each k-point.\n    tp_prev : numpy.ndarray\n        Moments of the virtual self-energy from the previous\n        iteration at each k-point.\n\n    Returns\n    -------\n    conv : bool\n        Convergence flag.\n    \"\"\"\n\n    # Get the previous moments\n    if th_prev is None:\n        th_prev = np.zeros_like(th)\n    if tp_prev is None:\n        tp_prev = np.zeros_like(tp)\n\n    # Get the HOMO and LUMO errors\n    error_homo = max(\n        abs(mo[n - 1] - mo_prev[n - 1])\n        for mo, mo_prev, n in zip(mo_energy, mo_energy_prev, self.nocc)\n    )\n    error_lumo = max(\n        abs(mo[n] - mo_prev[n]) for mo, mo_prev, n in zip(mo_energy, mo_energy_prev, self.nocc)\n    )\n\n    # Get the moment errors\n    error_th = max(abs(self._moment_error(t, t_prev)) for t, t_prev in zip(th, th_prev))\n    error_tp = max(abs(self._moment_error(t, t_prev)) for t, t_prev in zip(tp, tp_prev))\n\n    # Print the table\n    style_homo = logging.rate(error_homo, self.conv_tol, self.conv_tol * 1e2)\n    style_lumo = logging.rate(error_lumo, self.conv_tol, self.conv_tol * 1e2)\n    style_th = logging.rate(error_th, self.conv_tol_moms, self.conv_tol_moms * 1e2)\n    style_tp = logging.rate(error_tp, self.conv_tol_moms, self.conv_tol_moms * 1e2)\n    table = logging.Table(title=\"Convergence\")\n    table.add_column(\"Sector\", justify=\"right\")\n    table.add_column(\"\u0394 energy\", justify=\"right\")\n    table.add_column(\"\u0394 moments\", justify=\"right\")\n    table.add_row(\n        \"Hole\", f\"[{style_homo}]{error_homo:.3g}[/]\", f\"[{style_th}]{error_th:.3g}[/]\"\n    )\n    table.add_row(\n        \"Particle\", f\"[{style_lumo}]{error_lumo:.3g}[/]\", f\"[{style_tp}]{error_tp:.3g}[/]\"\n    )\n    logging.write(\"\")\n    logging.write(table)\n\n    return self.conv_logical(\n        (\n            max(error_homo, error_lumo) &lt; self.conv_tol,\n            max(error_th, error_tp) &lt; self.conv_tol_moms,\n        )\n    )\n</code></pre>"},{"location":"reference/pbc/evgw/#momentGW.pbc.evgw.evKGW.remove_unphysical_poles","title":"<code>momentGW.pbc.evgw.evKGW.remove_unphysical_poles(gf)</code>","text":"<p>Remove unphysical poles from the Green's function to stabilise iterations, according to the threshold <code>self.weight_tol</code>.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function at each k-point.</p> required <p>Returns:</p> Name Type Description <code>gf_out</code> <code>tuple of dyson.Lehmann</code> <p>Green's function at each k-point, with potentially fewer poles.</p> Source code in <code>momentGW/pbc/evgw.py</code> <pre><code>def remove_unphysical_poles(self, gf):\n    \"\"\"\n    Remove unphysical poles from the Green's function to stabilise\n    iterations, according to the threshold `self.weight_tol`.\n\n    Parameters\n    ----------\n    gf : tuple of dyson.Lehmann\n        Green's function at each k-point.\n\n    Returns\n    -------\n    gf_out : tuple of dyson.Lehmann\n        Green's function at each k-point, with potentially fewer\n        poles.\n    \"\"\"\n    gf = list(gf)\n    for k, g in enumerate(gf):\n        gf[k] = g.physical(weight=self.weight_tol)\n    return tuple(gf)\n</code></pre>"},{"location":"reference/pbc/fock/","title":"Fock","text":"<p>Fock matrix and static self-energy parts with periodic boundary conditions.</p>"},{"location":"reference/pbc/fock/#momentGW.pbc.fock.FockLoop","title":"<code>momentGW.pbc.fock.FockLoop</code>","text":"<p>             Bases: <code>FockLoop</code></p> <p>Self-consistent loop for the density matrix via the Hartree--Fock self-consistent field for spin-restricted periodic systems.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseKGW</code> <p>GW object.</p> required <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Initial Green's function object at each k-point. If <code>None</code>, use <code>gw.init_gf()</code>. Default value is <code>None</code>.</p> required <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Initial self-energy object at each k-point. If passed, use as dynamic part of the self-energy. If <code>None</code>, self-energy is assumed to be static and fully defined by the Fock matrix. Default value is <code>None</code>.</p> required <code>fock_diis_space</code> <code>int</code> <p>DIIS space size for the Fock matrix. Default value is <code>10</code>.</p> required <code>fock_diis_min_space</code> <code>int</code> <p>Minimum DIIS space size for the Fock matrix. Default value is <code>1</code>.</p> required <code>conv_tol_nelec</code> <code>float</code> <p>Convergence tolerance for the number of electrons. Default value is <code>1e-6</code>.</p> required <code>conv_tol_rdm1</code> <code>float</code> <p>Convergence tolerance for the density matrix. Default value is <code>1e-8</code>.</p> required <code>max_cycle_inner</code> <code>int</code> <p>Maximum number of inner iterations. Default value is <code>100</code>.</p> required <code>max_cycle_outer</code> <code>int</code> <p>Maximum number of outer iterations. Default value is <code>20</code>.</p> required"},{"location":"reference/pbc/fock/#momentGW.pbc.fock.FockLoop.naux","title":"<code>momentGW.pbc.fock.FockLoop.naux</code>  <code>property</code>","text":"<p>Get the number of auxiliary states.</p>"},{"location":"reference/pbc/fock/#momentGW.pbc.fock.FockLoop.nqmo","title":"<code>momentGW.pbc.fock.FockLoop.nqmo</code>  <code>property</code>","text":"<p>Get the number of quasiparticle MOs.</p>"},{"location":"reference/pbc/fock/#momentGW.pbc.fock.FockLoop.kpts","title":"<code>momentGW.pbc.fock.FockLoop.kpts</code>  <code>property</code>","text":"<p>Get the k-points object.</p>"},{"location":"reference/pbc/fock/#momentGW.pbc.fock.FockLoop.auxiliary_shift","title":"<code>momentGW.pbc.fock.FockLoop.auxiliary_shift(fock, se=None)</code>","text":"<p>Optimise a shift in the auxiliary energies to best satisfy the electron number.</p> <p>Parameters:</p> Name Type Description Default <code>fock</code> <code>ndarray</code> <p>Fock matrix.</p> required <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy at each k-point. If <code>None</code>, use <code>self.se</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy at each k-point.</p> Notes <p>If there is no dynamic part of the self-energy (<code>self.se</code> is <code>None</code>), this method returns <code>None</code>.</p> Source code in <code>momentGW/pbc/fock.py</code> <pre><code>def auxiliary_shift(self, fock, se=None):\n    \"\"\"\n    Optimise a shift in the auxiliary energies to best satisfy the\n    electron number.\n\n    Parameters\n    ----------\n    fock : numpy.ndarray\n        Fock matrix.\n    se : tuple of dyson.Lehmann, optional\n        Self-energy at each k-point. If `None`, use `self.se`.\n        Default value is `None`.\n\n    Returns\n    -------\n    se : tuple of dyson.Lehmann\n        Self-energy at each k-point.\n\n    Notes\n    -----\n    If there is no dynamic part of the self-energy (`self.se` is\n    `None`), this method returns `None`.\n    \"\"\"\n\n    # Get the self-energy\n    if se is None:\n        se = self.se\n    if se is None:\n        return None\n\n    # Optimise the shift in the auxiliary energies\n    se, opt = minimize_chempot(\n        se,\n        fock,\n        sum(self.nelec),\n        x0=se[0].chempot,\n        tol=self.conv_tol_nelec,\n        maxiter=self.max_cycle_inner,\n    )\n\n    return se\n</code></pre>"},{"location":"reference/pbc/fock/#momentGW.pbc.fock.FockLoop.search_chempot","title":"<code>momentGW.pbc.fock.FockLoop.search_chempot(gf=None)</code>","text":"<p>Search for a chemical potential for a given Green's function.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function at each k-point. If <code>None</code>, use <code>self.gf</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>chempot</code> <code>float</code> <p>Chemical potential.</p> <code>nerr</code> <code>float</code> <p>Error in the number of electrons.</p> Source code in <code>momentGW/pbc/fock.py</code> <pre><code>def search_chempot(self, gf=None):\n    \"\"\"Search for a chemical potential for a given Green's function.\n\n    Parameters\n    ----------\n    gf : tuple of dyson.Lehmann, optional\n        Green's function at each k-point. If `None`, use `self.gf`.\n        Default value is `None`.\n\n    Returns\n    -------\n    chempot : float\n        Chemical potential.\n    nerr : float\n        Error in the number of electrons.\n    \"\"\"\n\n    # Get the Green's function\n    if gf is None:\n        gf = self.gf\n\n    # Search for the chemical potential\n    chempot, nerr = search_chempot(\n        [g.energies for g in gf],\n        [g.couplings for g in gf],\n        self.nmo,\n        sum(self.nelec),\n    )\n    nerr = abs(nerr)\n\n    return chempot, nerr\n</code></pre>"},{"location":"reference/pbc/fock/#momentGW.pbc.fock.FockLoop.solve_dyson","title":"<code>momentGW.pbc.fock.FockLoop.solve_dyson(fock, se=None)</code>","text":"<p>Solve the Dyson equation for a given Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>fock</code> <code>ndarray</code> <p>Fock matrix at each k-point.</p> required <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy at each k-point. If <code>None</code>, use <code>self.se</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function at each k-point.</p> <code>nerr</code> <code>float</code> <p>Error in the number of electrons.</p> Notes <p>If there is no dynamic part of the self-energy (<code>self.se</code> is <code>None</code>), this method simply diagonalises the Fock matrix and returns the Lehmann representation of the resulting zeroth-order Green's function.</p> Source code in <code>momentGW/pbc/fock.py</code> <pre><code>def solve_dyson(self, fock, se=None):\n    \"\"\"Solve the Dyson equation for a given Fock matrix.\n\n    Parameters\n    ----------\n    fock : numpy.ndarray\n        Fock matrix at each k-point.\n    se : tuple of dyson.Lehmann, optional\n        Self-energy at each k-point. If `None`, use `self.se`.\n        Default value is `None`.\n\n    Returns\n    -------\n    gf : tuple of dyson.Lehmann\n        Green's function at each k-point.\n    nerr : float\n        Error in the number of electrons.\n\n    Notes\n    -----\n    If there is no dynamic part of the self-energy (`self.se` is\n    `None`), this method simply diagonalises the Fock matrix and\n    returns the Lehmann representation of the resulting zeroth-order\n    Green's function.\n    \"\"\"\n\n    # Get the self-energy\n    if se is None:\n        se = self.se\n\n    # Diagonalise the (extended) Fock matrix\n    if se is None:\n        e, c = np.linalg.eigh(fock)\n    else:\n        e, c = zip(*[s.diagonalise_matrix(f, chempot=0.0) for s, f in zip(se, fock)])\n\n    # Broadcast the eigenvalues and eigenvectors in case of\n    # hybrid parallelisation introducing non-determinism\n    e = [mpi_helper.bcast(ek, root=0) for ek in e]\n    c = [mpi_helper.bcast(ck, root=0) for ck in c]\n\n    # Construct the Green's function\n    gf = [Lehmann(ek, ck[: self.nmo], chempot=0.0) for ek, ck in zip(e, c)]\n\n    # Search for the chemical potential\n    chempot, nerr = self.search_chempot(gf)\n    for k in self.kpts.loop(1):\n        gf[k].chempot = chempot\n\n    return tuple(gf), nerr\n</code></pre>"},{"location":"reference/pbc/fock/#momentGW.pbc.fock.FockLoop.kernel","title":"<code>momentGW.pbc.fock.FockLoop.kernel(integrals=None)</code>","text":"<p>Driver for the Fock loop.</p> <p>Parameters:</p> Name Type Description Default <code>integrals</code> <code>KIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>converged</code> <code>bool</code> <p>Whether the loop has converged.</p> <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function object at each k-point.</p> <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy object at each k-point.</p> Source code in <code>momentGW/pbc/fock.py</code> <pre><code>@logging.with_timer(\"Fock loop\")\n@logging.with_status(\"Running Fock loop\")\ndef kernel(self, integrals=None):\n    \"\"\"Driver for the Fock loop.\n\n    Parameters\n    ----------\n    integrals : KIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    converged : bool\n        Whether the loop has converged.\n    gf : tuple of dyson.Lehmann\n        Green's function object at each k-point.\n    se : tuple of dyson.Lehmann\n        Self-energy object at each k-point.\n    \"\"\"\n    return super().kernel(integrals)\n</code></pre>"},{"location":"reference/pbc/fock/#momentGW.pbc.fock.search_chempot_constrained","title":"<code>momentGW.pbc.fock.search_chempot_constrained(w, v, nphys, nelec, occupancy=2)</code>","text":"<p>Search for a chemical potential, constraining the k-point dependent occupancy to ensure no crossover of states. If this is not possible, a ValueError will be raised.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>ndarray</code> <p>Eigenvalues at each k-point.</p> required <code>v</code> <code>ndarray</code> <p>Eigenvectors at each k-point.</p> required <code>nphys</code> <code>int</code> <p>Number of physical states.</p> required <code>nelec</code> <code>int</code> <p>Number of electrons.</p> required <code>occupancy</code> <code>int</code> <p>Number of electrons per state. Default value is <code>2</code>.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>chempot</code> <code>float</code> <p>Chemical potential.</p> <code>error</code> <code>float</code> <p>Error in the number of electrons.</p> Source code in <code>momentGW/pbc/fock.py</code> <pre><code>def search_chempot_constrained(w, v, nphys, nelec, occupancy=2):\n    \"\"\"\n    Search for a chemical potential, constraining the k-point\n    dependent occupancy to ensure no crossover of states. If this\n    is not possible, a ValueError will be raised.\n\n    Parameters\n    ----------\n    w : numpy.ndarray\n        Eigenvalues at each k-point.\n    v : numpy.ndarray\n        Eigenvectors at each k-point.\n    nphys : int\n        Number of physical states.\n    nelec : int\n        Number of electrons.\n    occupancy : int, optional\n        Number of electrons per state. Default value is `2`.\n\n    Returns\n    -------\n    chempot : float\n        Chemical potential.\n    error : float\n        Error in the number of electrons.\n    \"\"\"\n\n    if nelec == 0:\n        return min(wk[0] for wk in w) - 1e-6, 0.0\n\n    nmo = max(len(x) for x in w)\n    nkpts = len(w)\n    sum0 = sum1 = 0.0\n\n    for i in range(nmo):\n        n = 0\n        for k in range(nkpts):\n            n += np.dot(v[k][:nphys, i].conj().T, v[k][:nphys, i]).real\n        n *= occupancy\n        sum0, sum1 = sum1, sum1 + n\n\n        if i &gt; 0 and sum0 &lt;= nelec and nelec &lt;= sum1:\n            break\n\n    if abs(sum0 - nelec) &lt; abs(sum1 - nelec):\n        homo = i - 1\n        error = nelec - sum0\n    else:\n        homo = i\n        error = nelec - sum1\n\n    lumo = homo + 1\n\n    if lumo == nmo:\n        chempot = np.max(w) + 1e-6\n    else:\n        e_homo = np.max([x[homo] for x in w])\n        e_lumo = np.min([x[lumo] for x in w])\n\n        if e_homo &gt; e_lumo:\n            raise ChemicalPotentialError(\n                \"Could not find a chemical potential under \"\n                \"the constrain of equal k-point occupancy.\"\n            )\n\n        chempot = 0.5 * (e_homo + e_lumo)\n\n    return chempot, error\n</code></pre>"},{"location":"reference/pbc/fock/#momentGW.pbc.fock.search_chempot_unconstrained","title":"<code>momentGW.pbc.fock.search_chempot_unconstrained(w, v, nphys, nelec, occupancy=2)</code>","text":"<p>Search for a chemical potential, without constraining the k-point dependent occupancy.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>ndarray</code> <p>Eigenvalues at each k-point.</p> required <code>v</code> <code>ndarray</code> <p>Eigenvectors at each k-point.</p> required <code>nphys</code> <code>int</code> <p>Number of physical states.</p> required <code>nelec</code> <code>int</code> <p>Number of electrons.</p> required <code>occupancy</code> <code>int</code> <p>Number of electrons per state. Default value is <code>2</code>.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>chempot</code> <code>float</code> <p>Chemical potential.</p> <code>error</code> <code>float</code> <p>Error in the number of electrons.</p> Source code in <code>momentGW/pbc/fock.py</code> <pre><code>def search_chempot_unconstrained(w, v, nphys, nelec, occupancy=2):\n    \"\"\"\n    Search for a chemical potential, without constraining the\n    k-point dependent occupancy.\n\n    Parameters\n    ----------\n    w : numpy.ndarray\n        Eigenvalues at each k-point.\n    v : numpy.ndarray\n        Eigenvectors at each k-point.\n    nphys : int\n        Number of physical states.\n    nelec : int\n        Number of electrons.\n    occupancy : int, optional\n        Number of electrons per state. Default value is `2`.\n\n    Returns\n    -------\n    chempot : float\n        Chemical potential.\n    error : float\n        Error in the number of electrons.\n    \"\"\"\n\n    w = np.concatenate(w)\n    v = np.hstack([vk[:nphys] for vk in v])\n\n    mask = np.argsort(w)\n    w = w[mask]\n    v = v[:, mask]\n\n    nmo = v.shape[-1]\n    sum0 = sum1 = 0.0\n\n    for i in range(nmo):\n        n = occupancy * np.dot(v[:nphys, i].conj().T, v[:nphys, i]).real\n        sum0, sum1 = sum1, sum1 + n\n\n        if i &gt; 0 and sum0 &lt;= nelec and nelec &lt;= sum1:\n            break\n\n    if abs(sum0 - nelec) &lt; abs(sum1 - nelec):\n        homo = i - 1\n        error = nelec - sum0\n    else:\n        homo = i\n        error = nelec - sum1\n\n    lumo = homo + 1\n\n    if lumo == len(w):\n        chempot = w[homo] + 1e-6\n    else:\n        chempot = 0.5 * (w[homo] + w[lumo])\n\n    return chempot, error\n</code></pre>"},{"location":"reference/pbc/fock/#momentGW.pbc.fock.search_chempot","title":"<code>momentGW.pbc.fock.search_chempot(w, v, nphys, nelec, occupancy=2)</code>","text":"<p>Search for a chemical potential, first trying with k-point restraints and if that doesn't succeed then without.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>ndarray</code> <p>Eigenvalues at each k-point.</p> required <code>v</code> <code>ndarray</code> <p>Eigenvectors at each k-point.</p> required <code>nphys</code> <code>int</code> <p>Number of physical states.</p> required <code>nelec</code> <code>int</code> <p>Number of electrons.</p> required <code>occupancy</code> <code>int</code> <p>Number of electrons per state. Default value is <code>2</code>.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>chempot</code> <code>float</code> <p>Chemical potential.</p> <code>error</code> <code>float</code> <p>Error in the number of electrons.</p> Source code in <code>momentGW/pbc/fock.py</code> <pre><code>def search_chempot(w, v, nphys, nelec, occupancy=2):\n    \"\"\"\n    Search for a chemical potential, first trying with k-point\n    restraints and if that doesn't succeed then without.\n\n    Parameters\n    ----------\n    w : numpy.ndarray\n        Eigenvalues at each k-point.\n    v : numpy.ndarray\n        Eigenvectors at each k-point.\n    nphys : int\n        Number of physical states.\n    nelec : int\n        Number of electrons.\n    occupancy : int, optional\n        Number of electrons per state. Default value is `2`.\n\n    Returns\n    -------\n    chempot : float\n        Chemical potential.\n    error : float\n        Error in the number of electrons.\n    \"\"\"\n\n    try:\n        chempot, error = search_chempot_constrained(w, v, nphys, nelec, occupancy=occupancy)\n    except ChemicalPotentialError:\n        chempot, error = search_chempot_unconstrained(w, v, nphys, nelec, occupancy=occupancy)\n\n    return chempot, error\n</code></pre>"},{"location":"reference/pbc/fock/#momentGW.pbc.fock.minimize_chempot","title":"<code>momentGW.pbc.fock.minimize_chempot(se, fock, nelec, occupancy=2, x0=0.0, tol=1e-06, maxiter=200)</code>","text":"<p>Optimise the shift in auxiliary energies to satisfy the electron number, ensuring that the same shift is applied at all k-points.</p> <p>Parameters:</p> Name Type Description Default <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy object at each k-point.</p> required <code>fock</code> <code>ndarray</code> <p>Fock matrix at each k-point.</p> required <code>nelec</code> <code>int</code> <p>Number of electrons.</p> required <code>occupancy</code> <code>int</code> <p>Number of electrons per state. Default value is <code>2</code>.</p> <code>2</code> <code>x0</code> <code>float</code> <p>Initial guess value. Default value is <code>0.0</code>.</p> <code>0.0</code> <code>tol</code> <code>float</code> <p>Threshold in the number of electrons. Default value is <code>1e-6</code>.</p> <code>1e-06</code> <code>maxiter</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>200</code>.</p> <code>200</code> <p>Returns:</p> Name Type Description <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy object at each k-point.</p> <code>opt</code> <code>OptimizeResult</code> <p>Result of the optimisation.</p> Source code in <code>momentGW/pbc/fock.py</code> <pre><code>@logging.with_timer(\"Chemical potential optimisation\")\n@logging.with_status(\"Optimising chemical potential\")\ndef minimize_chempot(se, fock, nelec, occupancy=2, x0=0.0, tol=1e-6, maxiter=200):\n    \"\"\"\n    Optimise the shift in auxiliary energies to satisfy the electron\n    number, ensuring that the same shift is applied at all k-points.\n\n    Parameters\n    ----------\n    se : tuple of dyson.Lehmann\n        Self-energy object at each k-point.\n    fock : numpy.ndarray\n        Fock matrix at each k-point.\n    nelec : int\n        Number of electrons.\n    occupancy : int, optional\n        Number of electrons per state. Default value is `2`.\n    x0 : float, optional\n        Initial guess value. Default value is `0.0`.\n    tol : float, optional\n        Threshold in the number of electrons. Default value is `1e-6`.\n    maxiter : int, optional\n        Maximum number of iterations. Default value is `200`.\n\n    Returns\n    -------\n    se : tuple of dyson.Lehmann\n        Self-energy object at each k-point.\n    opt : scipy.optimize.OptimizeResult\n        Result of the optimisation.\n    \"\"\"\n\n    tol = tol**2  # we minimize the squared error\n    dtype = np.result_type(*[s.dtype for s in se], *[f.dtype for f in fock])\n    nphys = max([s.nphys for s in se])\n    naux = max([s.naux for s in se])\n    buf = np.zeros(((nphys + naux) ** 2,), dtype=dtype)\n    fargs = (se, fock, nelec, occupancy, buf)\n\n    options = dict(maxiter=maxiter, ftol=tol, xtol=tol, gtol=tol)\n    kwargs = dict(x0=x0, method=\"TNC\", jac=True, options=options)\n    fun = _gradient\n\n    opt = scipy.optimize.minimize(fun, args=fargs, **kwargs)\n\n    for s in se:\n        s.energies -= opt.x\n\n    ws, vs = zip(*[s.diagonalise_matrix(f) for s, f in zip(se, fock)])\n    chempot = search_chempot(ws, vs, se[0].nphys, nelec, occupancy=occupancy)[0]\n\n    for s in se:\n        s.chempot = chempot\n\n    return se, opt\n</code></pre>"},{"location":"reference/pbc/fsgw/","title":"Fsgw","text":"<p>Spin-restricted Fock matrix self-consistent GW via self-energy moment constraints for periodic systems.</p>"},{"location":"reference/pbc/fsgw/#momentGW.pbc.fsgw.fsKGW","title":"<code>momentGW.pbc.fsgw.fsKGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>KGW</code>, <code>fsGW</code></p> <p>Spin-restricted Fock matrix self-consistent GW via self-energy moment constraints for periodic systems.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>KSCF</code> <p>PySCF periodic mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>fc</code> <code>bool</code> <p>If <code>True</code>, apply finite size corrections. Default value is <code>False</code>.</p> required <code>max_cycle</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>50</code>.</p> required <code>conv_tol</code> <code>float</code> <p>Convergence threshold in the change in the HOMO and LUMO. Default value is <code>1e-8</code>.</p> required <code>conv_tol_moms</code> <code>float</code> <p>Convergence threshold in the change in the moments. Default value is <code>1e-8</code>.</p> required <code>conv_logical</code> <code>callable</code> <p>Function that takes an iterable of booleans as input indicating whether the individual <code>conv_tol</code>, <code>conv_tol_moms</code> have been satisfied, respectively, and returns a boolean indicating overall convergence. For example, the function <code>all</code> requires both metrics to be met, and <code>any</code> requires just one. Default value is <code>all</code>.</p> required <code>diis_space</code> <code>int</code> <p>Size of the DIIS extrapolation space. Default value is <code>8</code>.</p> required <code>damping</code> <code>float</code> <p>Damping parameter. Default value is <code>0.0</code>.</p> required <code>solver</code> <code>BaseGW</code> <p>Solver to use to obtain the self-energy. Compatible with any <code>BaseGW</code>-like class. Default value is <code>momentGW.gw.GW</code>.</p> required <code>solver_options</code> <code>dict</code> <p>Keyword arguments to pass to the solver. Default value is an empty <code>dict</code>.</p> required Source code in <code>momentGW/pbc/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Options\n    self.fc = False\n\n    # Attributes\n    self._kpts = KPoints(self.cell, getattr(mf, \"kpts\", np.zeros((1, 3))))\n</code></pre>"},{"location":"reference/pbc/fsgw/#momentGW.pbc.fsgw.fsKGW.name","title":"<code>momentGW.pbc.fsgw.fsKGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/pbc/gw/","title":"Gw","text":"<p>Spin-restricted one-shot GW via self-energy moment constraints for periodic systems.</p>"},{"location":"reference/pbc/gw/#momentGW.pbc.gw.KGW","title":"<code>momentGW.pbc.gw.KGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>BaseKGW</code>, <code>GW</code></p> <p>Spin-restricted one-shot GW via self-energy moment constraints for periodic systems.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>KSCF</code> <p>PySCF periodic mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.pbc.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>fc</code> <code>bool</code> <p>If <code>True</code>, apply finite size corrections. Default value is <code>False</code>.</p> required Source code in <code>momentGW/pbc/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Options\n    self.fc = False\n\n    # Attributes\n    self._kpts = KPoints(self.cell, getattr(mf, \"kpts\", np.zeros((1, 3))))\n</code></pre>"},{"location":"reference/pbc/gw/#momentGW.pbc.gw.KGW.name","title":"<code>momentGW.pbc.gw.KGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/pbc/gw/#momentGW.pbc.gw.KGW.build_se_static","title":"<code>momentGW.pbc.gw.KGW.build_se_static(integrals)</code>","text":"<p>Build the static part of the self-energy, including the Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>integrals</code> <code>KIntegrals</code> <p>Integrals object.</p> required <p>Returns:</p> Name Type Description <code>se_static</code> <code>ndarray</code> <p>Static part of the self-energy at each k-point. If <code>self.diagonal_se</code>, non-diagonal elements are set to zero.</p> Source code in <code>momentGW/pbc/gw.py</code> <pre><code>@logging.with_timer(\"Static self-energy\")\n@logging.with_status(\"Building static self-energy\")\ndef build_se_static(self, integrals):\n    \"\"\"\n    Build the static part of the self-energy, including the Fock\n    matrix.\n\n    Parameters\n    ----------\n    integrals : KIntegrals\n        Integrals object.\n\n    Returns\n    -------\n    se_static : numpy.ndarray\n        Static part of the self-energy at each k-point. If\n        `self.diagonal_se`, non-diagonal elements are set to zero.\n    \"\"\"\n    return super().build_se_static(integrals)\n</code></pre>"},{"location":"reference/pbc/gw/#momentGW.pbc.gw.KGW.build_se_moments","title":"<code>momentGW.pbc.gw.KGW.build_se_moments(nmom_max, integrals, **kwargs)</code>","text":"<p>Build the moments of the self-energy.</p> <p>Parameters:</p> Name Type Description Default <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>integrals</code> <code>KIntegrals</code> <p>Density-fitted integrals.</p> required <code>See</code> required <p>Returns:</p> Name Type Description <code>se_moments_hole</code> <code>ndarray</code> <p>Moments of the hole self-energy at each k-point. If <code>self.diagonal_se</code>, non-diagonal elements are set to zero.</p> <code>se_moments_part</code> <code>ndarray</code> <p>Moments of the particle self-energy at each k-point. If <code>self.diagonal_se</code>, non-diagonal elements are set to zero.</p> Source code in <code>momentGW/pbc/gw.py</code> <pre><code>def build_se_moments(self, nmom_max, integrals, **kwargs):\n    \"\"\"Build the moments of the self-energy.\n\n    Parameters\n    ----------\n    nmom_max : int\n        Maximum moment number to calculate.\n    integrals : KIntegrals\n        Density-fitted integrals.\n\n    See functions in `momentGW.rpa` for `kwargs` options.\n\n    Returns\n    -------\n    se_moments_hole : numpy.ndarray\n        Moments of the hole self-energy at each k-point. If\n        `self.diagonal_se`, non-diagonal elements are set to zero.\n    se_moments_part : numpy.ndarray\n        Moments of the particle self-energy at each k-point. If\n        `self.diagonal_se`, non-diagonal elements are set to zero.\n    \"\"\"\n\n    if self.polarizability.lower() == \"dtda\":\n        tda = dTDA(self, nmom_max, integrals, **kwargs)\n        return tda.kernel()\n    if self.polarizability.lower() == \"drpa\":\n        rpa = dRPA(self, nmom_max, integrals, **kwargs)\n        return rpa.kernel()\n    elif self.polarizability.lower() == \"thc-dtda\":\n        tda = thc.dTDA(self, nmom_max, integrals, **kwargs)\n        return tda.kernel()\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pbc/gw/#momentGW.pbc.gw.KGW.ao2mo","title":"<code>momentGW.pbc.gw.KGW.ao2mo(transform=True)</code>","text":"<p>Get the integrals object.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <code>bool</code> <p>Whether to transform the integrals object.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>integrals</code> <code>KIntegrals</code> <p>Integrals object.</p> See Also <p>momentGW.pbc.ints.KIntegrals momentGW.pbc.thc.KIntegrals</p> Source code in <code>momentGW/pbc/gw.py</code> <pre><code>@logging.with_timer(\"Integral construction\")\n@logging.with_status(\"Constructing integrals\")\ndef ao2mo(self, transform=True):\n    \"\"\"Get the integrals object.\n\n    Parameters\n    ----------\n    transform : bool, optional\n        Whether to transform the integrals object.\n\n    Returns\n    -------\n    integrals : KIntegrals\n        Integrals object.\n\n    See Also\n    --------\n    momentGW.pbc.ints.KIntegrals\n    momentGW.pbc.thc.KIntegrals\n    \"\"\"\n\n    # Get the integrals class\n    if self.polarizability.lower().startswith(\"thc\"):\n        cls = thc.KIntegrals\n        kwargs = self.thc_opts\n    else:\n        cls = KIntegrals\n        kwargs = dict(\n            compression=self.compression,\n            compression_tol=self.compression_tol,\n            store_full=self.fock_loop,\n            input_path=self.thc_opts[\"file_path\"],\n        )\n\n    # Get the integrals\n    integrals = cls(\n        self.with_df,\n        self.kpts,\n        self.mo_coeff,\n        self.mo_occ,\n        **kwargs,\n    )\n\n    # Transform the integrals\n    if transform:\n        if \"input_path\" in kwargs and kwargs[\"input_path\"] is not None:\n            integrals.get_cderi_from_thc()\n        else:\n            integrals.transform()\n\n    return integrals\n</code></pre>"},{"location":"reference/pbc/gw/#momentGW.pbc.gw.KGW.solve_dyson","title":"<code>momentGW.pbc.gw.KGW.solve_dyson(se_moments_hole, se_moments_part, se_static, integrals=None)</code>","text":"<p>Solve the Dyson equation due to a self-energy resulting from a list of hole and particle moments, along with a static contribution.</p> <p>Also finds a chemical potential best satisfying the physical number of electrons. If <code>self.optimise_chempot</code>, this will shift the self-energy poles relative to the Green's function, which is a partial self-consistency that better conserves the particle number.</p> <p>If <code>self.fock_loop</code>, this function will also require that the outputted Green's function is self-consistent with respect to the corresponding density and Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>se_moments_hole</code> <code>ndarray</code> <p>Moments of the hole self-energy at each k-point.</p> required <code>se_moments_part</code> <code>ndarray</code> <p>Moments of the particle self-energy at each k-point.</p> required <code>se_static</code> <code>ndarray</code> <p>Static part of the self-energy at each k-point.</p> required <code>integrals</code> <code>KIntegrals</code> <p>Density-fitted integrals. Required if <code>self.fock_loop</code> is <code>True</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function at each k-point.</p> <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy at each k-point.</p> See Also <p>momentGW.pbc.fock.FockLoop</p> Source code in <code>momentGW/pbc/gw.py</code> <pre><code>def solve_dyson(self, se_moments_hole, se_moments_part, se_static, integrals=None):\n    \"\"\"Solve the Dyson equation due to a self-energy resulting\n    from a list of hole and particle moments, along with a static\n    contribution.\n\n    Also finds a chemical potential best satisfying the physical\n    number of electrons. If `self.optimise_chempot`, this will\n    shift the self-energy poles relative to the Green's function,\n    which is a partial self-consistency that better conserves the\n    particle number.\n\n    If `self.fock_loop`, this function will also require that the\n    outputted Green's function is self-consistent with respect to\n    the corresponding density and Fock matrix.\n\n    Parameters\n    ----------\n    se_moments_hole : numpy.ndarray\n        Moments of the hole self-energy at each k-point.\n    se_moments_part : numpy.ndarray\n        Moments of the particle self-energy at each k-point.\n    se_static : numpy.ndarray\n        Static part of the self-energy at each k-point.\n    integrals : KIntegrals, optional\n        Density-fitted integrals. Required if `self.fock_loop`\n        is `True`. Default value is `None`.\n\n    Returns\n    -------\n    gf : tuple of dyson.Lehmann\n        Green's function at each k-point.\n    se : tuple of dyson.Lehmann\n        Self-energy at each k-point.\n\n    See Also\n    --------\n    momentGW.pbc.fock.FockLoop\n    \"\"\"\n\n    # Solve the Dyson equation for the moments\n    with logging.with_modifiers(status=\"Solving Dyson equation\", timer=\"Dyson equation\"):\n        se = []\n        for k in self.kpts.loop(1):\n            solver_occ = MBLSE(se_static[k], np.array(se_moments_hole[k]))\n            solver_occ.kernel()\n\n            solver_vir = MBLSE(se_static[k], np.array(se_moments_part[k]))\n            solver_vir.kernel()\n\n            solver = MixedMBLSE(solver_occ, solver_vir)\n            se.append(solver.get_self_energy())\n\n    # Initialise the solver\n    solver = FockLoop(self, se=se, **self.fock_opts)\n\n    # Shift the self-energy poles relative to the Green's function\n    # to better conserve the particle number\n    if self.optimise_chempot:\n        se = solver.auxiliary_shift(se_static)\n\n    # Find the error in the moments\n    error_h, error_p = zip(\n        *(\n            self.moment_error(th, tp, s)\n            for th, tp, s in zip(se_moments_hole, se_moments_part, se)\n        )\n    )\n    error = (sum(error_h), sum(error_p))\n    logging.write(\n        f\"Error in moments:  [{logging.rate(sum(error), 1e-12, 1e-8)}]{sum(error):.3e}[/] \"\n        f\"(hole = [{logging.rate(error[0], 1e-12, 1e-8)}]{error[0]:.3e}[/], \"\n        f\"particle = [{logging.rate(error[1], 1e-12, 1e-8)}]{error[1]:.3e}[/])\"\n    )\n\n    # Solve the Dyson equation for the self-energy\n    gf, error = solver.solve_dyson(se_static)\n    for g, s in zip(gf, se):\n        s.chempot = g.chempot\n\n    # Self-consistently renormalise the density matrix\n    if self.fock_loop:\n        logging.write(\"\")\n        solver.gf = gf\n        solver.se = se\n        conv, gf, se = solver.kernel(integrals=integrals)\n        _, error = solver.search_chempot(gf)\n\n    # Print the error in the number of electrons\n    logging.write(\"\")\n    style = logging.rate(\n        error,\n        1e-6,\n        1e-6 if self.fock_loop or self.optimise_chempot else 1e-1,\n    )\n    logging.write(f\"Error in number of electrons:  [{style}]{error:.3e}[/]\")\n    logging.write(f\"Chemical potential (\u0393):  {gf[0].chempot:.6f}\")\n\n    return tuple(gf), tuple(se)\n</code></pre>"},{"location":"reference/pbc/gw/#momentGW.pbc.gw.KGW.kernel","title":"<code>momentGW.pbc.gw.KGW.kernel(nmom_max, moments=None, integrals=None)</code>","text":"<p>Driver for the method.</p> <p>Parameters:</p> Name Type Description Default <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>moments</code> <code>tuple of numpy.ndarray</code> <p>Tuple of (hole, particle) moments at each k-point, if passed then they will be used instead of calculating them. Default value is <code>None</code>.</p> <code>None</code> <code>integrals</code> <code>KIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>converged</code> <code>bool</code> <p>Whether the solver converged. For single-shot calculations, this is always <code>True</code>.</p> <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function object at each k-point.</p> <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy object at each k-point.</p> <code>qp_energy</code> <code>NoneType</code> <p>Quasiparticle energies. For most GW methods, this is <code>None</code>.</p> Source code in <code>momentGW/pbc/gw.py</code> <pre><code>def kernel(\n    self,\n    nmom_max,\n    moments=None,\n    integrals=None,\n):\n    \"\"\"Driver for the method.\n\n    Parameters\n    ----------\n    nmom_max : int\n        Maximum moment number to calculate.\n    moments : tuple of numpy.ndarray, optional\n        Tuple of (hole, particle) moments at each k-point, if passed\n        then they will be used instead of calculating them. Default\n        value is `None`.\n    integrals : KIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    converged : bool\n        Whether the solver converged. For single-shot calculations,\n        this is always `True`.\n    gf : tuple of dyson.Lehmann\n        Green's function object at each k-point.\n    se : tuple of dyson.Lehmann\n        Self-energy object at each k-point.\n    qp_energy : NoneType\n        Quasiparticle energies. For most GW methods, this is `None`.\n    \"\"\"\n    return super().kernel(nmom_max, moments=moments, integrals=integrals)\n</code></pre>"},{"location":"reference/pbc/gw/#momentGW.pbc.gw.KGW.make_rdm1","title":"<code>momentGW.pbc.gw.KGW.make_rdm1(gf=None)</code>","text":"<p>Get the first-order reduced density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function at each k-point. If <code>None</code>, use either <code>self.gf</code>, or the mean-field Green's function. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>rdm1</code> <code>ndarray</code> <p>First-order reduced density matrix at each k-point.</p> Source code in <code>momentGW/pbc/gw.py</code> <pre><code>def make_rdm1(self, gf=None):\n    \"\"\"Get the first-order reduced density matrix.\n\n    Parameters\n    ----------\n    gf : tuple of dyson.Lehmann, optional\n        Green's function at each k-point. If `None`, use either\n        `self.gf`, or the mean-field Green's function. Default\n        value is `None`.\n\n    Returns\n    -------\n    rdm1 : numpy.ndarray\n        First-order reduced density matrix at each k-point.\n    \"\"\"\n\n    # Get the Green's function\n    if gf is None:\n        gf = self.gf\n    if gf is None:\n        gf = self.init_gf()\n\n    return np.array([g.occupied().moment(0) for g in gf]) * 2\n</code></pre>"},{"location":"reference/pbc/gw/#momentGW.pbc.gw.KGW.energy_hf","title":"<code>momentGW.pbc.gw.KGW.energy_hf(gf=None, integrals=None)</code>","text":"<p>Calculate the one-body (Hartree--Fock) energy.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function at each k-point. If <code>None</code>, use either <code>self.gf</code>, or the mean-field Green's function. Default value is <code>None</code>.</p> <code>None</code> <code>integrals</code> <code>KIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>e_1b</code> <code>float</code> <p>One-body energy.</p> Source code in <code>momentGW/pbc/gw.py</code> <pre><code>@logging.with_timer(\"Energy\")\n@logging.with_status(\"Calculating energy\")\ndef energy_hf(self, gf=None, integrals=None):\n    \"\"\"Calculate the one-body (Hartree--Fock) energy.\n\n    Parameters\n    ----------\n    gf : tuple of dyson.Lehmann, optional\n        Green's function at each k-point. If `None`, use either\n        `self.gf`, or the mean-field Green's function. Default\n        value is `None`.\n    integrals : KIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    e_1b : float\n        One-body energy.\n    \"\"\"\n\n    # Get the Green's function\n    if gf is None:\n        gf = self.gf\n\n    # Get the integrals\n    if integrals is None:\n        integrals = self.ao2mo()\n\n    # Find the Fock matrix\n    with util.SilentSCF(self._scf):\n        h1e = util.einsum(\n            \"kpq,kpi,kqj-&gt;kij\", self._scf.get_hcore(), self.mo_coeff.conj(), self.mo_coeff\n        )\n    rdm1 = self.make_rdm1()\n    fock = integrals.get_fock(rdm1, h1e)\n\n    # Calculate the Hartree--Fock energy at each k-point\n    e_1b = sum(energy.hartree_fock(rdm1[k], fock[k], h1e[k]) for k in self.kpts.loop(1))\n    e_1b /= self.nkpts\n\n    return e_1b.real\n</code></pre>"},{"location":"reference/pbc/gw/#momentGW.pbc.gw.KGW.energy_gm","title":"<code>momentGW.pbc.gw.KGW.energy_gm(gf=None, se=None, g0=True)</code>","text":"<p>Calculate the two-body (Galitskii--Migdal) energy.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>tuple of tuple of dyson.Lehmann</code> <p>Green's function at each k-point for each spin channel. If <code>None</code>, use <code>self.gf</code>. Default value is <code>None</code>.</p> <code>None</code> <code>se</code> <code>tuple of tuple of dyson.Lehmann</code> <p>Self-energy at each k-point for each spin channel. If <code>None</code>, use <code>self.se</code>. Default value is <code>None</code>.</p> <code>None</code> <code>g0</code> <code>bool</code> <p>If <code>True</code>, use the mean-field Green's function. Default value is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>e_2b</code> <code>float</code> <p>Two-body energy.</p> Source code in <code>momentGW/pbc/gw.py</code> <pre><code>@logging.with_timer(\"Energy\")\n@logging.with_status(\"Calculating energy\")\ndef energy_gm(self, gf=None, se=None, g0=True):\n    r\"\"\"Calculate the two-body (Galitskii--Migdal) energy.\n\n    Parameters\n    ----------\n    gf : tuple of tuple of dyson.Lehmann, optional\n        Green's function at each k-point for each spin channel. If\n        `None`, use `self.gf`. Default value is `None`.\n    se : tuple of tuple of dyson.Lehmann, optional\n        Self-energy at each k-point for each spin channel. If\n        `None`, use `self.se`. Default value is `None`.\n    g0 : bool, optional\n        If `True`, use the mean-field Green's function. Default\n        value is `True`.\n\n    Returns\n    -------\n    e_2b : float\n        Two-body energy.\n    \"\"\"\n\n    # Get the Green's function and self-energy\n    if gf is None:\n        gf = self.gf\n    if se is None:\n        se = self.se\n\n    # Calculate the Galitskii--Migdal energy\n    if g0:\n        e_2b = sum(\n            energy.galitskii_migdal_g0(self.mo_energy[k], self.mo_occ[k], se[k])\n            for k in self.kpts.loop(1)\n        )\n    else:\n        e_2b = sum(energy.galitskii_migdal(gf[k], se[k]) for k in self.kpts.loop(1))\n\n    return e_2b.real\n</code></pre>"},{"location":"reference/pbc/gw/#momentGW.pbc.gw.KGW.interpolate","title":"<code>momentGW.pbc.gw.KGW.interpolate(mf, nmom_max)</code>","text":"<p>Interpolate the object to a new k-point grid, represented by a new mean-field object.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>KSCF</code> <p>Mean-field object on new k-point mesh.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <p>Returns:</p> Name Type Description <code>other</code> <code>__class__</code> <p>Interpolated object.</p> Source code in <code>momentGW/pbc/gw.py</code> <pre><code>@logging.with_timer(\"Interpolation\")\n@logging.with_status(\"Interpolating in k-space\")\ndef interpolate(self, mf, nmom_max):\n    \"\"\"\n    Interpolate the object to a new k-point grid, represented by a\n    new mean-field object.\n\n    Parameters\n    ----------\n    mf : pyscf.pbc.scf.KSCF\n        Mean-field object on new k-point mesh.\n    nmom_max : int\n        Maximum moment number to calculate.\n\n    Returns\n    -------\n    other : __class__\n        Interpolated object.\n    \"\"\"\n\n    if len(mf.kpts) % len(self.kpts) != 0:\n        raise ValueError(\"Size of interpolation grid must be a multiple of the old grid.\")\n\n    other = self.__class__(mf)\n    other.__dict__.update({key: getattr(self, key) for key in self._opts})\n    sc = util.einsum(\"kpq,kqi-&gt;kpi\", mf.get_ovlp(), mf.mo_coeff)\n\n    def interp(m):\n        # Interpolate part of the moments via the AO basis\n        m = util.einsum(\"knij,kpi,kqj-&gt;knpq\", m, self.mo_coeff, self.mo_coeff.conj())\n        m = np.stack(\n            [self.kpts.interpolate(other.kpts, m[:, n]) for n in range(nmom_max + 1)],\n            axis=1,\n        )\n        m = util.einsum(\"knpq,kpi,kqj-&gt;knij\", m, sc.conj(), sc)\n        return m\n\n    # Get the moments of the self-energy on the small k-point grid\n    th = np.array([se.occupied().moment(range(nmom_max + 1)) for se in self.se])\n    tp = np.array([se.virtual().moment(range(nmom_max + 1)) for se in self.se])\n\n    # Interpolate the moments\n    th = interp(th)\n    tp = interp(tp)\n\n    # Get the static self-energy on the fine k-point grid\n    integrals = other.ao2mo(transform=False)\n    se_static = other.build_se_static(integrals)\n\n    # Solve the Dyson equation on the fine k-point grid\n    gf, se = other.solve_dyson(th, tp, se_static, integrals=integrals)\n\n    # Set attributes\n    # TODO handle _qp_energy if not None\n    other.gf = gf\n    other.se = se\n\n    return other\n</code></pre>"},{"location":"reference/pbc/gw/#momentGW.pbc.gw.KGW.init_gf","title":"<code>momentGW.pbc.gw.KGW.init_gf(mo_energy=None)</code>","text":"<p>Initialise the mean-field Green's function.</p> <p>Parameters:</p> Name Type Description Default <code>mo_energy</code> <code>ndarray</code> <p>Molecular orbital energies at each k-point. Default value is <code>self.mo_energy</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Mean-field Green's function at each k-point.</p> Source code in <code>momentGW/pbc/gw.py</code> <pre><code>def init_gf(self, mo_energy=None):\n    \"\"\"Initialise the mean-field Green's function.\n\n    Parameters\n    ----------\n    mo_energy : numpy.ndarray, optional\n        Molecular orbital energies at each k-point. Default value is\n        `self.mo_energy`.\n\n    Returns\n    -------\n    gf : tuple of dyson.Lehmann\n        Mean-field Green's function at each k-point.\n    \"\"\"\n\n    if mo_energy is None:\n        mo_energy = self.mo_energy\n\n    gf = []\n    for k in self.kpts.loop(1):\n        gf.append(Lehmann(mo_energy[k], np.eye(self.nmo)))\n\n    ws = [g.energies for g in gf]\n    vs = [g.couplings for g in gf]\n    nelec = [n * 2 for n in self.nocc]\n    chempot = search_chempot_unconstrained(ws, vs, self.nmo, sum(nelec))[0]\n\n    for k in self.kpts.loop(1):\n        gf[k].chempot = chempot\n\n    return tuple(gf)\n</code></pre>"},{"location":"reference/pbc/ints/","title":"Ints","text":"<p>Integral helpers with periodic boundary conditions.</p>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals","title":"<code>momentGW.pbc.ints.KIntegrals(with_df, kpts, mo_coeff, mo_occ, compression='ia', compression_tol=1e-10, store_full=False, input_path=None)</code>","text":"<p>             Bases: <code>Integrals</code></p> <p>Container for the integrals required for KGW methods.</p> <p>Parameters:</p> Name Type Description Default <code>with_df</code> <code>DF</code> <p>Density fitting object.</p> required <code>mo_coeff</code> <code>ndarray</code> <p>Molecular orbital coefficients at each k-point.</p> required <code>mo_occ</code> <code>ndarray</code> <p>Molecular orbital occupations at each k-point.</p> required <code>compression</code> <code>str</code> <p>Compression scheme to use. Default value is <code>'ia'</code>. See <code>momentGW.gw</code> for more details.</p> <code>'ia'</code> <code>compression_tol</code> <code>float</code> <p>Compression tolerance. Default value is <code>1e-10</code>. See <code>momentGW.gw</code> for more details.</p> <code>1e-10</code> <code>store_full</code> <code>bool</code> <p>Store the full MO integrals in memory. Default value is <code>False</code>.</p> <code>False</code> Source code in <code>momentGW/pbc/ints.py</code> <pre><code>def __init__(\n    self,\n    with_df,\n    kpts,\n    mo_coeff,\n    mo_occ,\n    compression=\"ia\",\n    compression_tol=1e-10,\n    store_full=False,\n    input_path=None,\n):\n    Integrals.__init__(\n        self,\n        with_df,\n        mo_coeff,\n        mo_occ,\n        compression=compression,\n        compression_tol=compression_tol,\n        store_full=store_full,\n    )\n\n    # Options\n    self.input_path = input_path\n\n    # Attributes\n    self.kpts = kpts\n    self._madelung = None\n    self._naux_full = None\n    self._naux = None\n</code></pre>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.madelung","title":"<code>momentGW.pbc.ints.KIntegrals.madelung</code>  <code>property</code>","text":"<p>Return the Madelung constant for the lattice.</p>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.Lai","title":"<code>momentGW.pbc.ints.KIntegrals.Lai</code>  <code>property</code>","text":"<p>Get the full uncompressed <code>(aux, MO, MO)</code> integrals.</p>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.nmo","title":"<code>momentGW.pbc.ints.KIntegrals.nmo</code>  <code>property</code>","text":"<p>Get the number of MOs.</p>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.nocc","title":"<code>momentGW.pbc.ints.KIntegrals.nocc</code>  <code>property</code>","text":"<p>Get the number of occupied MOs.</p>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.nvir","title":"<code>momentGW.pbc.ints.KIntegrals.nvir</code>  <code>property</code>","text":"<p>Get the number of virtual MOs.</p>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.nmo_g","title":"<code>momentGW.pbc.ints.KIntegrals.nmo_g</code>  <code>property</code>","text":"<p>Get the number of MOs for the Green's function.</p>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.nmo_w","title":"<code>momentGW.pbc.ints.KIntegrals.nmo_w</code>  <code>property</code>","text":"<p>Get the number of MOs for the screened Coulomb interaction.</p>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.nocc_w","title":"<code>momentGW.pbc.ints.KIntegrals.nocc_w</code>  <code>property</code>","text":"<p>Get the number of occupied MOs for the screened Coulomb interaction.</p>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.nvir_w","title":"<code>momentGW.pbc.ints.KIntegrals.nvir_w</code>  <code>property</code>","text":"<p>Get the number of virtual MOs for the screened Coulomb interaction.</p>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.naux","title":"<code>momentGW.pbc.ints.KIntegrals.naux</code>  <code>property</code>","text":"<p>Get the number of auxiliary basis functions, after the compression.</p>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.naux_full","title":"<code>momentGW.pbc.ints.KIntegrals.naux_full</code>  <code>property</code>","text":"<p>Get the number of auxiliary basis functions, before the compression.</p>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.get_compression_metric","title":"<code>momentGW.pbc.ints.KIntegrals.get_compression_metric()</code>","text":"<p>Return the compression metric.</p> <p>Returns:</p> Name Type Description <code>rot</code> <code>ndarray</code> <p>Rotation matrix into the compressed auxiliary space.</p> Source code in <code>momentGW/pbc/ints.py</code> <pre><code>@logging.with_status(\"Computing compression metric\")\ndef get_compression_metric(self):\n    \"\"\"\n    Return the compression metric.\n\n    Returns\n    -------\n    rot : numpy.ndarray\n        Rotation matrix into the compressed auxiliary space.\n    \"\"\"\n\n    # TODO MPI\n\n    # Get the compression sectors\n    compression = self._parse_compression()\n    if not compression:\n        return None\n\n    # Initialise the inner product matrix\n    prod = np.zeros((len(self.kpts)), dtype=object)\n\n    # ao2mo function for both real and complex integrals\n    tao = np.empty([], dtype=np.int32)\n    ao_loc = self.with_df.cell.ao_loc_nr()\n\n    def _ao2mo_e2(Lpq, mo_coeff, orb_slice, out=None):\n        mo_coeff = np.asarray(mo_coeff, order=\"F\")\n        if np.iscomplexobj(Lpq):\n            out = _ao2mo.r_e2(Lpq, mo_coeff, orb_slice, tao, ao_loc, aosym=\"s1\", out=out)\n        else:\n            out = _ao2mo.nr_e2(Lpq, mo_coeff, orb_slice, aosym=\"s1\", mosym=\"s1\")\n        return out\n\n    # Loop over required blocks\n    for key in sorted(compression):\n        with logging.with_status(f\"{key} sector\"):\n            # Get the coefficients\n            ci, cj = [\n                {\n                    \"o\": [c[:, o &gt; 0] for c, o in zip(self.mo_coeff, self.mo_occ)],\n                    \"v\": [c[:, o == 0] for c, o in zip(self.mo_coeff, self.mo_occ)],\n                    \"i\": [c[:, o &gt; 0] for c, o in zip(self.mo_coeff_w, self.mo_occ_w)],\n                    \"a\": [c[:, o == 0] for c, o in zip(self.mo_coeff_w, self.mo_occ_w)],\n                }[k]\n                for k in key\n            ]\n            ni = [c.shape[-1] for c in ci]\n            nj = [c.shape[-1] for c in cj]\n\n            for q, ki in self.kpts.loop(2):\n                kj = self.kpts.member(self.kpts.wrap_around(self.kpts[ki] - self.kpts[q]))\n\n                # Build the (L|xy) array\n                Lxy = np.zeros((self.naux_full[q], ni[ki] * nj[kj]), dtype=complex)\n                b1 = 0\n                for block in self.with_df.sr_loop((ki, kj), compact=False):\n                    if block[2] == -1:\n                        raise NotImplementedError(\"Low dimensional integrals\")\n                    block = block[0] + block[1] * 1.0j\n                    block = block.reshape(block.shape[0], self.nao, self.nao)\n                    b0, b1 = b1, b1 + block.shape[0]\n                    progress = ki * len(self.kpts) ** 2 + kj * len(self.kpts) + b0\n                    progress /= len(self.kpts) ** 2 + block.shape[0]\n\n                    with logging.with_status(f\"block [{ki}, {kj}, {b0}:{b1}] ({progress:.1%})\"):\n                        coeffs = np.concatenate((ci[ki], cj[kj]), axis=1)\n                        orb_slice = (0, ni[ki], ni[ki], ni[ki] + nj[kj])\n                        _ao2mo_e2(block, coeffs, orb_slice, out=Lxy[b0:b1])\n\n                # Update the inner product matrix\n                prod[q] += np.dot(Lxy, Lxy.T.conj()) / len(self.kpts)\n\n    # Diagonalise the inner product matrix\n    rot = np.empty((len(self.kpts),), dtype=object)\n    if mpi_helper.rank == 0:\n        for q in self.kpts.loop(1):\n            e, v = np.linalg.eigh(prod[q])\n            mask = np.abs(e) &gt; self.compression_tol\n            rot[q] = v[:, mask]\n    else:\n        for q in self.kpts.loop(1):\n            rot[q] = np.zeros((0,), dtype=complex)\n    del prod\n\n    # Print the compression status\n    naux_total = sum(r.shape[-1] for r in rot)\n    if naux_total == np.sum(self.naux_full):\n        logging.write(\"No compression found for auxiliary space\")\n        rot = None\n    else:\n        percent = 100 * naux_total / np.sum(self.naux_full)\n        style = logging.rate(percent, 80, 95)\n        logging.write(\n            f\"Compressed auxiliary space from {np.sum(self.naux_full)} to {naux_total} \"\n            f\"([{style}]{percent:.1f}%)[/]\"\n        )\n\n    return rot\n</code></pre>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.transform","title":"<code>momentGW.pbc.ints.KIntegrals.transform(do_Lpq=None, do_Lpx=True, do_Lia=True)</code>","text":"<p>Transform the integrals in-place.</p> <p>Parameters:</p> Name Type Description Default <code>do_Lpq</code> <code>bool</code> <p>Whether to compute the full <code>(aux, MO, MO)</code> array. Default value is <code>True</code> if <code>store_full</code> is <code>True</code>, <code>False</code> otherwise.</p> <code>None</code> <code>do_Lpx</code> <code>bool</code> <p>Whether to compute the compressed <code>(aux, MO, MO)</code> array. Default value is <code>True</code>.</p> <code>True</code> <code>do_Lia</code> <code>bool</code> <p>Whether to compute the compressed <code>(aux, occ, vir)</code> array. Default value is <code>True</code>.</p> <code>True</code> Source code in <code>momentGW/pbc/ints.py</code> <pre><code>@require_compression_metric()\n@logging.with_status(\"Transforming integrals\")\ndef transform(self, do_Lpq=None, do_Lpx=True, do_Lia=True):\n    \"\"\"\n    Transform the integrals in-place.\n\n    Parameters\n    ----------\n    do_Lpq : bool, optional\n        Whether to compute the full ``(aux, MO, MO)`` array. Default\n        value is `True` if `store_full` is `True`, `False`\n        otherwise.\n    do_Lpx : bool, optional\n        Whether to compute the compressed ``(aux, MO, MO)`` array.\n        Default value is `True`.\n    do_Lia : bool, optional\n        Whether to compute the compressed ``(aux, occ, vir)`` array.\n        Default value is `True`.\n    \"\"\"\n\n    # Get the compression metric\n    rot = self._rot\n    if rot is None:\n        rot = np.zeros(len(self.kpts), dtype=object)\n        for q in self.kpts.loop(1):\n            rot[q] = np.eye(self.naux[q])\n\n    # Check which arrays to build\n    do_Lpq = self.store_full if do_Lpq is None else do_Lpq\n    if not any([do_Lpq, do_Lpx, do_Lia]):\n        return\n\n    # ao2mo function for both real and complex integrals\n    tao = np.empty([], dtype=np.int32)\n\n    def _ao2mo_e2(Lpq, mo_coeff, orb_slice, out=None):\n        mo_coeff = np.asarray(mo_coeff, order=\"F\")\n        if np.iscomplexobj(Lpq):\n            out = _ao2mo.r_e2(Lpq, mo_coeff, orb_slice, tao, ao_loc=None, aosym=\"s1\", out=out)\n        else:\n            out = _ao2mo.nr_e2(Lpq, mo_coeff, orb_slice, aosym=\"s1\", mosym=\"s1\")\n        return out\n\n    # Prepare the outputs\n    Lpq = {}\n    Lpx = {}\n    Lia = {}\n    Lai = {}\n\n    for q in self.kpts.loop(1):\n        for ki in self.kpts.loop(1, mpi=True):\n            kj = self.kpts.member(self.kpts.wrap_around(self.kpts[q] + self.kpts[ki]))\n\n            # Get the slices on the current process and initialise\n            # the arrays\n            Lpq_k = (\n                np.zeros((self.naux_full[q], self.nmo, self.nmo), dtype=complex)\n                if do_Lpq\n                else None\n            )\n            Lpx_k = (\n                np.zeros((self.naux[q], self.nmo, self.nmo_g[kj]), dtype=complex)\n                if do_Lpx\n                else None\n            )\n            Lia_k = (\n                np.zeros((self.naux[q], self.nocc_w[ki] * self.nvir_w[kj]), dtype=complex)\n                if do_Lia\n                else None\n            )\n            Lai_k = (\n                np.zeros((self.naux[q], self.nocc_w[ki] * self.nvir_w[kj]), dtype=complex)\n                if do_Lia\n                else None\n            )\n\n            # Build the integrals blockwise\n            b1 = 0\n            for block in self.with_df.sr_loop((ki, kj), compact=False):  # TODO lock I/O\n                if block[2] == -1:\n                    raise NotImplementedError(\"Low dimensional integrals\")\n                block = block[0] + block[1] * 1.0j\n                b0, b1 = b1, b1 + block.shape[0]\n                progress = ki * len(self.kpts) ** 2 + kj * len(self.kpts) + b0\n                progress /= len(self.kpts) ** 2 + self.naux[q]\n\n                with logging.with_status(f\"block [{ki}, {kj}, {b0}:{b1}] ({progress:.1%})\"):\n                    # If needed, rotate the full (L|pq) array\n                    if do_Lpq:\n                        coeffs = np.concatenate((self.mo_coeff[ki], self.mo_coeff[kj]), axis=1)\n                        orb_slice = (0, self.nmo, self.nmo, self.nmo + self.nmo)\n                        _ao2mo_e2(block, coeffs, orb_slice, out=Lpq_k[b0:b1])\n\n                    # Compress the block\n                    block_comp = util.einsum(\"L...,LQ-&gt;Q...\", block, rot[q][b0:b1].conj())\n\n                    # Build the compressed (L|px) array\n                    if do_Lpx:\n                        coeffs = np.concatenate(\n                            (self.mo_coeff[ki], self.mo_coeff_g[kj]), axis=1\n                        )\n                        orb_slice = (0, self.nmo, self.nmo, self.nmo + self.nmo_g[kj])\n                        tmp = _ao2mo_e2(block_comp, coeffs, orb_slice)\n                        Lpx_k += tmp.reshape(Lpx_k.shape)\n\n                    # Build the compressed (L|ia) array\n                    if do_Lia:\n                        coeffs = np.concatenate(\n                            (\n                                self.mo_coeff_w[ki][:, self.mo_occ_w[ki] &gt; 0],\n                                self.mo_coeff_w[kj][:, self.mo_occ_w[kj] == 0],\n                            ),\n                            axis=1,\n                        )\n                        orb_slice = (\n                            0,\n                            self.nocc_w[ki],\n                            self.nocc_w[ki],\n                            self.nocc_w[ki] + self.nvir_w[kj],\n                        )\n                        tmp = _ao2mo_e2(block_comp, coeffs, orb_slice)\n                        Lia_k += tmp.reshape(Lia_k.shape)\n\n            # Store the blocks\n            if do_Lpq:\n                Lpq[ki, kj] = Lpq_k\n            if do_Lpx:\n                Lpx[ki, kj] = Lpx_k\n            if do_Lia:\n                Lia[ki, kj] = Lia_k\n            else:\n                continue\n\n            # Inverse q for ki &lt;-&gt; kj\n            invq = self.kpts.member(self.kpts.wrap_around(-self.kpts[q]))\n\n            # Build the integrals blockwise\n            b1 = 0\n            for block in self.with_df.sr_loop((kj, ki), compact=False):  # TODO lock I/O\n                if block[2] == -1:\n                    raise NotImplementedError(\"Low dimensional integrals\")\n                block = block[0] + block[1] * 1.0j\n                b0, b1 = b1, b1 + block.shape[0]\n                progress = ki * len(self.kpts) ** 2 + kj * len(self.kpts) + b0\n                progress /= len(self.kpts) ** 2 + self.naux_full[invq]\n\n                with logging.with_status(f\"block [{ki}, {kj}, {b0}:{b1}] ({progress:.1%})\"):\n                    # Compress the block\n                    block_comp = util.einsum(\"L...,LQ-&gt;Q...\", block, rot[invq][b0:b1].conj())\n\n                    # Build the compressed (L|ai) array\n                    coeffs = np.concatenate(\n                        (\n                            self.mo_coeff_w[kj][:, self.mo_occ_w[kj] == 0],\n                            self.mo_coeff_w[ki][:, self.mo_occ_w[ki] &gt; 0],\n                        ),\n                        axis=1,\n                    )\n                    orb_slice = (\n                        0,\n                        self.nvir_w[kj],\n                        self.nvir_w[kj],\n                        self.nvir_w[kj] + self.nocc_w[ki],\n                    )\n                    tmp = _ao2mo_e2(block_comp, coeffs, orb_slice)\n                    tmp = tmp.reshape(self.naux[invq], self.nvir_w[kj], self.nocc_w[ki])\n                    tmp = tmp.swapaxes(1, 2)\n                    Lai_k += tmp.reshape(Lai_k.shape)\n\n            Lai[ki, kj] = Lai_k\n\n    # Store the arrays\n    if do_Lpq:\n        self._blocks[\"Lpq\"] = Lpq\n    if do_Lpx:\n        self._blocks[\"Lpx\"] = Lpx\n    if do_Lia:\n        self._blocks[\"Lia\"] = Lia\n        self._blocks[\"Lai\"] = Lai\n</code></pre>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.get_cderi_from_thc","title":"<code>momentGW.pbc.ints.KIntegrals.get_cderi_from_thc()</code>","text":"<p>Build CDERIs using THC integrals imported from a h5py file. It must contain a 'collocation_matrix' and a 'coulomb_matrix'.</p> Source code in <code>momentGW/pbc/ints.py</code> <pre><code>def get_cderi_from_thc(self):\n    \"\"\"\n    Build CDERIs using THC integrals imported from a h5py file.\n    It must contain a 'collocation_matrix' and a 'coulomb_matrix'.\n    \"\"\"\n\n    if self.input_path is None:\n        raise ValueError(\n            \"A file path containing the THC integrals is needed for the THC implementation\"\n        )\n    if \"thc\" not in self.input_path.lower():\n        raise ValueError(\"File path must contain 'thc' or 'THC' for THC implementation\")\n\n    thc_eri = h5py.File(self.input_path, \"r\")\n    kpts_imp = np.array(thc_eri[\"kpts\"])\n\n    if self.kpts != kpts_imp:\n        raise ValueError(\"Different kpts imported to those from PySCF\")\n\n    Lpx = {}\n    Lia = {}\n    Lai = {}\n    self._naux = [np.array(thc_eri[\"coulomb_matrix\"])[0, ..., 0].shape[0]] * len(self.kpts)\n    for q in self.kpts.loop(1):\n        for ki in self.kpts.loop(1):\n            kj = self.kpts.member(self.kpts.wrap_around(self.kpts[q] + self.kpts[ki]))\n\n            Lpx_k = np.zeros((self.naux[q], self.nmo, self.nmo_g[kj]), dtype=complex)\n            Lia_k = np.zeros((self.naux[q], self.nocc_w[ki] * self.nvir_w[kj]), dtype=complex)\n            Lai_k = np.zeros((self.naux[q], self.nocc_w[ki] * self.nvir_w[kj]), dtype=complex)\n\n            cou = np.asarray(thc_eri[\"coulomb_matrix\"])[q, ..., 0]\n            coll_ki = np.asarray(thc_eri[\"collocation_matrix\"])[0, ki, ..., 0]\n            coll_kj = np.asarray(thc_eri[\"collocation_matrix\"])[0, kj, ..., 0]\n            cholesky_cou = cholesky(cou, lower=True)\n\n            block = util.einsum(\"Pp,Pq,PQ-&gt;Qpq\", coll_ki.conj(), coll_kj, cholesky_cou)\n\n            coeffs = (self.mo_coeff[ki], self.mo_coeff_g[kj])\n            Lpx_k += util.einsum(\"Lpq,pi,qj-&gt;Lij\", block, coeffs[0].conj(), coeffs[1])\n            coeffs = (\n                self.mo_coeff_w[ki][:, self.mo_occ_w[ki] &gt; 0],\n                self.mo_coeff_w[kj][:, self.mo_occ_w[kj] == 0],\n            )\n            tmp = util.einsum(\"Lpq,pi,qj-&gt;Lij\", block, coeffs[0].conj(), coeffs[1])\n            tmp = tmp.reshape(self.naux[q], -1)\n            Lia_k += tmp\n\n            Lpx[ki, kj] = Lpx_k\n            Lia[ki, kj] = Lia_k\n\n            q = self.kpts.member(self.kpts.wrap_around(-self.kpts[q]))\n\n            block_switch = util.einsum(\"Pp,Pq,PQ-&gt;Qpq\", coll_kj.conj(), coll_ki, cholesky_cou)\n\n            coeffs = (\n                self.mo_coeff_w[kj][:, self.mo_occ_w[kj] == 0],\n                self.mo_coeff_w[ki][:, self.mo_occ_w[ki] &gt; 0],\n            )\n            tmp = util.einsum(\"Lpq,pi,qj-&gt;Lij\", block_switch, coeffs[0].conj(), coeffs[1])\n            tmp = tmp.swapaxes(1, 2)\n            tmp = tmp.reshape(self.naux[q], -1)\n            Lai_k += tmp\n\n            Lai[ki, kj] = Lai_k\n\n    self._blocks[\"Lpx\"] = Lpx\n    self._blocks[\"Lia\"] = Lia\n    self._blocks[\"Lai\"] = Lai\n</code></pre>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.update_coeffs","title":"<code>momentGW.pbc.ints.KIntegrals.update_coeffs(mo_coeff_g=None, mo_coeff_w=None, mo_occ_w=None)</code>","text":"<p>Update the MO coefficients in-place for the Green's function and the screened Coulomb interaction.</p> <p>Parameters:</p> Name Type Description Default <code>mo_coeff_g</code> <code>ndarray</code> <p>Coefficients corresponding to the Green's function at each k-point. Default value is <code>None</code>.</p> <code>None</code> <code>mo_coeff_w</code> <code>ndarray</code> <p>Coefficients corresponding to the screened Coulomb interaction at each k-point. Default value is <code>None</code>.</p> <code>None</code> <code>mo_occ_w</code> <code>ndarray</code> <p>Occupations corresponding to the screened Coulomb interaction at each k-point. Default value is <code>None</code>.</p> <code>None</code> Notes <p>If <code>mo_coeff_g</code> is <code>None</code>, the Green's function is assumed to remain in the basis in which it was originally defined, and vice-versa for <code>mo_coeff_w</code> and <code>mo_occ_w</code>. At least one of <code>mo_coeff_g</code> and <code>mo_coeff_w</code> must be provided.</p> Source code in <code>momentGW/pbc/ints.py</code> <pre><code>def update_coeffs(self, mo_coeff_g=None, mo_coeff_w=None, mo_occ_w=None):\n    \"\"\"\n    Update the MO coefficients in-place for the Green's function\n    and the screened Coulomb interaction.\n\n    Parameters\n    ----------\n    mo_coeff_g : numpy.ndarray, optional\n        Coefficients corresponding to the Green's function at each\n        k-point. Default value is `None`.\n    mo_coeff_w : numpy.ndarray, optional\n        Coefficients corresponding to the screened Coulomb\n        interaction at each k-point. Default value is `None`.\n    mo_occ_w : numpy.ndarray, optional\n        Occupations corresponding to the screened Coulomb\n        interaction at each k-point. Default value is `None`.\n\n    Notes\n    -----\n    If `mo_coeff_g` is `None`, the Green's function is assumed to\n    remain in the basis in which it was originally defined, and\n    vice-versa for `mo_coeff_w` and `mo_occ_w`. At least one of\n    `mo_coeff_g` and `mo_coeff_w` must be provided.\n    \"\"\"\n    return super().update_coeffs(\n        mo_coeff_g=mo_coeff_g,\n        mo_coeff_w=mo_coeff_w,\n        mo_occ_w=mo_occ_w,\n    )\n</code></pre>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.get_j","title":"<code>momentGW.pbc.ints.KIntegrals.get_j(dm, basis='mo', other=None)</code>","text":"<p>Build the J matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix at each k-point.</p> required <code>basis</code> <code>str</code> <p>Basis in which to build the J matrix. One of <code>(\"ao\", \"mo\")</code>. Default value is <code>\"mo\"</code>.</p> <code>'mo'</code> <code>other</code> <code>Integrals</code> <p>Integrals object for the ket side. Allows inheritence for mixed-spin evaluations. If <code>None</code>, use <code>self</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>vj</code> <code>ndarray</code> <p>J matrix.</p> Notes <p>The contraction is <code>J[p, q] = self[p, q] * other[r, s] * dm[r, s]</code>, and the bases must reflect shared indices.</p> Source code in <code>momentGW/pbc/ints.py</code> <pre><code>@logging.with_timer(\"J matrix\")\n@logging.with_status(\"Building J matrix\")\ndef get_j(self, dm, basis=\"mo\", other=None):\n    \"\"\"Build the J matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix at each k-point.\n    basis : str, optional\n        Basis in which to build the J matrix. One of\n        `(\"ao\", \"mo\")`. Default value is `\"mo\"`.\n    other : Integrals, optional\n        Integrals object for the ket side. Allows inheritence for\n        mixed-spin evaluations. If `None`, use `self`. Default\n        value is `None`.\n\n    Returns\n    -------\n    vj : numpy.ndarray\n        J matrix.\n\n    Notes\n    -----\n    The contraction is\n    `J[p, q] = self[p, q] * other[r, s] * dm[r, s]`, and the\n    bases must reflect shared indices.\n    \"\"\"\n\n    # Check the input\n    assert basis in (\"ao\", \"mo\")\n\n    # Get the other integrals\n    if other is None:\n        other = self\n\n    if self.store_full and basis == \"mo\":\n        # Initialise the J matrix\n        vj = np.zeros_like(dm, dtype=complex)\n\n        # Constuct J using the full MO basis integrals\n        buf = 0.0\n        for kk in self.kpts.loop(1, mpi=True):\n            buf += util.einsum(\"Lpq,pq-&gt;L\", other.Lpq[kk, kk], dm[kk].conj())\n\n        buf = mpi_helper.allreduce(buf)\n\n        for ki in self.kpts.loop(1, mpi=True):\n            vj[ki] += util.einsum(\"Lpq,L-&gt;pq\", self.Lpq[ki, ki], buf)\n\n        vj = mpi_helper.allreduce(vj)\n\n    else:\n        # Transform the density into the AO basis\n        if basis == \"mo\":\n            dm = util.einsum(\"kij,kpi,kqj-&gt;kpq\", dm, other.mo_coeff, np.conj(other.mo_coeff))\n\n        # Initialise the J matrix\n        vj = np.zeros_like(dm, dtype=complex)\n        buf = np.zeros((self.naux_full[0],), dtype=complex)\n\n        for kk in self.kpts.loop(1, mpi=True):\n            b1 = 0\n            for block in self.with_df.sr_loop((kk, kk), compact=False):  # TODO lock I/O\n                if block[2] == -1:\n                    raise NotImplementedError(\"Low dimensional integrals\")\n                block = block[0] + block[1] * 1.0j\n                block = block.reshape(block.shape[0], self.nao, self.nao)\n                b0, b1 = b1, b1 + block.shape[0]\n                buf[b0:b1] += util.einsum(\"Lpq,pq-&gt;L\", block, dm[kk].conj())\n\n        buf = mpi_helper.allreduce(buf)\n\n        for ki in self.kpts.loop(1, mpi=True):\n            b1 = 0\n            for block in self.with_df.sr_loop((ki, ki), compact=False):\n                if block[2] == -1:\n                    raise NotImplementedError(\"Low dimensional integrals\")\n                block = block[0] + block[1] * 1.0j\n                block = block.reshape(block.shape[0], self.nao, self.nao)\n                b0, b1 = b1, b1 + block.shape[0]\n                vj[ki] += util.einsum(\"Lpq,L-&gt;pq\", block, buf[b0:b1])\n\n        vj = mpi_helper.allreduce(vj)\n\n        # Transform the J matrix back to the MO basis\n        if basis == \"mo\":\n            vj = util.einsum(\"kpq,kpi,kqj-&gt;kij\", vj, np.conj(self.mo_coeff), self.mo_coeff)\n\n    vj /= len(self.kpts)\n\n    return vj\n</code></pre>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.get_k","title":"<code>momentGW.pbc.ints.KIntegrals.get_k(dm, basis='mo', ewald=False)</code>","text":"<p>Build the K matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix at each k-point.</p> required <code>basis</code> <code>str</code> <p>Basis in which to build the K matrix. One of <code>(\"ao\", \"mo\")</code>. Default value is <code>\"mo\"</code>.</p> <code>'mo'</code> <p>Returns:</p> Name Type Description <code>vk</code> <code>ndarray</code> <p>K matrix at each k-point.</p> Notes <p>The contraction is <code>K[p, q] = self[r, q] * self[p, r] * dm[q, s]</code>, and the bases must reflect shared indices.</p> Source code in <code>momentGW/pbc/ints.py</code> <pre><code>@logging.with_timer(\"K matrix\")\n@logging.with_status(\"Building K matrix\")\ndef get_k(self, dm, basis=\"mo\", ewald=False):\n    \"\"\"Build the K matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix at each k-point.\n    basis : str, optional\n        Basis in which to build the K matrix. One of\n        `(\"ao\", \"mo\")`. Default value is `\"mo\"`.\n\n    Returns\n    -------\n    vk : numpy.ndarray\n        K matrix at each k-point.\n\n    Notes\n    -----\n    The contraction is\n    `K[p, q] = self[r, q] * self[p, r] * dm[q, s]`, and the\n    bases must reflect shared indices.\n    \"\"\"\n\n    # Check the input\n    assert basis in (\"ao\", \"mo\")\n\n    if self.store_full and basis == \"mo\":\n        # Initialise the K matrix\n        vk = np.zeros_like(dm, dtype=complex)\n\n        # Constuct K using the full MO basis integrals\n        for p0, p1 in lib.prange(0, np.max(self.naux_full), 240):\n            buf = np.zeros((len(self.kpts), len(self.kpts)), dtype=object)\n            for ki in self.kpts.loop(1, mpi=True):\n                for kk in self.kpts.loop(1):\n                    q = self.kpts.member(self.kpts.wrap_around(self.kpts[kk] - self.kpts[ki]))\n                    if p1 &gt; self.naux_full[q]:\n                        p1 = self.naux_full[q]\n                    buf[kk, ki] = util.einsum(\"Lpq,qr-&gt;Lrp\", self.Lpq[ki, kk][p0:p1], dm[kk])\n\n            buf = mpi_helper.allreduce(buf)\n\n            for ki in self.kpts.loop(1):\n                for kk in self.kpts.loop(1, mpi=True):\n                    vk[ki] += util.einsum(\"Lrp,Lrs-&gt;ps\", buf[kk, ki], self.Lpq[kk, ki][p0:p1])\n\n        vk = mpi_helper.allreduce(vk)\n\n    else:\n        # Transform the density into the AO basis\n        if basis == \"mo\":\n            dm = util.einsum(\"kij,kpi,kqj-&gt;kpq\", dm, self.mo_coeff, np.conj(self.mo_coeff))\n\n        # Initialise the J matrix\n        vk = np.zeros_like(dm, dtype=complex)\n\n        for q in self.kpts.loop(1):\n            buf = np.zeros(\n                (len(self.kpts), self.naux_full[q], self.nao, self.nao), dtype=complex\n            )\n            for ki in self.kpts.loop(1, mpi=True):\n                b1 = 0\n                kk = self.kpts.member(self.kpts.wrap_around(self.kpts[q] + self.kpts[ki]))\n                for block in self.with_df.sr_loop((ki, kk), compact=False):\n                    if block[2] == -1:\n                        raise NotImplementedError(\"Low dimensional integrals\")\n                    block = block[0] + block[1] * 1.0j\n                    block = block.reshape(block.shape[0], self.nao, self.nao)\n                    b0, b1 = b1, b1 + block.shape[0]\n                    buf[ki, b0:b1] = util.einsum(\"Lpq,qr-&gt;Lrp\", block, dm[kk])\n\n            buf = mpi_helper.allreduce(buf)\n\n            for ki in self.kpts.loop(1, mpi=True):\n                b1 = 0\n                kk = self.kpts.member(self.kpts.wrap_around(self.kpts[q] + self.kpts[ki]))\n                for block in self.with_df.sr_loop((kk, ki), compact=False):\n                    if block[2] == -1:\n                        raise NotImplementedError(\"Low dimensional integrals\")\n                    block = block[0] + block[1] * 1.0j\n                    block = block.reshape(block.shape[0], self.nao, self.nao)\n                    b0, b1 = b1, b1 + block.shape[0]\n                    vk[ki] += util.einsum(\"Lrp,Lrs-&gt;ps\", buf[ki, b0:b1], block)\n\n        vk = mpi_helper.allreduce(vk)\n\n        # Transform the K matrix back to the MO basis\n        if basis == \"mo\":\n            vk = util.einsum(\"kpq,kpi,kqj-&gt;kij\", vk, np.conj(self.mo_coeff), self.mo_coeff)\n\n    vk /= len(self.kpts)\n\n    if ewald:\n        vk += self.get_ewald(dm, basis=basis)\n\n    return vk\n</code></pre>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.get_ewald","title":"<code>momentGW.pbc.ints.KIntegrals.get_ewald(dm, basis='mo')</code>","text":"<p>Build the Ewald exchange divergence matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix at each k-point.</p> required <code>basis</code> <code>str</code> <p>Basis in which to build the K matrix. One of <code>(\"ao\", \"mo\")</code>. Default value is <code>\"mo\"</code>.</p> <code>'mo'</code> <p>Returns:</p> Name Type Description <code>ew</code> <code>ndarray</code> <p>Ewald exchange divergence matrix at each k-point.</p> Source code in <code>momentGW/pbc/ints.py</code> <pre><code>@logging.with_timer(\"Ewald matrix\")\n@logging.with_status(\"Building Ewald matrix\")\ndef get_ewald(self, dm, basis=\"mo\"):\n    \"\"\"Build the Ewald exchange divergence matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix at each k-point.\n    basis : str, optional\n        Basis in which to build the K matrix. One of\n        `(\"ao\", \"mo\")`. Default value is `\"mo\"`.\n\n    Returns\n    -------\n    ew : numpy.ndarray\n        Ewald exchange divergence matrix at each k-point.\n    \"\"\"\n\n    # Check the input\n    assert basis in (\"ao\", \"mo\")\n\n    # Get the overlap matrix\n    if basis == \"mo\":\n        ovlp = defaultdict(lambda: np.eye(self.nmo))\n    else:\n        ovlp = self.with_df.cell.pbc_intor(\"int1e_ovlp\", hermi=1, kpts=self.kpts._kpts)\n\n    # Initialise the Ewald matrix\n    ew = util.einsum(\"kpq,kpi,kqj-&gt;kij\", dm, ovlp.conj(), ovlp)\n\n    return ew\n</code></pre>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.get_jk","title":"<code>momentGW.pbc.ints.KIntegrals.get_jk(dm, **kwargs)</code>","text":"<p>Build the J and K matrices.</p> <p>Returns:</p> Name Type Description <code>vj</code> <code>ndarray</code> <p>J matrix at each k-point.</p> <code>vk</code> <code>ndarray</code> <p>K matrix at each k-point.</p> Notes <p>See <code>get_j</code> and <code>get_k</code> for more information.</p> Source code in <code>momentGW/pbc/ints.py</code> <pre><code>def get_jk(self, dm, **kwargs):\n    \"\"\"Build the J and K matrices.\n\n    Returns\n    -------\n    vj : numpy.ndarray\n        J matrix at each k-point.\n    vk : numpy.ndarray\n        K matrix at each k-point.\n\n    Notes\n    -----\n    See `get_j` and `get_k` for more information.\n    \"\"\"\n    return super().get_jk(dm, **kwargs)\n</code></pre>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.get_veff","title":"<code>momentGW.pbc.ints.KIntegrals.get_veff(dm, j=None, k=None, **kwargs)</code>","text":"<p>Build the effective potential.</p> <p>Returns:</p> Name Type Description <code>veff</code> <code>ndarray</code> <p>Effective potential at each k-point.</p> <code>j</code> <code>(ndarray, optional)</code> <p>J matrix at each k-point. If <code>None</code>, compute it. Default value is <code>None</code>.</p> <code>k</code> <code>(ndarray, optional)</code> <p>K matrix at each k-point. If <code>None</code>, compute it. Default value is <code>None</code>.</p> Notes <p>See <code>get_jk</code> for more information.</p> Source code in <code>momentGW/pbc/ints.py</code> <pre><code>def get_veff(self, dm, j=None, k=None, **kwargs):\n    \"\"\"Build the effective potential.\n\n    Returns\n    -------\n    veff : numpy.ndarray\n        Effective potential at each k-point.\n    j : numpy.ndarray, optional\n        J matrix at each k-point. If `None`, compute it. Default\n        value is `None`.\n    k : numpy.ndarray, optional\n        K matrix at each k-point. If `None`, compute it. Default\n        value is `None`.\n\n    Notes\n    -----\n    See `get_jk` for more information.\n    \"\"\"\n    return super().get_veff(dm, j=j, k=k, **kwargs)\n</code></pre>"},{"location":"reference/pbc/ints/#momentGW.pbc.ints.KIntegrals.get_fock","title":"<code>momentGW.pbc.ints.KIntegrals.get_fock(dm, h1e, **kwargs)</code>","text":"<p>Build the Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix at each k-point.</p> required <code>h1e</code> <code>ndarray</code> <p>Core Hamiltonian matrix at each k-point.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for <code>get_jk</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>fock</code> <code>ndarray</code> <p>Fock matrix at each k-point.</p> Notes <p>See <code>get_jk</code> for more information. The basis of <code>h1e</code> must be the same as <code>dm</code>.</p> Source code in <code>momentGW/pbc/ints.py</code> <pre><code>def get_fock(self, dm, h1e, **kwargs):\n    \"\"\"Build the Fock matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix at each k-point.\n    h1e : numpy.ndarray\n        Core Hamiltonian matrix at each k-point.\n    **kwargs : dict, optional\n        Additional keyword arguments for `get_jk`.\n\n    Returns\n    -------\n    fock : numpy.ndarray\n        Fock matrix at each k-point.\n\n    Notes\n    -----\n    See `get_jk` for more information. The basis of `h1e` must be\n    the same as `dm`.\n    \"\"\"\n    return super().get_fock(dm, h1e, **kwargs)\n</code></pre>"},{"location":"reference/pbc/kpts/","title":"Kpts","text":"<p>k-points helper utilities.</p>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints","title":"<code>momentGW.pbc.kpts.KPoints(cell, kpts, tol=1e-06, wrap_around=True)</code>","text":"<p>Helper class for k-points.</p> <p>Parameters:</p> Name Type Description Default <code>cell</code> <code>Cell</code> <p>Unit cell.</p> required <code>kpts</code> <code>ndarray</code> <p>K-points.</p> required <code>tol</code> <code>float</code> <p>Threshold for determining if two k-points are equal. Default value is <code>1e-8</code>.</p> <code>1e-06</code> <code>wrap_around</code> <code>bool</code> <p>Whether to wrap k-points around the first Brillouin zone. Default value is <code>True</code>.</p> <code>True</code> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def __init__(self, cell, kpts, tol=1e-6, wrap_around=True):\n    self.cell = cell\n    self.tol = tol\n\n    if not isinstance(kpts, np.ndarray):\n        kpts = kpts.kpts\n\n    if wrap_around:\n        kpts = self.wrap_around(kpts)\n    self._kpts = kpts\n\n    self._kconserv = kpts_helper.get_kconserv(cell, kpts)\n    self._kpts_hash = {self.hash_kpts(kpt): k for k, kpt in enumerate(self._kpts)}\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.tol_decimals","title":"<code>momentGW.pbc.kpts.KPoints.tol_decimals</code>  <code>property</code>","text":"<p>Convert the tolerance into a number of decimal places.</p> <p>Returns:</p> Name Type Description <code>tol_decimals</code> <code>int</code> <p>Number of decimal places.</p>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.kmesh","title":"<code>momentGW.pbc.kpts.KPoints.kmesh</code>  <code>property</code>","text":"<p>Guess the k-mesh.</p> <p>Returns:</p> Name Type Description <code>kmesh</code> <code>list</code> <p>Size of the k-mesh in each direction.</p>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.T","title":"<code>momentGW.pbc.kpts.KPoints.T</code>  <code>property</code>","text":"<p>Get the transpose of the k-points.</p>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.member","title":"<code>momentGW.pbc.kpts.KPoints.member(kpt)</code>","text":"<p>Find the index of the k-point in the k-point list.</p> <p>Parameters:</p> Name Type Description Default <code>kpt</code> <code>ndarray</code> <p>The k-point.</p> required <p>Returns:</p> Name Type Description <code>index</code> <code>int</code> <p>Index of the k-point.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def member(self, kpt):\n    \"\"\"\n    Find the index of the k-point in the k-point list.\n\n    Parameters\n    ----------\n    kpt : numpy.ndarray\n        The k-point.\n\n    Returns\n    -------\n    index : int\n        Index of the k-point.\n    \"\"\"\n    if kpt not in self:\n        raise ValueError(f\"{kpt} is not in list\")\n    return self._kpts_hash[self.hash_kpts(kpt)]\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.index","title":"<code>momentGW.pbc.kpts.KPoints.index(kpt)</code>","text":"<p>Alias for <code>member</code>.</p> <p>Parameters:</p> Name Type Description Default <code>kpt</code> <code>ndarray</code> <p>The k-point.</p> required <p>Returns:</p> Name Type Description <code>index</code> <code>int</code> <p>Index of the k-point.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def index(self, kpt):\n    \"\"\"\n    Alias for `member`.\n\n    Parameters\n    ----------\n    kpt : numpy.ndarray\n        The k-point.\n\n    Returns\n    -------\n    index : int\n        Index of the k-point.\n    \"\"\"\n    return self.member(kpt)\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.get_scaled_kpts","title":"<code>momentGW.pbc.kpts.KPoints.get_scaled_kpts(kpts)</code>","text":"<p>Convert absolute k-points to scaled k-points for the current cell.</p> <p>Parameters:</p> Name Type Description Default <code>kpts</code> <code>ndarray</code> <p>Absolute k-points.</p> required <p>Returns:</p> Name Type Description <code>scaled_kpts</code> <code>ndarray</code> <p>Scaled k-points.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>@allow_single_kpt(output_is_kpts=True)\ndef get_scaled_kpts(self, kpts):\n    \"\"\"\n    Convert absolute k-points to scaled k-points for the current\n    cell.\n\n    Parameters\n    ----------\n    kpts : numpy.ndarray\n        Absolute k-points.\n\n    Returns\n    -------\n    scaled_kpts : numpy.ndarray\n        Scaled k-points.\n    \"\"\"\n    return self.cell.get_scaled_kpts(kpts)\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.get_abs_kpts","title":"<code>momentGW.pbc.kpts.KPoints.get_abs_kpts(kpts)</code>","text":"<p>Convert scaled k-points to absolute k-points for the current cell.</p> <p>Parameters:</p> Name Type Description Default <code>kpts</code> <code>ndarray</code> <p>Scaled k-points.</p> required <p>Returns:</p> Name Type Description <code>abs_kpts</code> <code>ndarray</code> <p>Absolute k-points.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>@allow_single_kpt(output_is_kpts=True)\ndef get_abs_kpts(self, kpts):\n    \"\"\"\n    Convert scaled k-points to absolute k-points for the current\n    cell.\n\n    Parameters\n    ----------\n    kpts : numpy.ndarray\n        Scaled k-points.\n\n    Returns\n    -------\n    abs_kpts : numpy.ndarray\n        Absolute k-points.\n    \"\"\"\n    return self.cell.get_abs_kpts(kpts)\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.wrap_around","title":"<code>momentGW.pbc.kpts.KPoints.wrap_around(kpts, window=(-0.5, 0.5))</code>","text":"<p>Handle the wrapping of k-points into the first Brillouin zone.</p> <p>Parameters:</p> Name Type Description Default <code>kpts</code> <code>ndarray</code> <p>Absolute k-points.</p> required <code>window</code> <code>tuple</code> <p>Window within which to contain scaled k-points. Default value is <code>(-0.5, 0.5)</code>.</p> <code>(-0.5, 0.5)</code> <p>Returns:</p> Name Type Description <code>wrapped_kpts</code> <code>ndarray</code> <p>Wrapped k-points.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>@allow_single_kpt(output_is_kpts=True)\ndef wrap_around(self, kpts, window=(-0.5, 0.5)):\n    \"\"\"\n    Handle the wrapping of k-points into the first Brillouin zone.\n\n    Parameters\n    ----------\n    kpts : numpy.ndarray\n        Absolute k-points.\n    window : tuple, optional\n        Window within which to contain scaled k-points. Default value\n        is `(-0.5, 0.5)`.\n\n    Returns\n    -------\n    wrapped_kpts : numpy.ndarray\n        Wrapped k-points.\n    \"\"\"\n\n    kpts = self.get_scaled_kpts(kpts) % 1.0\n    kpts = lib.cleanse(kpts, axis=0, tol=self.tol)\n    kpts = kpts.round(decimals=self.tol_decimals) % 1.0\n\n    kpts[kpts &lt; window[0]] += 1.0\n    kpts[kpts &gt;= window[1]] -= 1.0\n\n    kpts = self.get_abs_kpts(kpts)\n\n    return kpts\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.hash_kpts","title":"<code>momentGW.pbc.kpts.KPoints.hash_kpts(kpts)</code>","text":"<p>Convert k-points to a unique, hashable representation.</p> <p>Parameters:</p> Name Type Description Default <code>kpts</code> <code>ndarray</code> <p>Absolute k-points.</p> required <p>Returns:</p> Name Type Description <code>hash_kpts</code> <code>tuple</code> <p>Hashable representation of k-points.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>@allow_single_kpt(output_is_kpts=False)\ndef hash_kpts(self, kpts):\n    \"\"\"\n    Convert k-points to a unique, hashable representation.\n\n    Parameters\n    ----------\n    kpts : numpy.ndarray\n        Absolute k-points.\n\n    Returns\n    -------\n    hash_kpts : tuple\n        Hashable representation of k-points.\n    \"\"\"\n    return tuple(np.rint(kpts / (self.tol)).ravel().astype(int))\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.conserve","title":"<code>momentGW.pbc.kpts.KPoints.conserve(ki, kj, kk)</code>","text":"<p>Get the index of the k-point that conserves momentum.</p> <p>Parameters:</p> Name Type Description Default <code>ki</code> <code>int</code> <p>Indices of the k-points.</p> required <code>kj</code> <code>int</code> <p>Indices of the k-points.</p> required <code>kk</code> <code>int</code> <p>Indices of the k-points.</p> required <p>Returns:</p> Name Type Description <code>kconserv</code> <code>int</code> <p>Index of the k-point that conserves momentum.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def conserve(self, ki, kj, kk):\n    \"\"\"\n    Get the index of the k-point that conserves momentum.\n\n    Parameters\n    ----------\n    ki, kj, kk : int\n        Indices of the k-points.\n\n    Returns\n    -------\n    kconserv : int\n        Index of the k-point that conserves momentum.\n    \"\"\"\n    return self._kconserv[ki, kj, kk]\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.loop","title":"<code>momentGW.pbc.kpts.KPoints.loop(depth, mpi=False)</code>","text":"<p>Iterate over all combinations of k-points up to a given depth.</p> <p>Parameters:</p> Name Type Description Default <code>depth</code> <code>int</code> <p>Depth of the loop.</p> required <code>mpi</code> <code>bool</code> <p>Whether to split the loop over MPI processes. Default value is <code>False</code>.</p> <code>False</code> <p>Yields:</p> Name Type Description <code>kpts</code> <code>tuple</code> <p>Tuple of k-point indices.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def loop(self, depth, mpi=False):\n    \"\"\"\n    Iterate over all combinations of k-points up to a given depth.\n\n    Parameters\n    ----------\n    depth : int\n        Depth of the loop.\n    mpi : bool, optional\n        Whether to split the loop over MPI processes. Default value\n        is `False`.\n\n    Yields\n    ------\n    kpts : tuple\n        Tuple of k-point indices.\n    \"\"\"\n\n    if depth == 1:\n        seq = range(len(self))\n    else:\n        seq = itertools.product(range(len(self)), repeat=depth)\n\n    if mpi:\n        size = len(self) * depth\n        split = lambda x: x * size // mpi_helper.size\n\n        p0 = split(mpi_helper.rank)\n        p1 = size if mpi_helper.rank == (mpi_helper.size - 1) else split(mpi_helper.rank + 1)\n\n        seq = itertools.islice(seq, p0, p1)\n\n    yield from seq\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.loop_size","title":"<code>momentGW.pbc.kpts.KPoints.loop_size(depth=1)</code>","text":"<p>Return the size of <code>loop</code>. Without MPI, this is equivalent to <code>len(self)**depth</code>.</p> <p>Parameters:</p> Name Type Description Default <code>depth</code> <code>int</code> <p>Depth of the loop. Default value is <code>1</code>.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>size</code> <code>int</code> <p>Size of the loop.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def loop_size(self, depth=1):\n    \"\"\"\n    Return the size of `loop`. Without MPI, this is equivalent to\n    `len(self)**depth`.\n\n    Parameters\n    ----------\n    depth : int, optional\n        Depth of the loop. Default value is `1`.\n\n    Returns\n    -------\n    size : int\n        Size of the loop.\n    \"\"\"\n\n    size = len(self) * depth\n    split = lambda x: x * size // mpi_helper.size\n\n    p0 = split(mpi_helper.rank)\n    p1 = size if mpi_helper.rank == (mpi_helper.size - 1) else split(mpi_helper.rank + 1)\n\n    return p1 - p0\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.is_zero","title":"<code>momentGW.pbc.kpts.KPoints.is_zero(kpts)</code>","text":"<p>Check if the k-point is zero.</p> <p>Parameters:</p> Name Type Description Default <code>kpts</code> <code>ndarray</code> <p>Absolute k-points.</p> required <p>Returns:</p> Name Type Description <code>is_zero</code> <code>bool</code> <p>Whether the k-point is zero.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>@allow_single_kpt(output_is_kpts=False)\ndef is_zero(self, kpts):\n    \"\"\"\n    Check if the k-point is zero.\n\n    Parameters\n    ----------\n    kpts : numpy.ndarray\n        Absolute k-points.\n\n    Returns\n    -------\n    is_zero : bool\n        Whether the k-point is zero.\n    \"\"\"\n    return np.max(np.abs(kpts)) &lt; self.tol\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.translation_vectors","title":"<code>momentGW.pbc.kpts.KPoints.translation_vectors()</code>","text":"<p>Build translation vectors to construct supercell of which the gamma point is identical to the k-point mesh of the primitive cell.</p> <p>Returns:</p> Name Type Description <code>r_vec_abs</code> <code>ndarray</code> <p>Translation vectors.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def translation_vectors(self):\n    \"\"\"\n    Build translation vectors to construct supercell of which the\n    gamma point is identical to the k-point mesh of the primitive\n    cell.\n\n    Returns\n    -------\n    r_vec_abs : numpy.ndarray\n        Translation vectors.\n    \"\"\"\n\n    kmesh = self.kmesh\n\n    r_rel = [np.arange(kmesh[i]) for i in range(3)]\n    r_vec_rel = lib.cartesian_prod(r_rel)\n    r_vec_abs = np.dot(r_vec_rel, self.cell.lattice_vectors())\n\n    return r_vec_abs\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.interpolate","title":"<code>momentGW.pbc.kpts.KPoints.interpolate(other, fk)</code>","text":"<p>Interpolate a function <code>f</code> from the current grid of k-points to those of <code>other</code>. Input must be in a localised basis, i.e. AOs.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>KPoints</code> <p>The k-points to interpolate to.</p> required <code>fk</code> <code>ndarray</code> <p>The function to interpolate, expressed on the current k-point grid. Must be a matrix-valued array expressed in k-space, in a localised basis.</p> required <p>Returns:</p> Name Type Description <code>f</code> <code>ndarray</code> <p>The interpolated function, expressed on the new k-point grid.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def interpolate(self, other, fk):\n    \"\"\"\n    Interpolate a function `f` from the current grid of k-points to\n    those of `other`. Input must be in a localised basis, i.e. AOs.\n\n    Parameters\n    ----------\n    other : KPoints\n        The k-points to interpolate to.\n    fk : numpy.ndarray\n        The function to interpolate, expressed on the current\n        k-point grid. Must be a matrix-valued array expressed in\n        k-space, *in a localised basis*.\n\n    Returns\n    -------\n    f : numpy.ndarray\n        The interpolated function, expressed on the new k-point grid.\n    \"\"\"\n\n    if len(other) % len(self):\n        raise ValueError(\n            \"Size of destination k-point mesh must be divisible by the size of the source \"\n            \"k-point mesh for interpolation.\"\n        )\n    nimg = len(other) // len(self)\n    nao = fk.shape[-1]\n\n    r_vec_abs = self.translation_vectors()\n    kR = np.exp(1.0j * np.dot(self._kpts, r_vec_abs.T)) / np.sqrt(len(r_vec_abs))\n\n    r_vec_abs = other.translation_vectors()\n    kL = np.exp(1.0j * np.dot(other._kpts, r_vec_abs.T)) / np.sqrt(len(r_vec_abs))\n\n    # k -&gt; bvk\n    fg = util.einsum(\"kR,kij,kS-&gt;RiSj\", kR, fk, kR.conj())\n    if np.max(np.abs(fg.imag)) &gt; 1e-6:\n        raise ValueError(\"Interpolated function has non-zero imaginary part.\")\n    fg = fg.real\n    fg = fg.reshape(len(self) * nao, len(self) * nao)\n\n    # tile in bvk\n    fg = scipy.linalg.block_diag(*[fg for i in range(nimg)])\n\n    # bvk -&gt; k\n    fg = fg.reshape(len(other), nao, len(other), nao)\n    fl = util.einsum(\"kR,RiSj,kS-&gt;kij\", kL.conj(), fg, kL)\n\n    return fl\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.__array__","title":"<code>momentGW.pbc.kpts.KPoints.__array__()</code>","text":"<p>Get the k-points as a numpy array.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def __array__(self):\n    \"\"\"\n    Get the k-points as a numpy array.\n    \"\"\"\n    return np.asarray(self._kpts)\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.__getitem__","title":"<code>momentGW.pbc.kpts.KPoints.__getitem__(index)</code>","text":"<p>Get the k-point at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the k-point.</p> required <p>Returns:</p> Name Type Description <code>kpt</code> <code>ndarray</code> <p>The k-point.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def __getitem__(self, index):\n    \"\"\"\n    Get the k-point at the given index.\n\n    Parameters\n    ----------\n    index : int\n        Index of the k-point.\n\n    Returns\n    -------\n    kpt : numpy.ndarray\n        The k-point.\n    \"\"\"\n    return self._kpts[index]\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.__iter__","title":"<code>momentGW.pbc.kpts.KPoints.__iter__()</code>","text":"<p>Iterate over the k-points.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def __iter__(self):\n    \"\"\"\n    Iterate over the k-points.\n    \"\"\"\n    return iter(self._kpts)\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.__contains__","title":"<code>momentGW.pbc.kpts.KPoints.__contains__(kpt)</code>","text":"<p>Check if the k-point is in the k-point list.</p> <p>Parameters:</p> Name Type Description Default <code>kpt</code> <code>ndarray</code> <p>The k-point.</p> required <p>Returns:</p> Name Type Description <code>is_in</code> <code>bool</code> <p>Whether the k-point is in the list.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def __contains__(self, kpt):\n    \"\"\"\n    Check if the k-point is in the k-point list.\n\n    Parameters\n    ----------\n    kpt : numpy.ndarray\n        The k-point.\n\n    Returns\n    -------\n    is_in : bool\n        Whether the k-point is in the list.\n    \"\"\"\n    return self.hash_kpts(kpt) in self._kpts_hash\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.__len__","title":"<code>momentGW.pbc.kpts.KPoints.__len__()</code>","text":"<p>Get the number of k-points.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def __len__(self):\n    \"\"\"\n    Get the number of k-points.\n    \"\"\"\n    return len(self._kpts)\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.__eq__","title":"<code>momentGW.pbc.kpts.KPoints.__eq__(other)</code>","text":"<p>Check if two k-point lists are equal to within <code>self.tol</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>KPoints or ndarray</code> <p>The other k-point list. If a <code>numpy.ndarray</code> is given, it is converted to a <code>KPoints</code> object, complete with the wrap around handling.</p> required <p>Returns:</p> Name Type Description <code>is_equal</code> <code>bool</code> <p>Whether the two k-point lists are equal to within <code>self.tol</code>. Uses the hashes according to <code>KPoints.hash_kpts</code>.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Check if two k-point lists are equal to within `self.tol`.\n\n    Parameters\n    ----------\n    other : KPoints or numpy.ndarray\n        The other k-point list. If a `numpy.ndarray` is given, it\n        is converted to a `KPoints` object, complete with the wrap\n        around handling.\n\n    Returns\n    -------\n    is_equal : bool\n        Whether the two k-point lists are equal to within\n        `self.tol`. Uses the hashes according to `KPoints.hash_kpts`.\n    \"\"\"\n    if not isinstance(other, KPoints):\n        other = KPoints(self.cell, other, tol=self.tol)\n    if len(self) != len(other):\n        return False\n    return self.hash_kpts(self._kpts) == other.hash_kpts(other._kpts)\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.__ne__","title":"<code>momentGW.pbc.kpts.KPoints.__ne__(other)</code>","text":"<p>Check if two k-point lists are not equal to within <code>self.tol</code>.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def __ne__(self, other):\n    \"\"\"\n    Check if two k-point lists are not equal to within `self.tol`.\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.__repr__","title":"<code>momentGW.pbc.kpts.KPoints.__repr__()</code>","text":"<p>Get a string representation of the k-points.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def __repr__(self):\n    \"\"\"\n    Get a string representation of the k-points.\n    \"\"\"\n    return repr(self._kpts)\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.KPoints.__str__","title":"<code>momentGW.pbc.kpts.KPoints.__str__()</code>","text":"<p>Get a string representation of the k-points.</p> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Get a string representation of the k-points.\n    \"\"\"\n    return str(self._kpts)\n</code></pre>"},{"location":"reference/pbc/kpts/#momentGW.pbc.kpts.allow_single_kpt","title":"<code>momentGW.pbc.kpts.allow_single_kpt(output_is_kpts=False)</code>","text":"<p>Decorate functions to allow <code>kpts</code> arguments to be passed as a single k-point.</p> <p>Parameters:</p> Name Type Description Default <code>output_is_kpts</code> <code>bool</code> <p>Whether the output of the function is a k-point. Default value is <code>False</code>.</p> <code>False</code> Source code in <code>momentGW/pbc/kpts.py</code> <pre><code>def allow_single_kpt(output_is_kpts=False):\n    \"\"\"\n    Decorate functions to allow `kpts` arguments to be passed as a single\n    k-point.\n\n    Parameters\n    ----------\n    output_is_kpts : bool, optional\n        Whether the output of the function is a k-point. Default value\n        is `False`.\n    \"\"\"\n\n    def decorator(func):\n        def wrapper(self, kpts, *args, **kwargs):\n            shape = kpts.shape\n            kpts = kpts.reshape(-1, 3)\n            res = func(self, kpts, *args, **kwargs)\n            if output_is_kpts:\n                return res.reshape(shape)\n            else:\n                return res\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/pbc/qsgw/","title":"Qsgw","text":"<p>Spin-restricted quasiparticle self-consistent GW via self-energy moment constraints for periodic systems.</p>"},{"location":"reference/pbc/qsgw/#momentGW.pbc.qsgw.qsKGW","title":"<code>momentGW.pbc.qsgw.qsKGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>KGW</code>, <code>qsGW</code></p> <p>Spin-restricted quasiparticle self-consistent GW via self-energy moment constraints for periodic systems.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>KSCF</code> <p>PySCF periodic mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>fc</code> <code>bool</code> <p>If <code>True</code>, apply finite size corrections. Default value is <code>False</code>.</p> required <code>max_cycle</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>50</code>.</p> required <code>max_cycle_qp</code> <code>int</code> <p>Maximum number of iterations in the quasiparticle equation loop. Default value is <code>50</code>.</p> required <code>conv_tol</code> <code>float</code> <p>Convergence threshold in the change in the HOMO and LUMO. Default value is <code>1e-8</code>.</p> required <code>conv_tol_moms</code> <code>float</code> <p>Convergence threshold in the change in the moments. Default value is <code>1e-8</code>.</p> required <code>conv_tol_qp</code> <code>float</code> <p>Convergence threshold in the change in the density matrix in the quasiparticle equation loop. Default value is <code>1e-8</code>.</p> required <code>conv_logical</code> <code>callable</code> <p>Function that takes an iterable of booleans as input indicating whether the individual <code>conv_tol</code>, <code>conv_tol_moms</code>, <code>conv_tol_qp</code> have been satisfied, respectively, and returns a boolean indicating overall convergence. For example, the function <code>all</code> requires both metrics to be met, and <code>any</code> requires just one. Default value is <code>all</code>.</p> required <code>diis_space</code> <code>int</code> <p>Size of the DIIS extrapolation space. Default value is <code>8</code>.</p> required <code>diis_space_qp</code> <code>int</code> <p>Size of the DIIS extrapolation space in the quasiparticle loop. Default value is <code>8</code>.</p> required <code>damping</code> <code>float</code> <p>Damping parameter. Default value is <code>0.0</code>.</p> required <code>eta</code> <code>float</code> <p>Small value to regularise the self-energy. Default value is <code>1e-1</code>.</p> required <code>srg</code> <code>float</code> <p>If non-zero, use the similarity renormalisation group approach of Marie and Loos in place of the <code>eta</code> regularisation. For value recommendations refer to their paper (arXiv:2303.05984). Default value is <code>0.0</code>.</p> required <code>solver</code> <code>BaseGW</code> <p>Solver to use to obtain the self-energy. Compatible with any <code>BaseGW</code>-like class. Default value is <code>momentGW.gw.GW</code>.</p> required <code>solver_options</code> <code>dict</code> <p>Keyword arguments to pass to the solver. Default value is an empty <code>dict</code>.</p> required Source code in <code>momentGW/pbc/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Options\n    self.fc = False\n\n    # Attributes\n    self._kpts = KPoints(self.cell, getattr(mf, \"kpts\", np.zeros((1, 3))))\n</code></pre>"},{"location":"reference/pbc/qsgw/#momentGW.pbc.qsgw.qsKGW.name","title":"<code>momentGW.pbc.qsgw.qsKGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/pbc/qsgw/#momentGW.pbc.qsgw.qsKGW.project_basis","title":"<code>momentGW.pbc.qsgw.qsKGW.project_basis(matrix, ovlp, mo1, mo2)</code>  <code>staticmethod</code>","text":"<p>Project a matrix from one basis to another.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>numpy.ndarray or tuple of dyson.Lehmann</code> <p>Matrix to project at each k-point. Can also be a tuple of <code>dyson.Lehmann</code> objects, in which case the <code>couplings</code> attributes are projected.</p> required <code>ovlp</code> <code>ndarray</code> <p>Overlap matrix in the shared (AO) basis at each k-point.</p> required <code>mo1</code> <code>ndarray</code> <p>First basis, rotates from the shared (AO) basis into the basis of <code>matrix</code> at each k-point.</p> required <code>mo2</code> <code>ndarray</code> <p>Second basis, rotates from the shared (AO) basis into the desired basis of the output at each k-point.</p> required <p>Returns:</p> Name Type Description <code>proj</code> <code>numpy.ndarray or tuple of dyson.Lehmann</code> <p>Matrix projected into the desired basis at each k-point.</p> Source code in <code>momentGW/pbc/qsgw.py</code> <pre><code>@staticmethod\ndef project_basis(matrix, ovlp, mo1, mo2):\n    \"\"\"\n    Project a matrix from one basis to another.\n\n    Parameters\n    ----------\n    matrix : numpy.ndarray or tuple of dyson.Lehmann\n        Matrix to project at each k-point. Can also be a tuple of\n        `dyson.Lehmann` objects, in which case the `couplings`\n        attributes are projected.\n    ovlp : numpy.ndarray\n        Overlap matrix in the shared (AO) basis at each k-point.\n    mo1 : numpy.ndarray\n        First basis, rotates from the shared (AO) basis into the\n        basis of `matrix` at each k-point.\n    mo2 : numpy.ndarray\n        Second basis, rotates from the shared (AO) basis into the\n        desired basis of the output at each k-point.\n\n    Returns\n    -------\n    proj : numpy.ndarray or tuple of dyson.Lehmann\n        Matrix projected into the desired basis at each k-point.\n    \"\"\"\n\n    # Build the projection matrix\n    proj = util.einsum(\"k...pq,k...pi,k...qj-&gt;k...ij\", ovlp, np.conj(mo1), mo2)\n\n    # Project the matrix\n    if isinstance(matrix, np.ndarray):\n        projected_matrix = util.einsum(\n            \"k...pq,k...pi,k...qj-&gt;k...ij\", matrix, np.conj(proj), proj\n        )\n    else:\n        projected_matrix = []\n        for k, m in enumerate(matrix):\n            coupling = util.einsum(\"pk,pi-&gt;ik\", m.couplings, np.conj(proj[k]))\n            projected_m = m.copy()\n            projected_m.couplings = coupling\n            projected_matrix.append(projected_m)\n\n    return projected_matrix\n</code></pre>"},{"location":"reference/pbc/qsgw/#momentGW.pbc.qsgw.qsKGW.self_energy_to_moments","title":"<code>momentGW.pbc.qsgw.qsKGW.self_energy_to_moments(se, nmom_max)</code>  <code>staticmethod</code>","text":"<p>Return the hole and particle moments for a self-energy.</p> <p>Parameters:</p> Name Type Description Default <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy to compute the moments of at each k-point.</p> required <p>Returns:</p> Name Type Description <code>th</code> <code>ndarray</code> <p>Hole moments at each k-point.</p> <code>tp</code> <code>ndarray</code> <p>Particle moments at each k-point.</p> Source code in <code>momentGW/pbc/qsgw.py</code> <pre><code>@staticmethod\ndef self_energy_to_moments(se, nmom_max):\n    \"\"\"\n    Return the hole and particle moments for a self-energy.\n\n    Parameters\n    ----------\n    se : tuple of dyson.Lehmann\n        Self-energy to compute the moments of at each k-point.\n\n    Returns\n    -------\n    th : numpy.ndarray\n        Hole moments at each k-point.\n    tp : numpy.ndarray\n        Particle moments at each k-point.\n    \"\"\"\n    th = np.array([s.occupied().moment(range(nmom_max + 1)) for s in se])\n    tp = np.array([s.virtual().moment(range(nmom_max + 1)) for s in se])\n    return th, tp\n</code></pre>"},{"location":"reference/pbc/qsgw/#momentGW.pbc.qsgw.qsKGW.build_static_potential","title":"<code>momentGW.pbc.qsgw.qsKGW.build_static_potential(mo_energy, se)</code>","text":"<p>Build the static potential approximation to the self-energy.</p> <p>Parameters:</p> Name Type Description Default <code>mo_energy</code> <code>ndarray</code> <p>Molecular orbital energies at each k-point.</p> required <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy to approximate at each k-point.</p> required <p>Returns:</p> Name Type Description <code>se_qp</code> <code>ndarray</code> <p>Static potential approximation to the self-energy at each k-point.</p> Source code in <code>momentGW/pbc/qsgw.py</code> <pre><code>def build_static_potential(self, mo_energy, se):\n    \"\"\"\n    Build the static potential approximation to the self-energy.\n\n    Parameters\n    ----------\n    mo_energy : numpy.ndarray\n        Molecular orbital energies at each k-point.\n    se : tuple of dyson.Lehmann\n        Self-energy to approximate at each k-point.\n\n    Returns\n    -------\n    se_qp : numpy.ndarray\n        Static potential approximation to the self-energy at each\n        k-point.\n    \"\"\"\n    return np.array([qsGW.build_static_potential(self, mo, s) for mo, s in zip(mo_energy, se)])\n</code></pre>"},{"location":"reference/pbc/rpa/","title":"Rpa","text":"<p>Construct RPA moments with periodic boundary conditions.</p>"},{"location":"reference/pbc/rpa/#momentGW.pbc.rpa.dRPA","title":"<code>momentGW.pbc.rpa.dRPA(gw, nmom_max, integrals, mo_energy=None, mo_occ=None)</code>","text":"<p>             Bases: <code>dTDA</code>, <code>dRPA</code></p> <p>Compute the self-energy moments using dRPA and numerical integration with periodic boundary conditions.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseKGW</code> <p>GW object.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>integrals</code> <code>KIntegrals</code> <p>Density-fitted integrals at each k-point.</p> required <code>mo_energy</code> <code>dict</code> <p>Molecular orbital energies. Keys are \"g\" and \"w\" for the Green's function and screened Coulomb interaction, respectively. If <code>None</code>, use <code>gw.mo_energy</code> for both. Default value is <code>None</code>.</p> <code>None</code> <code>mo_occ</code> <code>dict</code> <p>Molecular orbital occupancies. Keys are \"g\" and \"w\" for the Green's function and screened Coulomb interaction, respectively. If <code>None</code>, use <code>gw.mo_occ</code> for both. Default value is <code>None</code>.</p> <code>None</code> Notes <p>See <code>momentGW.tda.dTDA.__init__</code> for initialisation details and <code>momentGW.tda.dTDA.kernel</code> for calculation run details.</p> Source code in <code>momentGW/tda.py</code> <pre><code>def __init__(\n    self,\n    gw,\n    nmom_max,\n    integrals,\n    mo_energy=None,\n    mo_occ=None,\n):\n    # Attributes\n    self.gw = gw\n    self.nmom_max = nmom_max\n    self.integrals = integrals\n\n    # Get the MO energies for G and W\n    if mo_energy is not None:\n        self.mo_energy_g = mo_energy[\"g\"]\n        self.mo_energy_w = mo_energy[\"w\"]\n    else:\n        self.mo_energy_g = self.mo_energy_w = gw.mo_energy\n\n    # Get the MO occupancies for G and W\n    if mo_occ is not None:\n        self.mo_occ_g = mo_occ[\"g\"]\n        self.mo_occ_w = mo_occ[\"w\"]\n    else:\n        self.mo_occ_g = self.mo_occ_w = gw.mo_occ\n\n    # Options and thresholds\n    self.report_quadrature_error = True\n    if self.gw.compression and \"ia\" in self.gw.compression.split(\",\"):\n        self.compression_tol = gw.compression_tol\n    else:\n        self.compression_tol = None\n</code></pre>"},{"location":"reference/pbc/rpa/#momentGW.pbc.rpa.dRPA.integrate","title":"<code>momentGW.pbc.rpa.dRPA.integrate()</code>","text":"<p>Optimise the quadrature and perform the integration for a given set of k-points for the zeroth moment.</p> <p>Returns:</p> Name Type Description <code>integral</code> <code>ndarray</code> <p>Integral array, including the offset part.</p> Source code in <code>momentGW/pbc/rpa.py</code> <pre><code>@logging.with_timer(\"Numerical integration\")\n@logging.with_status(\"Performing numerical integration\")\ndef integrate(self):\n    \"\"\"\n    Optimise the quadrature and perform the integration for a given\n    set of k-points for the zeroth moment.\n\n    Returns\n    -------\n    integral : numpy.ndarray\n        Integral array, including the offset part.\n    \"\"\"\n\n    # Construct the energy differences\n    d = self._build_d()\n\n    # Calculate diagonal part of ERIs\n    diag_eri = self._build_diag_eri()\n\n    # Get the offset integral quadrature\n    quad = self.optimise_offset_quad(d, diag_eri)\n\n    # Perform the offset integral\n    offset = self.eval_offset_integral(quad, d)\n\n    # Get the main integral quadrature\n    quad = self.optimise_main_quad(d, diag_eri)\n\n    # Perform the main integral\n    integral = self.eval_main_integral(quad, d)\n\n    # Report quadrature error\n    if self.report_quadrature_error:\n        a = 0.0\n        b = 0.0\n        for q in self.kpts.loop(1):\n            for ka in self.kpts.loop(1, mpi=True):\n                a += np.sum((integral[0, q, ka] - integral[2, q, ka]) ** 2)\n                b += np.sum((integral[0, q, ka] - integral[1, q, ka]) ** 2)\n        a, b = mpi_helper.allreduce(np.array([a, b]))\n        a, b = a**0.5, b**0.5\n        err = self.estimate_error_clencur(a, b)\n        style_half = logging.rate(a, 1e-4, 1e-3)\n        style_quar = logging.rate(b, 1e-8, 1e-6)\n        style_full = logging.rate(err, 1e-12, 1e-9)\n        logging.write(\n            f\"Error in integral:  [{style_full}]{err:.3e}[/] \"\n            f\"(half = [{style_half}]{a:.3e}[/], quarter = [{style_quar}]{b:.3e}[/])\",\n        )\n\n    return integral[0] + offset\n</code></pre>"},{"location":"reference/pbc/rpa/#momentGW.pbc.rpa.dRPA.build_dd_moments","title":"<code>momentGW.pbc.rpa.dRPA.build_dd_moments(integral=None)</code>","text":"<p>Build the moments of the density-density response.</p> <p>Parameters:</p> Name Type Description Default <code>integral</code> <code>ndarray</code> <p>Integral array, including the offset part. If <code>None</code>, calculate from scratch. Default is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>moments</code> <code>ndarray</code> <p>Moments of the density-density response.</p> Source code in <code>momentGW/pbc/rpa.py</code> <pre><code>@logging.with_timer(\"Density-density moments\")\n@logging.with_status(\"Constructing density-density moments\")\ndef build_dd_moments(self, integral=None):\n    \"\"\"Build the moments of the density-density response.\n\n    Parameters\n    ----------\n    integral : numpy.ndarray, optional\n        Integral array, including the offset part. If `None`,\n        calculate from scratch. Default is `None`.\n\n    Returns\n    -------\n    moments : numpy.ndarray\n        Moments of the density-density response.\n    \"\"\"\n\n    if integral is None:\n        integral = self.integrate()\n\n    kpts = self.kpts\n    Lia = self.integrals.Lia\n    moments = np.zeros((self.nkpts, self.nkpts, self.nmom_max + 1), dtype=object)\n\n    # Construct the energy differences\n    d = self._build_d()\n\n    # Calculate (L|ia) D_{ia} and (L|ia) D_{ia}^{-1} intermediates\n    Liad = self._build_Liad(Lia, d)\n    Liadinv = self._build_Liadinv(Lia, d)\n\n    for q in kpts.loop(1):\n        # Get the zeroth order moment\n        tmp = np.zeros((self.naux[q], self.naux[q]), dtype=complex)\n        inter = 0.0\n        for kj in kpts.loop(1, mpi=True):\n            kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[kj]))\n            tmp += np.dot(Liadinv[q, kb], self.integrals.Lia[kj, kb].conj().T)\n            inter += np.dot(integral[q, kb], Liadinv[q, kb].T.conj())\n        tmp = mpi_helper.allreduce(tmp)\n        inter = mpi_helper.allreduce(inter)\n        tmp *= 2.0\n        u = np.linalg.inv(np.eye(tmp.shape[0]) * self.nkpts / 2 + tmp)\n\n        rest = np.dot(inter, u) * self.nkpts / 2\n        for ki in kpts.loop(1, mpi=True):\n            ka = kpts.member(kpts.wrap_around(kpts[q] + kpts[ki]))\n            moments[q, ka, 0] = integral[q, ka] / d[q, ka] * self.nkpts / 2\n            moments[q, ka, 0] -= np.dot(rest, Liadinv[q, ka]) * 2\n\n    # Get the first order moment\n    moments[:, :, 1] = Liad / self.nkpts\n\n    # Get the higher order moments\n    for i in range(2, self.nmom_max + 1):\n        for q in kpts.loop(1):\n            tmp = 0.0\n            for ka in kpts.loop(1, mpi=True):\n                kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[ka]))\n                moments[q, kb, i] = moments[q, kb, i - 2] * d[q, kb] ** 2\n                tmp += np.dot(moments[q, kb, i - 2], self.integrals.Lia[ka, kb].conj().T)\n            tmp = mpi_helper.allreduce(tmp)\n            tmp /= self.nkpts\n            tmp *= 2\n            for ki in kpts.loop(1, mpi=True):\n                ka = kpts.member(kpts.wrap_around(kpts[q] + kpts[ki]))\n                moments[q, ka, i] += np.dot(tmp, Liad[q, ka]) * 2\n\n    return moments\n</code></pre>"},{"location":"reference/pbc/rpa/#momentGW.pbc.rpa.dRPA.optimise_offset_quad","title":"<code>momentGW.pbc.rpa.dRPA.optimise_offset_quad(d, diag_eri, name='main')</code>","text":"<p>Optimise the grid spacing of Gauss-Laguerre quadrature for the offset integral.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>ndarray</code> <p>Orbital energy differences at each k-point.</p> required <code>diag_eri</code> <code>ndarray</code> <p>Diagonal of the ERIs at each k-point.</p> required <code>name</code> <code>str</code> <p>Name of the integral. Default value is <code>\"main\"</code>.</p> <code>'main'</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>The quadrature points.</p> <code>weights</code> <code>ndarray</code> <p>The quadrature weights.</p> Source code in <code>momentGW/pbc/rpa.py</code> <pre><code>def optimise_offset_quad(self, d, diag_eri, name=\"main\"):\n    \"\"\"\n    Optimise the grid spacing of Gauss-Laguerre quadrature for the\n    offset integral.\n\n    Parameters\n    ----------\n    d : numpy.ndarray\n        Orbital energy differences at each k-point.\n    diag_eri : numpy.ndarray\n        Diagonal of the ERIs at each k-point.\n    name : str, optional\n        Name of the integral. Default value is `\"main\"`.\n\n    Returns\n    -------\n    points : numpy.ndarray\n        The quadrature points.\n    weights : numpy.ndarray\n        The quadrature weights.\n    \"\"\"\n\n    # Generate the bare quadrature\n    bare_quad = self.gen_gausslag_quad_semiinf()\n\n    # Calculate the exact value of the integral for the diagonal\n    exact = 0.0\n    for q in self.kpts.loop(1):\n        for ki in self.kpts.loop(1, mpi=True):\n            ka = self.kpts.member(self.kpts.wrap_around(self.kpts[q] + self.kpts[ki]))\n            exact += np.dot(1.0 / d[q, ka], d[q, ka] * diag_eri[q, ka])\n    exact = mpi_helper.allreduce(exact)\n\n    # Define the integrand\n    integrand = lambda quad: self.eval_diag_offset_integral(quad, d, diag_eri)\n\n    # Get the optimal quadrature\n    quad = self.get_optimal_quad(bare_quad, integrand, exact, name=name)\n\n    return quad\n</code></pre>"},{"location":"reference/pbc/rpa/#momentGW.pbc.rpa.dRPA.eval_diag_offset_integral","title":"<code>momentGW.pbc.rpa.dRPA.eval_diag_offset_integral(quad, d, diag_eri)</code>","text":"<p>Evaluate the diagonal of the offset integral.</p> <p>Parameters:</p> Name Type Description Default <code>quad</code> <code>tuple</code> <p>The quadrature points and weights.</p> required <code>d</code> <code>ndarray</code> <p>Orbital energy differences at each k-point.</p> required <code>diag_eri</code> <code>ndarray</code> <p>Diagonal of the ERIs at each k-point.</p> required <p>Returns:</p> Name Type Description <code>integral</code> <code>ndarray</code> <p>Offset integral.</p> Source code in <code>momentGW/pbc/rpa.py</code> <pre><code>def eval_diag_offset_integral(self, quad, d, diag_eri):\n    \"\"\"Evaluate the diagonal of the offset integral.\n\n    Parameters\n    ----------\n    quad : tuple\n        The quadrature points and weights.\n    d : numpy.ndarray\n        Orbital energy differences at each k-point.\n    diag_eri : numpy.ndarray\n        Diagonal of the ERIs at each k-point.\n\n    Returns\n    -------\n    integral : numpy.ndarray\n        Offset integral.\n    \"\"\"\n\n    # Calculate the integral for each point\n    integral = 0.0\n    for point, weight in zip(*quad):\n        for q in self.kpts.loop(1):\n            for ki in self.kpts.loop(1, mpi=True):\n                ka = self.kpts.member(self.kpts.wrap_around(self.kpts[q] + self.kpts[ki]))\n                tmp = d[q, ka] * diag_eri[q, ka]\n                expval = np.exp(-2 * point * d[q, ka])\n                res = np.dot(expval, tmp)\n                integral += 2 * res * weight\n    integral = mpi_helper.allreduce(integral)\n\n    return integral\n</code></pre>"},{"location":"reference/pbc/rpa/#momentGW.pbc.rpa.dRPA.eval_offset_integral","title":"<code>momentGW.pbc.rpa.dRPA.eval_offset_integral(quad, d, Lia=None)</code>","text":"<p>Evaluate the offset integral.</p> <p>Parameters:</p> Name Type Description Default <code>quad</code> <code>tuple</code> <p>The quadrature points and weights.</p> required <code>d</code> <code>ndarray</code> <p>Orbital energy differences at each k-point.</p> required <code>Lia</code> <code>dict of numpy.ndarray</code> <p>Dict. with keys that are pairs of k-point indices (Nkpt, Nkpt) with an array of form (aux, W occ, W vir) at this k-point pair. The 1st Nkpt is defined by the difference between k-points and the second index's kpoint. If <code>None</code>, use <code>self.integrals.Lia</code>.</p> <code>None</code> <code>Liad</code> <code>dict of numpy.ndarray</code> <p>Product of Lia and the orbital energy differences at each k-point.</p> required <p>Returns:</p> Name Type Description <code>integral</code> <code>ndarray</code> <p>Offset integral.</p> Source code in <code>momentGW/pbc/rpa.py</code> <pre><code>def eval_offset_integral(self, quad, d, Lia=None):\n    \"\"\"Evaluate the offset integral.\n\n    Parameters\n    ----------\n    quad : tuple\n        The quadrature points and weights.\n    d : numpy.ndarray\n        Orbital energy differences at each k-point.\n    Lia : dict of numpy.ndarray\n        Dict. with keys that are pairs of k-point indices (Nkpt, Nkpt)\n        with an array of form (aux, W occ, W vir) at this k-point pair.\n        The 1st Nkpt is defined by the difference between k-points and\n        the second index's kpoint. If `None`, use `self.integrals.Lia`.\n    Liad : dict of numpy.ndarray\n        Product of Lia and the orbital energy differences at each\n        k-point.\n\n\n    Returns\n    -------\n    integral : numpy.ndarray\n        Offset integral.\n    \"\"\"\n\n    # Get the integral intermediates\n    if Lia is None:\n        Lia = self.integrals.Lia\n    Liad = self._build_Liad(Lia, d)\n    integrals = 2 * Liad / (self.nkpts**2)\n\n    kpts = self.kpts\n\n    # Calculate the integral for each point\n    for point, weight in zip(*quad):\n        for q in kpts.loop(1):\n            lhs = 0.0\n            for ka in kpts.loop(1, mpi=True):\n                kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[ka]))\n                expval = np.exp(-point * d[q, kb])\n                lhs += np.dot(Liad[q, kb] * expval[None], Lia[ka, kb].T.conj())\n            lhs = mpi_helper.allreduce(lhs)\n            lhs /= self.nkpts\n            lhs *= 2\n\n            for ka in kpts.loop(1, mpi=True):\n                kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[ka]))\n                rhs = self.integrals.Lia[ka, kb] * np.exp(-point * d[q, kb])\n                rhs /= self.nkpts**2\n                res = np.dot(lhs, rhs)\n                integrals[q, kb] += res * weight * 4\n\n    return integrals\n</code></pre>"},{"location":"reference/pbc/rpa/#momentGW.pbc.rpa.dRPA.optimise_main_quad","title":"<code>momentGW.pbc.rpa.dRPA.optimise_main_quad(d, diag_eri, name='main')</code>","text":"<p>Optimise the grid spacing of Clenshaw-Curtis quadrature for the main integral.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>ndarray</code> <p>Orbital energy differences at each k-point.</p> required <code>diag_eri</code> <code>ndarray</code> <p>Diagonal of the ERIs at each k-point.</p> required <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>The quadrature points.</p> <code>weights</code> <code>ndarray</code> <p>The quadrature weights.</p> Source code in <code>momentGW/pbc/rpa.py</code> <pre><code>def optimise_main_quad(self, d, diag_eri, name=\"main\"):\n    \"\"\"\n    Optimise the grid spacing of Clenshaw-Curtis quadrature for the\n    main integral.\n\n    Parameters\n    ----------\n    d : numpy.ndarray\n        Orbital energy differences at each k-point.\n    diag_eri : numpy.ndarray\n        Diagonal of the ERIs at each k-point.\n\n    Returns\n    -------\n    points : numpy.ndarray\n        The quadrature points.\n    weights : numpy.ndarray\n        The quadrature weights.\n    \"\"\"\n\n    # Generate the bare quadrature\n    bare_quad = self.gen_clencur_quad_inf(even=True)\n\n    # Calculate the exact value of the integral for the diagonal\n    exact = 0.0\n    d_sq = np.zeros((self.nkpts, self.nkpts), dtype=object)\n    d_eri = np.zeros((self.nkpts, self.nkpts), dtype=object)\n    d_sq_eri = np.zeros((self.nkpts, self.nkpts), dtype=object)\n    for q in self.kpts.loop(1):\n        for kj in self.kpts.loop(1, mpi=True):\n            kb = self.kpts.member(self.kpts.wrap_around(self.kpts[q] + self.kpts[kj]))\n            exact += np.sum((d[q, kb] * (d[q, kb] + diag_eri[q, kb])) ** 0.5)\n            exact -= 0.5 * np.dot(1.0 / d[q, kb], d[q, kb] * diag_eri[q, kb])\n            exact -= np.sum(d[q, kb])\n            d_sq[q, kb] = d[q, kb] ** 2\n            d_eri[q, kb] = d[q, kb] * diag_eri[q, kb]\n            d_sq_eri[q, kb] = d[q, kb] * (d[q, kb] + diag_eri[q, kb])\n    exact = mpi_helper.allreduce(exact)\n\n    # Define the integrand\n    integrand = lambda quad: self.eval_diag_main_integral(quad, d, d_sq, d_eri, d_sq_eri)\n\n    # Get the optimal quadrature\n    quad = self.get_optimal_quad(bare_quad, integrand, exact, name=name)\n\n    return quad\n</code></pre>"},{"location":"reference/pbc/rpa/#momentGW.pbc.rpa.dRPA.eval_diag_main_integral","title":"<code>momentGW.pbc.rpa.dRPA.eval_diag_main_integral(quad, d, d_sq, d_eri, d_sq_eri)</code>","text":"<p>Evaluate the diagonal of the main integral.</p> <p>Parameters:</p> Name Type Description Default <code>quad</code> <code>tuple</code> <p>The quadrature points and weights.</p> required <code>d</code> <code>ndarray</code> <p>Orbital energy differences at each k-point.</p> required <code>d_sq</code> <code>ndarray</code> <p>Orbital energy differences squared at each k-point. See \"optimise_main_quad\" for more details.</p> required <code>d_eri</code> <code>ndarray</code> <p>Orbital energy differences times the diagonal of the ERIs at each k-point. See \"optimise_main_quad\" for more details.</p> required <code>d_sq_eri</code> <code>ndarray</code> <p>Orbital energy differences times the diagonal of the ERIs plus the orbital energy differences at each k-point. See \"optimise_main_quad\" for more details.</p> required <p>Returns:</p> Name Type Description <code>integral</code> <code>ndarray</code> <p>Main integral.</p> Source code in <code>momentGW/pbc/rpa.py</code> <pre><code>def eval_diag_main_integral(self, quad, d, d_sq, d_eri, d_sq_eri):\n    \"\"\"Evaluate the diagonal of the main integral.\n\n    Parameters\n    ----------\n    quad : tuple\n        The quadrature points and weights.\n    d : numpy.ndarray\n        Orbital energy differences at each k-point.\n    d_sq : numpy.ndarray\n        Orbital energy differences squared at each k-point.\n        See \"optimise_main_quad\" for more details.\n    d_eri : numpy.ndarray\n        Orbital energy differences times the diagonal of the\n        ERIs at each k-point.\n        See \"optimise_main_quad\" for more details.\n    d_sq_eri : numpy.ndarray\n        Orbital energy differences times the diagonal of the ERIs plus\n        the orbital energy differences at each k-point.\n        See \"optimise_main_quad\" for more details.\n\n    Returns\n    -------\n    integral : numpy.ndarray\n        Main integral.\n    \"\"\"\n\n    integral = 0.0\n\n    def diag_contrib(x, freq):\n        integral = x / (x + freq**2)\n        integral /= np.pi\n        return integral\n\n    # Calculate the integral for each point\n    for point, weight in zip(*quad):\n        contrib = 0.0\n        for q in self.kpts.loop(1):\n            for kj in self.kpts.loop(1, mpi=True):\n                kb = self.kpts.member(self.kpts.wrap_around(self.kpts[q] + self.kpts[kj]))\n                contrib_int = diag_contrib(d_sq_eri[q, kb], point)\n                contrib_int -= diag_contrib(d_sq[q, kb], point)\n                contrib += np.abs(np.sum(contrib_int))\n\n                f_sq = 1.0 / (d[q, kb] ** 2 + point**2) ** 2\n                contrib -= np.abs(point**2 * np.dot(f_sq, d_eri[q, kb]) / np.pi)\n\n        integral += weight * contrib\n\n    integral = mpi_helper.allreduce(integral)\n\n    return integral\n</code></pre>"},{"location":"reference/pbc/rpa/#momentGW.pbc.rpa.dRPA.eval_main_integral","title":"<code>momentGW.pbc.rpa.dRPA.eval_main_integral(quad, d, Lia=None)</code>","text":"<p>Evaluate the main integral.</p> <p>Parameters:</p> Name Type Description Default <code>quad</code> <code>tuple</code> <p>The quadrature points and weights.</p> required Variables <p>d : numpy.ndarray     Orbital energy differences at each k-point. Lia : dict of numpy.ndarray     Dict. with keys that are pairs of k-point indices (Nkpt, Nkpt)     with an array of form (aux, W occ, W vir) at this k-point pair.     The 1st Nkpt is defined by the difference between k-points and     the second index's kpoint. If <code>None</code>, use <code>self.integrals.Lia</code>. Liad : dict of numpy.ndarray     Product of Lia and the orbital energy differences at each     k-point.</p> <p>Returns:</p> Name Type Description <code>integral</code> <code>ndarray</code> <p>Offset integral.</p> Source code in <code>momentGW/pbc/rpa.py</code> <pre><code>def eval_main_integral(self, quad, d, Lia=None):\n    \"\"\"Evaluate the main integral.\n\n    Parameters\n    ----------\n    quad : tuple\n        The quadrature points and weights.\n\n    Variables\n    ----------\n    d : numpy.ndarray\n        Orbital energy differences at each k-point.\n    Lia : dict of numpy.ndarray\n        Dict. with keys that are pairs of k-point indices (Nkpt, Nkpt)\n        with an array of form (aux, W occ, W vir) at this k-point pair.\n        The 1st Nkpt is defined by the difference between k-points and\n        the second index's kpoint. If `None`, use `self.integrals.Lia`.\n    Liad : dict of numpy.ndarray\n        Product of Lia and the orbital energy differences at each\n        k-point.\n\n    Returns\n    -------\n    integral : numpy.ndarray\n        Offset integral.\n    \"\"\"\n\n    # Get the integral intermediates\n    if Lia is None:\n        Lia = self.integrals.Lia\n    Liad = self._build_Liad(Lia, d)\n\n    # Initialise the integral\n    dim = 3 if self.report_quadrature_error else 1\n    integral = np.zeros((dim, self.nkpts, self.nkpts), dtype=object)\n\n    # Calculate the integral for each point\n    kpts = self.kpts\n    for i, (point, weight) in enumerate(zip(*quad)):\n        contrib = np.zeros_like(d, dtype=object)\n\n        for q in kpts.loop(1):\n            f = np.zeros((self.nkpts), dtype=object)\n            qz = 0.0\n            for ki in kpts.loop(1, mpi=True):\n                kj = kpts.member(kpts.wrap_around(kpts[q] + kpts[ki]))\n                f[kj] = 1.0 / (d[q, kj] ** 2 + point**2)\n                pre = (Lia[ki, kj] * f[kj]) * (4 / self.nkpts)\n                qz += np.dot(pre, Liad[q, kj].T.conj())\n            qz = mpi_helper.allreduce(qz)\n\n            tmp = np.linalg.inv(np.eye(self.naux[q]) + qz) - np.eye(self.naux[q])\n            inner = np.dot(qz, tmp)\n\n            for ka in kpts.loop(1, mpi=True):\n                kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[ka]))\n                contrib[q, kb] = 2 * np.dot(inner, Lia[ka, kb]) / (self.nkpts**2)\n                value = weight * (contrib[q, kb] * f[kb] * (point**2 / np.pi))\n\n                integral[0, q, kb] += value\n                if i % 2 == 0 and self.report_quadrature_error:\n                    integral[1, q, kb] += 2 * value\n                if i % 4 == 0 and self.report_quadrature_error:\n                    integral[2, q, kb] += 4 * value\n\n    return integral\n</code></pre>"},{"location":"reference/pbc/scgw/","title":"Scgw","text":"<p>Spin-restricted self-consistent GW via self-energy moment constraitns for periodic systems.</p>"},{"location":"reference/pbc/scgw/#momentGW.pbc.scgw.scKGW","title":"<code>momentGW.pbc.scgw.scKGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>KGW</code>, <code>scGW</code></p> <p>Spin-restricted self-consistent GW via self-energy moment constraints for periodic systems.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>KSCF</code> <p>PySCF periodic mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>fc</code> <code>bool</code> <p>If <code>True</code>, apply finite size corrections. Default value is <code>False</code>.</p> required <code>g0</code> <code>bool</code> <p>If <code>True</code>, do not self-consistently update the eigenvalues in the Green's function. Default value is <code>False</code>.</p> required <code>w0</code> <code>bool</code> <p>If <code>True</code>, do not self-consistently update the eigenvalues in the screened Coulomb interaction. Default value is <code>False</code>.</p> required <code>max_cycle</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>50</code>.</p> required <code>conv_tol</code> <code>float</code> <p>Convergence threshold in the change in the HOMO and LUMO. Default value is <code>1e-8</code>.</p> required <code>conv_tol_moms</code> <code>float</code> <p>Convergence threshold in the change in the moments. Default value is <code>1e-8</code>.</p> required <code>diis_space</code> <code>int</code> <p>Size of the DIIS extrapolation space. Default value is <code>8</code>.</p> required <code>damping</code> <code>float</code> <p>Damping parameter. Default value is <code>0.0</code>.</p> required Source code in <code>momentGW/pbc/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Options\n    self.fc = False\n\n    # Attributes\n    self._kpts = KPoints(self.cell, getattr(mf, \"kpts\", np.zeros((1, 3))))\n</code></pre>"},{"location":"reference/pbc/scgw/#momentGW.pbc.scgw.scKGW.name","title":"<code>momentGW.pbc.scgw.scKGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/pbc/tda/","title":"Tda","text":"<p>Construct TDA moments with periodic boundary conditions.</p>"},{"location":"reference/pbc/tda/#momentGW.pbc.tda.dTDA","title":"<code>momentGW.pbc.tda.dTDA(gw, nmom_max, integrals, mo_energy=None, mo_occ=None)</code>","text":"<p>             Bases: <code>dTDA</code></p> <p>Compute the self-energy moments using dTDA with periodic boundary conditions.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseKGW</code> <p>GW object.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>integrals</code> <code>KIntegrals</code> <p>Density-fitted integrals at each k-point.</p> required <code>mo_energy</code> <code>dict</code> <p>Molecular orbital energies at each k-point. Keys are \"g\" and \"w\" for the Green's function and screened Coulomb interaction, respectively. If <code>None</code>, use <code>gw.mo_energy</code> for both. Default value is <code>None</code>.</p> <code>None</code> <code>mo_occ</code> <code>dict</code> <p>Molecular orbital occupancies at each k-point. Keys are \"g\" and \"w\" for the Green's function and screened Coulomb interaction, respectively. If <code>None</code>, use <code>gw.mo_occ</code> for both. Default value is <code>None</code>.</p> <code>None</code> Source code in <code>momentGW/tda.py</code> <pre><code>def __init__(\n    self,\n    gw,\n    nmom_max,\n    integrals,\n    mo_energy=None,\n    mo_occ=None,\n):\n    # Attributes\n    self.gw = gw\n    self.nmom_max = nmom_max\n    self.integrals = integrals\n\n    # Get the MO energies for G and W\n    if mo_energy is not None:\n        self.mo_energy_g = mo_energy[\"g\"]\n        self.mo_energy_w = mo_energy[\"w\"]\n    else:\n        self.mo_energy_g = self.mo_energy_w = gw.mo_energy\n\n    # Get the MO occupancies for G and W\n    if mo_occ is not None:\n        self.mo_occ_g = mo_occ[\"g\"]\n        self.mo_occ_w = mo_occ[\"w\"]\n    else:\n        self.mo_occ_g = self.mo_occ_w = gw.mo_occ\n\n    # Options and thresholds\n    self.report_quadrature_error = True\n    if self.gw.compression and \"ia\" in self.gw.compression.split(\",\"):\n        self.compression_tol = gw.compression_tol\n    else:\n        self.compression_tol = None\n</code></pre>"},{"location":"reference/pbc/tda/#momentGW.pbc.tda.dTDA.nov","title":"<code>momentGW.pbc.tda.dTDA.nov</code>  <code>property</code>","text":"<p>Get the number of ov states in W.</p>"},{"location":"reference/pbc/tda/#momentGW.pbc.tda.dTDA.kpts","title":"<code>momentGW.pbc.tda.dTDA.kpts</code>  <code>property</code>","text":"<p>Get the k-points.</p>"},{"location":"reference/pbc/tda/#momentGW.pbc.tda.dTDA.nkpts","title":"<code>momentGW.pbc.tda.dTDA.nkpts</code>  <code>property</code>","text":"<p>Get the number of k-points.</p>"},{"location":"reference/pbc/tda/#momentGW.pbc.tda.dTDA.build_dd_moments","title":"<code>momentGW.pbc.tda.dTDA.build_dd_moments()</code>","text":"<p>Build the moments of the density-density response.</p> <p>Returns:</p> Name Type Description <code>moments</code> <code>ndarray</code> <p>Moments of the density-density response at each k-point.</p> Source code in <code>momentGW/pbc/tda.py</code> <pre><code>@logging.with_timer(\"Density-density moments\")\n@logging.with_status(\"Constructing density-density moments\")\ndef build_dd_moments(self):\n    \"\"\"Build the moments of the density-density response.\n\n    Returns\n    -------\n    moments : numpy.ndarray\n        Moments of the density-density response at each k-point.\n    \"\"\"\n\n    # Initialise the moments\n    kpts = self.kpts\n    moments = np.zeros((self.nkpts, self.nkpts, self.nmom_max + 1), dtype=object)\n\n    # Get the zeroth order moment\n    for q in kpts.loop(1):\n        for kj in kpts.loop(1, mpi=True):\n            kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[kj]))\n            moments[q, kb, 0] += self.integrals.Lia[kj, kb] / self.nkpts\n\n    # Get the higher order moments\n    for i in range(1, self.nmom_max + 1):\n        for q in kpts.loop(1):\n            for kj in kpts.loop(1, mpi=True):\n                kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[kj]))\n\n                d = util.build_1h1p_energies(\n                    (self.mo_energy_w[kj], self.mo_energy_w[kb]),\n                    (self.mo_occ_w[kj], self.mo_occ_w[kb]),\n                )\n                moments[q, kb, i] += moments[q, kb, i - 1] * d.ravel()[None]\n\n            tmp = np.zeros((self.naux[q], self.naux[q]), dtype=complex)\n            for ki in kpts.loop(1, mpi=True):\n                ka = kpts.member(kpts.wrap_around(kpts[q] + kpts[ki]))\n\n                tmp += np.dot(moments[q, ka, i - 1], self.integrals.Lia[ki, ka].T.conj())\n\n            tmp = mpi_helper.allreduce(tmp)\n            tmp *= 2.0\n            tmp /= self.nkpts\n\n            for kj in kpts.loop(1, mpi=True):\n                kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[kj]))\n\n                moments[q, kb, i] += np.dot(tmp, self.integrals.Lai[kj, kb].conj())\n\n    return moments\n</code></pre>"},{"location":"reference/pbc/tda/#momentGW.pbc.tda.dTDA.kernel","title":"<code>momentGW.pbc.tda.dTDA.kernel(exact=False)</code>","text":"<p>Run the polarizability calculation to compute moments of the self-energy.</p> <p>Parameters:</p> Name Type Description Default <code>exact</code> <code>bool</code> <p>Has no effect and is only present for compatibility with <code>dRPA</code>. Default value is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>moments_occ</code> <code>ndarray</code> <p>Moments of the occupied self-energy at each k-point.</p> <code>moments_vir</code> <code>ndarray</code> <p>Moments of the virtual self-energy at each k-point.</p> Source code in <code>momentGW/pbc/tda.py</code> <pre><code>def kernel(self, exact=False):\n    \"\"\"\n    Run the polarizability calculation to compute moments of the\n    self-energy.\n\n    Parameters\n    ----------\n    exact : bool, optional\n        Has no effect and is only present for compatibility with\n        `dRPA`. Default value is `False`.\n\n    Returns\n    -------\n    moments_occ : numpy.ndarray\n        Moments of the occupied self-energy at each k-point.\n    moments_vir : numpy.ndarray\n        Moments of the virtual self-energy at each k-point.\n    \"\"\"\n    return super().kernel(exact=exact)\n</code></pre>"},{"location":"reference/pbc/tda/#momentGW.pbc.tda.dTDA.convolve","title":"<code>momentGW.pbc.tda.dTDA.convolve(eta, mo_energy_g=None, mo_occ_g=None)</code>","text":"<p>Handle the convolution of the moments of the Green's function and screened Coulomb interaction.</p> <p>Parameters:</p> Name Type Description Default <code>eta</code> <code>ndarray</code> <p>Moments of the density-density response partly transformed into moments of the screened Coulomb interaction at each k-point.</p> required <code>mo_energy_g</code> <code>ndarray</code> <p>Energies of the Green's function at each k-point. If <code>None</code>, use <code>self.mo_energy_g</code>. Default value is <code>None</code>.</p> <code>None</code> <code>mo_occ_g</code> <code>ndarray</code> <p>Occupancies of the Green's function at each k-point. If <code>None</code>, use <code>self.mo_occ_g</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>moments_occ</code> <code>ndarray</code> <p>Moments of the occupied self-energy at each k-point.</p> <code>moments_vir</code> <code>ndarray</code> <p>Moments of the virtual self-energy at each k-point.</p> Source code in <code>momentGW/pbc/tda.py</code> <pre><code>@logging.with_timer(\"Moment convolution\")\n@logging.with_status(\"Convoluting moments\")\ndef convolve(self, eta, mo_energy_g=None, mo_occ_g=None):\n    \"\"\"\n    Handle the convolution of the moments of the Green's function\n    and screened Coulomb interaction.\n\n    Parameters\n    ----------\n    eta : numpy.ndarray\n        Moments of the density-density response partly transformed\n        into moments of the screened Coulomb interaction at each\n        k-point.\n    mo_energy_g : numpy.ndarray, optional\n        Energies of the Green's function at each k-point. If\n        `None`, use `self.mo_energy_g`. Default value is `None`.\n    mo_occ_g : numpy.ndarray, optional\n        Occupancies of the Green's function at each k-point. If\n        `None`, use `self.mo_occ_g`. Default value is `None`.\n\n    Returns\n    -------\n    moments_occ : numpy.ndarray\n        Moments of the occupied self-energy at each k-point.\n    moments_vir : numpy.ndarray\n        Moments of the virtual self-energy at each k-point.\n    \"\"\"\n\n    # Get the orbitals\n    if mo_energy_g is None:\n        mo_energy_g = self.mo_energy_g\n    if mo_occ_g is None:\n        mo_occ_g = self.mo_occ_g\n    kpts = self.kpts\n\n    # Setup dependent on diagonal SE\n    if self.gw.diagonal_se:\n        pqchar = \"p\"\n        fproc = lambda x: np.diag(x)\n    else:\n        pqchar = \"pq\"\n        fproc = lambda x: x\n\n    # We avoid self.nmo for inheritence reasons, but in MPI eta is\n    # sparse, hence this weird code\n    for part in eta.ravel():\n        if isinstance(part, np.ndarray):\n            nmo = part.shape[-1]\n            break\n\n    # Initialise the moments\n    moments_occ = np.zeros((self.nkpts, self.nmom_max + 1, nmo, nmo), dtype=complex)\n    moments_vir = np.zeros((self.nkpts, self.nmom_max + 1, nmo, nmo), dtype=complex)\n\n    moms = np.arange(self.nmom_max + 1)\n    for n in moms:\n        # Get the binomial coefficients\n        fp = scipy.special.binom(n, moms)\n        fh = fp * (-1) ** moms\n\n        for q in kpts.loop(1):\n            for kp in kpts.loop(1, mpi=True):\n                kx = kpts.member(kpts.wrap_around(kpts[kp] - kpts[q]))\n                subscript = f\"t,kt,kt{pqchar}-&gt;{pqchar}\"\n\n                # Construct the occupied moments for this order\n                eo = np.power.outer(mo_energy_g[kx][mo_occ_g[kx] &gt; 0], n - moms)\n                to = util.einsum(subscript, fh, eo, eta[kp, q][mo_occ_g[kx] &gt; 0])\n                moments_occ[kp, n] += fproc(to)\n\n                # Construct the virtual moments for this order\n                ev = np.power.outer(mo_energy_g[kx][mo_occ_g[kx] == 0], n - moms)\n                tv = util.einsum(subscript, fp, ev, eta[kp, q][mo_occ_g[kx] == 0])\n                moments_vir[kp, n] += fproc(tv)\n\n    # Numerical integration can lead to small non-hermiticity\n    for n in range(self.nmom_max + 1):\n        for k in kpts.loop(1, mpi=True):\n            moments_occ[k, n] = 0.5 * (moments_occ[k, n] + moments_occ[k, n].T.conj())\n            moments_vir[k, n] = 0.5 * (moments_vir[k, n] + moments_vir[k, n].T.conj())\n\n    # Sum over all processes\n    moments_occ = mpi_helper.allreduce(moments_occ)\n    moments_vir = mpi_helper.allreduce(moments_vir)\n\n    return moments_occ, moments_vir\n</code></pre>"},{"location":"reference/pbc/tda/#momentGW.pbc.tda.dTDA.build_se_moments","title":"<code>momentGW.pbc.tda.dTDA.build_se_moments(moments_dd)</code>","text":"<p>Build the moments of the self-energy via convolution.</p> <p>Parameters:</p> Name Type Description Default <code>moments_dd</code> <code>ndarray</code> <p>Moments of the density-density response at each k-point.</p> required <p>Returns:</p> Name Type Description <code>moments_occ</code> <code>ndarray</code> <p>Moments of the occupied self-energy at each k-point.</p> <code>moments_vir</code> <code>ndarray</code> <p>Moments of the virtual self-energy at each k-point.</p> Source code in <code>momentGW/pbc/tda.py</code> <pre><code>@logging.with_timer(\"Self-energy moments\")\n@logging.with_status(\"Constructing self-energy moments\")\ndef build_se_moments(self, moments_dd):\n    \"\"\"Build the moments of the self-energy via convolution.\n\n    Parameters\n    ----------\n    moments_dd : numpy.ndarray\n        Moments of the density-density response at each k-point.\n\n    Returns\n    -------\n    moments_occ : numpy.ndarray\n        Moments of the occupied self-energy at each k-point.\n    moments_vir : numpy.ndarray\n        Moments of the virtual self-energy at each k-point.\n    \"\"\"\n\n    kpts = self.kpts\n\n    # Setup dependent on diagonal SE\n    if self.gw.diagonal_se:\n        pqchar = pchar = qchar = \"p\"\n        eta_shape = lambda k: (self.mo_energy_g[k].size, self.nmom_max + 1, self.nmo)\n    else:\n        pqchar, pchar, qchar = \"pq\", \"p\", \"q\"\n        eta_shape = lambda k: (self.mo_energy_g[k].size, self.nmom_max + 1, self.nmo, self.nmo)\n    eta = np.zeros((self.nkpts, self.nkpts), dtype=object)\n\n    # Get the moments in (aux|aux) and rotate to (mo|mo)\n    for n in range(self.nmom_max + 1):\n        for q in kpts.loop(1):\n            eta_aux = 0\n            for kj in kpts.loop(1, mpi=True):\n                kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[kj]))\n                eta_aux += np.dot(moments_dd[q, kb, n], self.integrals.Lia[kj, kb].T.conj())\n\n            eta_aux = mpi_helper.allreduce(eta_aux)\n            eta_aux *= 2.0\n            eta_aux /= self.nkpts\n\n            for kp in kpts.loop(1, mpi=True):\n                kx = kpts.member(kpts.wrap_around(kpts[kp] - kpts[q]))\n\n                if not isinstance(eta[kp, q], np.ndarray):\n                    eta[kp, q] = np.zeros(eta_shape(kx), dtype=eta_aux.dtype)\n\n                for x in range(self.mo_energy_g[kx].size):\n                    Lp = self.integrals.Lpx[kp, kx][:, :, x]\n                    subscript = f\"P{pchar},Q{qchar},PQ-&gt;{pqchar}\"\n                    eta[kp, q][x, n] += util.einsum(subscript, Lp, Lp.conj(), eta_aux)\n\n    # Construct the self-energy moments\n    moments_occ, moments_vir = self.convolve(eta)\n\n    return moments_occ, moments_vir\n</code></pre>"},{"location":"reference/pbc/thc/","title":"Thc","text":"<p>Tensor hyper-contraction with periodic boundary conditions.</p>"},{"location":"reference/pbc/thc/#momentGW.pbc.thc.KIntegrals","title":"<code>momentGW.pbc.thc.KIntegrals(with_df, kpts, mo_coeff, mo_occ, file_path=None, store_full=False)</code>","text":"<p>             Bases: <code>Integrals</code>, <code>KIntegrals</code></p> <p>Container for the tensor-hypercontracted integrals required for GW methods with periodic boundary conditions.</p> <p>Parameters:</p> Name Type Description Default <code>with_df</code> <code>DF</code> <p>Density fitting object.</p> required <code>mo_coeff</code> <code>ndarray</code> <p>Molecular orbital coefficients at each k-point.</p> required <code>mo_occ</code> <code>ndarray</code> <p>Molecular orbital occupations at each k-point.</p> required <code>file_path</code> <code>str</code> <p>Path to the HDF5 file containing the integrals. Default value is <code>None</code>.</p> <code>None</code> Source code in <code>momentGW/pbc/thc.py</code> <pre><code>def __init__(\n    self,\n    with_df,\n    kpts,\n    mo_coeff,\n    mo_occ,\n    file_path=None,\n    store_full=False,\n):\n    Integrals.__init__(\n        self,\n        with_df,\n        mo_coeff,\n        mo_occ,\n        file_path=file_path,\n    )\n\n    # Parameters\n    self.kpts = kpts\n    self.store_full = store_full\n\n    # Options\n    self.compression = None\n\n    # Attributes\n    self._madelung = None\n</code></pre>"},{"location":"reference/pbc/thc/#momentGW.pbc.thc.KIntegrals.nkpts","title":"<code>momentGW.pbc.thc.KIntegrals.nkpts</code>  <code>property</code>","text":"<p>Get the number of k-points</p>"},{"location":"reference/pbc/thc/#momentGW.pbc.thc.KIntegrals.naux","title":"<code>momentGW.pbc.thc.KIntegrals.naux</code>  <code>property</code>","text":"<p>Get the number of auxiliary basis functions.</p>"},{"location":"reference/pbc/thc/#momentGW.pbc.thc.KIntegrals.import_thc_components","title":"<code>momentGW.pbc.thc.KIntegrals.import_thc_components()</code>","text":"<p>Import a HDF5 file containing a dictionary. The keys <code>\"collocation_matrix\"</code> and a <code>\"coulomb_matrix\"</code> must exist, with shapes <code>(MO, aux)</code> and <code>(aux, aux)</code>, respectively.</p> Source code in <code>momentGW/pbc/thc.py</code> <pre><code>def import_thc_components(self):\n    \"\"\"\n    Import a HDF5 file containing a dictionary. The keys\n    `\"collocation_matrix\"` and a `\"coulomb_matrix\"` must exist, with\n    shapes ``(MO, aux)`` and ``(aux, aux)``, respectively.\n    \"\"\"\n\n    if self.file_path is None:\n        raise ValueError(\"file path cannot be None for THC implementation\")\n\n    thc_eri = h5py.File(self.file_path, \"r\")\n\n    kpts_imp = np.array(thc_eri[\"kpts\"])\n\n    if kpts_imp.shape[0] != len(self.kpts):\n        raise ValueError(\"Number of kpts imported differs from pyscf\")\n    if not np.allclose(kpts_imp, self.kpts._kpts) and not np.allclose(\n        kpts_imp, -self.kpts._kpts\n    ):\n        raise ValueError(\"Different kpts imported to those in pyscf\")\n\n    cou = {}\n    coll = {}\n    for ki in range(len(self.kpts)):\n        cou[ki] = np.array(thc_eri[\"coulomb_matrix\"])[ki, ..., 0]\n        coll[ki] = np.array(thc_eri[\"collocation_matrix\"])[0, ki, ..., 0]\n\n    self._blocks[\"coll\"] = coll\n    self._blocks[\"cou\"] = cou\n</code></pre>"},{"location":"reference/pbc/thc/#momentGW.pbc.thc.KIntegrals.transform","title":"<code>momentGW.pbc.thc.KIntegrals.transform(do_Lpq=True, do_Lpx=True, do_Lia=True)</code>","text":"<p>Transform the integrals in-place.</p> <p>Parameters:</p> Name Type Description Default <code>do_Lpq</code> <code>bool</code> <p>Whether the <code>(aux, MO, MO)</code> array is required. In THC, this requires the <code>Lp</code> array. Default value is <code>True</code>.</p> <code>True</code> <code>do_Lpx</code> <code>bool</code> <p>Whether the <code>(aux, MO, MO)</code> array is required. In THC, this requires the <code>Lx</code> array. Default value is <code>True</code>.</p> <code>True</code> <code>do_Lia</code> <code>bool</code> <p>Whether the <code>(aux, occ, vir)</code> array is required. In THC, this requires the <code>Li</code> and <code>La</code> arrays. Default value is <code>True</code>.</p> <code>True</code> Source code in <code>momentGW/pbc/thc.py</code> <pre><code>@logging.with_status(\"Transforming integrals\")\ndef transform(self, do_Lpq=True, do_Lpx=True, do_Lia=True):\n    \"\"\"\n    Transform the integrals in-place.\n\n    Parameters\n    ----------\n    do_Lpq : bool, optional\n        Whether the ``(aux, MO, MO)`` array is required. In THC,\n        this requires the `Lp` array. Default value is `True`.\n    do_Lpx : bool, optional\n        Whether the ``(aux, MO, MO)`` array is required. In THC,\n        this requires the `Lx` array. Default value is `True`.\n    do_Lia : bool, optional\n        Whether the ``(aux, occ, vir)`` array is required. In THC,\n        this requires the `Li` and `La` arrays. Default value is\n        `True`.\n    \"\"\"\n\n    # Check if any arrays are required\n    if not any([do_Lpq, do_Lpx, do_Lia]):\n        return\n\n    # Import THC components\n    if self.coll is None and self.cou is None:\n        self.import_thc_components()\n\n    Lp = {}\n    Lx = {}\n    Li = {}\n    La = {}\n\n    do_Lpq = self.store_full if do_Lpq is None else do_Lpq\n\n    for ki in range(self.nkpts):\n        # Transform the (L|pq) array\n        if do_Lpq:\n            Lp[ki] = util.einsum(\"Lp,pq-&gt;Lq\", self.coll[ki], self.mo_coeff[ki])\n\n        # Transform the (L|px) array\n        if do_Lpx:\n            Lx[ki] = util.einsum(\"Lp,pq-&gt;Lq\", self.coll[ki], self.mo_coeff_g[ki])\n\n        # Transform the (L|ia) and (L|ai) arrays\n        if do_Lia:\n            ci = self.mo_coeff_w[ki][:, self.mo_occ_w[ki] &gt; 0]\n            ca = self.mo_coeff_w[ki][:, self.mo_occ_w[ki] == 0]\n\n            Li[ki] = util.einsum(\"Lp,pi-&gt;Li\", self.coll[ki], ci)\n            La[ki] = util.einsum(\"Lp,pa-&gt;La\", self.coll[ki], ca)\n\n    if do_Lpq:\n        self._blocks[\"Lp\"] = Lp\n    if do_Lpx:\n        self._blocks[\"Lx\"] = Lx\n    if do_Lia:\n        self._blocks[\"Li\"] = Li\n        self._blocks[\"La\"] = La\n</code></pre>"},{"location":"reference/pbc/thc/#momentGW.pbc.thc.KIntegrals.get_j","title":"<code>momentGW.pbc.thc.KIntegrals.get_j(dm, basis='mo')</code>","text":"<p>Build the J matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix at each k-point.</p> required <code>basis</code> <code>str</code> <p>Basis in which to build the J matrix. One of <code>(\"ao\", \"mo\")</code>. Default value is <code>\"mo\"</code>.</p> <code>'mo'</code> <p>Returns:</p> Name Type Description <code>vj</code> <code>ndarray</code> <p>J matrix at each k-point.</p> Notes <p>The basis of <code>dm</code> must be the same as <code>basis</code>.</p> Source code in <code>momentGW/pbc/thc.py</code> <pre><code>@logging.with_timer(\"J matrix\")\n@logging.with_status(\"Building J matrix\")\ndef get_j(self, dm, basis=\"mo\"):\n    \"\"\"Build the J matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix at each k-point.\n    basis : str, optional\n        Basis in which to build the J matrix. One of\n        `(\"ao\", \"mo\")`. Default value is `\"mo\"`.\n\n    Returns\n    -------\n    vj : numpy.ndarray\n        J matrix at each k-point.\n\n    Notes\n    -----\n    The basis of `dm` must be the same as `basis`.\n    \"\"\"\n\n    # Check the input\n    assert basis in (\"ao\", \"mo\")\n\n    # Get the components\n    vj = np.zeros_like(dm, dtype=complex)\n    if basis == \"ao\":\n        if self.coll is None and self.cou is None:\n            self.import_thc_components()\n        Lp = self.coll\n        cou = self.cou\n    else:\n        Lp = self.Lp\n        cou = self.cou\n\n    buf = 0.0\n    for ki in range(self.nkpts):\n        tmp = util.einsum(\"pq,Kp,Kq-&gt;K\", dm[ki], Lp[ki], Lp[ki].conj())\n        tmp = util.einsum(\"K,KL-&gt;L\", tmp, cou[0])\n        buf += tmp\n\n    buf /= self.nkpts\n\n    for kj in range(self.nkpts):\n        vj[kj] = util.einsum(\"L,Lr,Ls-&gt;rs\", buf, Lp[kj].conj(), Lp[kj])\n\n    return vj\n</code></pre>"},{"location":"reference/pbc/thc/#momentGW.pbc.thc.KIntegrals.get_k","title":"<code>momentGW.pbc.thc.KIntegrals.get_k(dm, basis='mo')</code>","text":"<p>Build the K matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix at each k-point.</p> required <code>basis</code> <code>str</code> <p>Basis in which to build the K matrix. One of <code>(\"ao\", \"mo\")</code>. Default value is <code>\"mo\"</code>.</p> <code>'mo'</code> <p>Returns:</p> Name Type Description <code>vk</code> <code>ndarray</code> <p>K matrix at each k-point.</p> Notes <p>The basis of <code>dm</code> must be the same as <code>basis</code>.</p> Source code in <code>momentGW/pbc/thc.py</code> <pre><code>@logging.with_timer(\"K matrix\")\n@logging.with_status(\"Building K matrix\")\ndef get_k(self, dm, basis=\"mo\"):\n    \"\"\"Build the K matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix at each k-point.\n    basis : str, optional\n        Basis in which to build the K matrix. One of\n        `(\"ao\", \"mo\")`. Default value is `\"mo\"`.\n\n    Returns\n    -------\n    vk : numpy.ndarray\n        K matrix at each k-point.\n\n    Notes\n    -----\n    The basis of `dm` must be the same as `basis`.\n    \"\"\"\n\n    # Check the input\n    assert basis in (\"ao\", \"mo\")\n\n    # Get the components\n    vk = np.zeros_like(dm, dtype=complex)\n    if basis == \"ao\":\n        if self.coll is None and self.cou is None:\n            self.import_thc_components()\n        Lp = self.coll\n        cou = self.cou\n    else:\n        Lp = self.Lp\n        cou = self.cou\n\n    buf = np.zeros((self.nkpts, self.nkpts, self.naux, self.naux), dtype=complex)\n    for ki in range(self.nkpts):\n        for kk in range(self.nkpts):\n            tmp = util.einsum(\"pq,Kp-&gt;Kq\", dm[kk], Lp[kk].conj())\n            tmp = util.einsum(\"Kq,Lq-&gt;KL\", tmp, Lp[kk])\n            kb = self.kpts.member(self.kpts.wrap_around(self.kpts[ki] + self.kpts[kk]))\n            buf[ki, kk] = util.einsum(\"KL,KL-&gt;KL\", tmp, cou[kb])\n\n    buf /= self.nkpts\n    for ki in range(self.nkpts):\n        for kk in range(self.nkpts):\n            tmp = util.einsum(\"KL,Ks-&gt;Ls\", buf[ki, kk], Lp[ki].conj())\n            vk[ki] += util.einsum(\"Ls,Lr-&gt;rs\", tmp, Lp[ki])\n\n    return vk\n</code></pre>"},{"location":"reference/pbc/thc/#momentGW.pbc.thc.dTDA","title":"<code>momentGW.pbc.thc.dTDA(gw, nmom_max, integrals, mo_energy=None, mo_occ=None)</code>","text":"<p>             Bases: <code>dTDA</code>, <code>dTDA</code></p> <p>Compute the self-energy moments using dTDA with tensor hyper-contraction and periodic boundary conditions.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseKGW</code> <p>GW object.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>integrals</code> <code>KIntegrals</code> <p>Density-fitted integrals.</p> required <code>mo_energy</code> <code>numpy.ndarray or tuple of numpy.ndarray</code> <p>Molecular orbital energies at each k-point. If a tuple is passed, the first element corresponds to the Green's function basis and the second to the screened Coulomb interaction. Default value is that of <code>gw.mo_energy</code>.</p> <code>None</code> <code>mo_occ</code> <code>numpy.ndarray or tuple of numpy.ndarray</code> <p>Molecular orbital occupancies at each k-point. If a tuple is passed, the first element corresponds to the Green's function basis and the second to the screened Coulomb interaction. Default value is that of <code>gw.mo_occ</code>.</p> <code>None</code> Source code in <code>momentGW/tda.py</code> <pre><code>def __init__(\n    self,\n    gw,\n    nmom_max,\n    integrals,\n    mo_energy=None,\n    mo_occ=None,\n):\n    # Attributes\n    self.gw = gw\n    self.nmom_max = nmom_max\n    self.integrals = integrals\n\n    # Get the MO energies for G and W\n    if mo_energy is not None:\n        self.mo_energy_g = mo_energy[\"g\"]\n        self.mo_energy_w = mo_energy[\"w\"]\n    else:\n        self.mo_energy_g = self.mo_energy_w = gw.mo_energy\n\n    # Get the MO occupancies for G and W\n    if mo_occ is not None:\n        self.mo_occ_g = mo_occ[\"g\"]\n        self.mo_occ_w = mo_occ[\"w\"]\n    else:\n        self.mo_occ_g = self.mo_occ_w = gw.mo_occ\n\n    # Options and thresholds\n    self.report_quadrature_error = True\n    if self.gw.compression and \"ia\" in self.gw.compression.split(\",\"):\n        self.compression_tol = gw.compression_tol\n    else:\n        self.compression_tol = None\n</code></pre>"},{"location":"reference/pbc/thc/#momentGW.pbc.thc.dTDA.build_dd_moments","title":"<code>momentGW.pbc.thc.dTDA.build_dd_moments()</code>","text":"<p>Build the moments of the density-density response.</p> <p>Returns:</p> Name Type Description <code>moments</code> <code>ndarray</code> <p>Moments of the density-density response at each k-point.</p> Notes <p>Unlike the standard <code>momentGW.tda</code> implementation, this method scales as :math:<code>O(N^3)</code> with system size instead of :math:<code>O(N^4)</code>.</p> Source code in <code>momentGW/pbc/thc.py</code> <pre><code>@logging.with_timer(\"Density-density moments\")\n@logging.with_status(\"Constructing density-density moments\")\ndef build_dd_moments(self):\n    \"\"\"Build the moments of the density-density response.\n\n    Returns\n    -------\n    moments : numpy.ndarray\n        Moments of the density-density response at each k-point.\n\n    Notes\n    -----\n    Unlike the standard `momentGW.tda` implementation, this method\n    scales as :math:`O(N^3)` with system size instead of\n    :math:`O(N^4)`.\n    \"\"\"\n\n    zeta = np.zeros((self.nkpts, self.nkpts, self.nmom_max + 1), dtype=object)\n\n    kpts = self.kpts\n    cou_occ = np.zeros((self.nkpts, 1), dtype=object)\n    cou_vir = np.zeros((self.nkpts, 1), dtype=object)\n\n    cou_d_left = np.zeros((self.nkpts, self.nkpts, self.nmom_max + 1), dtype=object)\n    cou_d_only = np.zeros((self.nkpts, self.nkpts, self.nmom_max + 1), dtype=object)\n    cou_left = np.zeros((self.nkpts, self.nkpts, 1), dtype=object)\n\n    for q in kpts.loop(1):\n        for kj in kpts.loop(1):\n            kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[kj]))\n            cou_occ[kj, 0] = np.dot(self.Li[kj].conj(), self.Li[kj].conj().T)\n            cou_vir[kb, 0] = np.dot(self.La[kb], self.La[kb].T)\n            zeta[q, kb, 0] = cou_occ[kj, 0] * cou_vir[kb, 0]\n    zeta[..., 0] /= self.nkpts\n\n    cou_square = np.zeros((self.nkpts, self.naux, self.naux), dtype=complex)\n    for q in kpts.loop(1):\n        for kj in kpts.loop(1):\n            kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[kj]))\n            cou_left[q, kb, 0] = np.eye(self.naux)\n            cou_square[q] += np.dot(self.cou[q], (cou_occ[kj, 0] * cou_vir[kb, 0]))\n\n    for i in range(1, self.nmom_max + 1):\n        cou_it_add = np.zeros((self.nkpts, self.naux, self.naux), dtype=complex)\n        for q in kpts.loop(1):\n            for kj in kpts.loop(1):\n                kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[kj]))\n                zeta[q, kb, i] = np.zeros((self.naux, self.naux), dtype=complex)\n                cou_d_left[q, kb, 0] = cou_left[q, kb, 0]\n                cou_d_left[q, kb] = np.roll(cou_d_left[q, kb], 1)\n                cou_left[q, kb, 0] = np.dot(cou_square[q], cou_left[q, kb, 0]) * 2 / self.nkpts\n\n                ei = self.mo_energy_w[kj][self.mo_occ_w[kj] &gt; 0]\n                ea = self.mo_energy_w[kb][self.mo_occ_w[kb] == 0]\n                cou_ei_max = util.einsum(\n                    \"i,Pi,Qi-&gt;PQ\", ei**i, self.Li[kj].conj(), self.Li[kj].conj()\n                ) * pow(-1, i)\n                cou_ea_max = util.einsum(\"a,Pa,Qa-&gt;PQ\", ea**i, self.La[kb], self.La[kb])\n\n                cou_d_only[q, kb, i] = cou_ea_max * cou_occ[kj, 0] + cou_ei_max * cou_vir[kb, 0]\n\n                for j in range(1, i):\n                    cou_ei = util.einsum(\n                        \"i,Pi,Qi-&gt;PQ\", ei**j, self.Li[kj].conj(), self.Li[kj].conj()\n                    ) * pow(-1, j)\n                    cou_ea = util.einsum(\n                        \"a,Pa,Qa-&gt;PQ\", ea ** (i - j), self.La[kb], self.La[kb]\n                    ) * binom(i, j)\n                    cou_d_only[q, kb, i] += cou_ei * cou_ea\n                    if j == (i - 1):\n                        cou_it_add[q] += cou_d_only[q, kb, j]\n                    else:\n                        cou_it_add[q] += np.dot(\n                            cou_d_only[q, kb, i - 1 - j], cou_d_left[q, kb, i - j]\n                        )\n                    zeta[q, kb, i] += (\n                        np.dot(cou_d_only[q, kb, j], cou_d_left[q, kb, j]) / self.nkpts\n                    )\n            cou_it_add[q] = np.dot(self.cou[q], cou_it_add[q])\n            cou_it_add[q] *= 2.0\n            cou_it_add[q] /= self.nkpts\n            for kj in kpts.loop(1):\n                kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[kj]))\n                zeta[q, kb, i] += cou_d_only[q, kb, i] / self.nkpts\n\n                cou_left[q, kb, 0] += cou_it_add[q]\n                zeta[q, kb, i] += np.dot(zeta[q, kb, 0], cou_left[q, kb, 0])\n\n    return zeta\n</code></pre>"},{"location":"reference/pbc/thc/#momentGW.pbc.thc.dTDA.build_se_moments","title":"<code>momentGW.pbc.thc.dTDA.build_se_moments(zeta)</code>","text":"<p>Build the moments of the self-energy via convolution.</p> <p>Parameters:</p> Name Type Description Default <code>zeta</code> <code>ndarray</code> <p>Moments of the density-density response at each k-point.</p> required <p>Returns:</p> Name Type Description <code>moments_occ</code> <code>ndarray</code> <p>Moments of the occupied self-energy at each k-point.</p> <code>moments_vir</code> <code>ndarray</code> <p>Moments of the virtual self-energy at each k-point.</p> Source code in <code>momentGW/pbc/thc.py</code> <pre><code>@logging.with_timer(\"Self-energy moments\")\n@logging.with_status(\"Constructing self-energy moments\")\ndef build_se_moments(self, zeta):\n    \"\"\"\n    Build the moments of the self-energy via convolution.\n\n    Parameters\n    ----------\n    zeta : numpy.ndarray\n        Moments of the density-density response at each k-point.\n\n    Returns\n    -------\n    moments_occ : numpy.ndarray\n        Moments of the occupied self-energy at each k-point.\n    moments_vir : numpy.ndarray\n        Moments of the virtual self-energy at each k-point.\n    \"\"\"\n\n    kpts = self.kpts\n\n    # Setup dependent on diagonal SE\n    if self.gw.diagonal_se:\n        pqchar = pchar = qchar = \"p\"\n        eta_shape = lambda k: (self.mo_energy_g[k].size, self.nmom_max + 1, self.nmo)\n    else:\n        pqchar, pchar, qchar = \"pq\", \"p\", \"q\"\n        eta_shape = lambda k: (self.mo_energy_g[k].size, self.nmom_max + 1, self.nmo, self.nmo)\n    eta = np.zeros((self.nkpts, self.nkpts), dtype=object)\n\n    # Get the moments in (aux|aux) and rotate to (mo|mo)\n    for i in range(self.nmom_max + 1):\n        for q in kpts.loop(1):\n            zeta_prime = 0\n            for kj in kpts.loop(1):\n                kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[kj]))\n                zeta_prime += np.linalg.multi_dot((self.cou[q], zeta[q, kb, i], self.cou[q]))\n            zeta_prime *= 2.0\n            zeta_prime /= self.nkpts\n\n            for kp in range(self.nkpts):\n                kx = kpts.member(kpts.wrap_around(kpts[kp] - kpts[q]))\n\n                if not isinstance(eta[kp, q], np.ndarray):\n                    eta[kp, q] = np.zeros(eta_shape(kx), dtype=zeta_prime.dtype)\n\n                for x in range(self.mo_energy_g[kx].size):\n                    Lpx = util.einsum(\n                        \"Pp,P-&gt;Pp\", self.integrals.Lp[kp], self.integrals.Lx[kx][:, x]\n                    )\n                    subscript = f\"P{pchar},Q{qchar},PQ-&gt;{pqchar}\"\n                    eta[kp, q][x, i] += util.einsum(subscript, Lpx, Lpx.conj(), zeta_prime)\n\n    # Construct the self-energy moments\n    moments_occ, moments_vir = self.convolve(eta)\n\n    return moments_occ, moments_vir\n</code></pre>"},{"location":"reference/pbc/uhf/","title":"Index","text":"<p>Methods for periodic systems with unrestricted references.</p>"},{"location":"reference/pbc/uhf/base/","title":"Base","text":"<p>Base class for moment-constrained GW solvers with periodic boundary conditions and unrestricted references.</p>"},{"location":"reference/pbc/uhf/base/#momentGW.pbc.uhf.base.BaseKUGW","title":"<code>momentGW.pbc.uhf.base.BaseKUGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>BaseKGW</code>, <code>BaseUGW</code></p> <p>Base class for moment-constrained GW solvers for periodic systems with unrestricted references.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>KSCF</code> <p>PySCF periodic mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.pbc.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>fc</code> <code>bool</code> <p>If <code>True</code>, apply finite size corrections. Default value is <code>False</code>.</p> required Source code in <code>momentGW/pbc/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Options\n    self.fc = False\n\n    # Attributes\n    self._kpts = KPoints(self.cell, getattr(mf, \"kpts\", np.zeros((1, 3))))\n</code></pre>"},{"location":"reference/pbc/uhf/evgw/","title":"Evgw","text":"<p>Spin-unrestricted eigenvalue self-consistent GW via self-energy moment constraints for periodic systems.</p>"},{"location":"reference/pbc/uhf/evgw/#momentGW.pbc.uhf.evgw.evKUGW","title":"<code>momentGW.pbc.uhf.evgw.evKUGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>KUGW</code>, <code>evKGW</code>, <code>evUGW</code></p> <p>Spin-unrestricted eigenvalue self-consistent GW via self-energy moment constraints for periodic systems.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>KSCF</code> <p>PySCF periodic mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>fc</code> <code>bool</code> <p>If <code>True</code>, apply finite size corrections. Default value is <code>False</code>.</p> required <code>g0</code> <code>bool</code> <p>If <code>True</code>, do not self-consistently update the eigenvalues in the Green's function. Default value is <code>False</code>.</p> required <code>w0</code> <code>bool</code> <p>If <code>True</code>, do not self-consistently update the eigenvalues in the screened Coulomb interaction. Default value is <code>False</code>.</p> required <code>max_cycle</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>50</code>.</p> required <code>conv_tol</code> <code>float</code> <p>Convergence threshold in the change in the HOMO and LUMO. Default value is <code>1e-8</code>.</p> required <code>conv_tol_moms</code> <code>float</code> <p>Convergence threshold in the change in the moments. Default value is <code>1e-8</code>.</p> required <code>conv_logical</code> <code>callable</code> <p>Function that takes an iterable of booleans as input indicating whether the individual <code>conv_tol</code> and <code>conv_tol_moms</code> have been satisfied, respectively, and returns a boolean indicating overall convergence. For example, the function <code>all</code> requires both metrics to be met, and <code>any</code> requires just one. Default value is <code>all</code>.</p> required <code>diis_space</code> <code>int</code> <p>Size of the DIIS extrapolation space. Default value is <code>8</code>.</p> required <code>damping</code> <code>float</code> <p>Damping parameter. Default value is <code>0.0</code>.</p> required <code>weight_tol</code> <code>float</code> <p>Threshold in physical weight of Green's function poles, below which they are considered zero. Default value is <code>1e-11</code>.</p> required Source code in <code>momentGW/pbc/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Options\n    self.fc = False\n\n    # Attributes\n    self._kpts = KPoints(self.cell, getattr(mf, \"kpts\", np.zeros((1, 3))))\n</code></pre>"},{"location":"reference/pbc/uhf/evgw/#momentGW.pbc.uhf.evgw.evKUGW.name","title":"<code>momentGW.pbc.uhf.evgw.evKUGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/pbc/uhf/evgw/#momentGW.pbc.uhf.evgw.evKUGW.check_convergence","title":"<code>momentGW.pbc.uhf.evgw.evKUGW.check_convergence(mo_energy, mo_energy_prev, th, th_prev, tp, tp_prev)</code>","text":"<p>Check for convergence, and print a summary of changes.</p> <p>Parameters:</p> Name Type Description Default <code>mo_energy</code> <code>ndarray</code> <p>Molecular orbital energies at each k-point for each spin channel.</p> required <code>mo_energy_prev</code> <code>ndarray</code> <p>Molecular orbital energies from the previous iteration at each k-point for each spin channel.</p> required <code>th</code> <code>ndarray</code> <p>Moments of the occupied self-energy at each k-point for each spin channel.</p> required <code>th_prev</code> <code>ndarray</code> <p>Moments of the occupied self-energy from the previous iteration at each k-point for each spin channel.</p> required <code>tp</code> <code>ndarray</code> <p>Moments of the virtual self-energy at each k-point for each spin channel.</p> required <code>tp_prev</code> <code>ndarray</code> <p>Moments of the virtual self-energy from the previous iteration at each k-point for each spin channel.</p> required <p>Returns:</p> Name Type Description <code>conv</code> <code>bool</code> <p>Convergence flag.</p> Source code in <code>momentGW/pbc/uhf/evgw.py</code> <pre><code>def check_convergence(self, mo_energy, mo_energy_prev, th, th_prev, tp, tp_prev):\n    \"\"\"Check for convergence, and print a summary of changes.\n\n    Parameters\n    ----------\n    mo_energy : numpy.ndarray\n        Molecular orbital energies at each k-point for each spin\n        channel.\n    mo_energy_prev : numpy.ndarray\n        Molecular orbital energies from the previous iteration at\n        each k-point for each spin channel.\n    th : numpy.ndarray\n        Moments of the occupied self-energy at each k-point for\n        each spin channel.\n    th_prev : numpy.ndarray\n        Moments of the occupied self-energy from the previous\n        iteration at each k-point for each spin channel.\n    tp : numpy.ndarray\n        Moments of the virtual self-energy at each k-point for each\n        spin channel.\n    tp_prev : numpy.ndarray\n        Moments of the virtual self-energy from the previous\n        iteration at each k-point for each spin channel.\n\n    Returns\n    -------\n    conv : bool\n        Convergence flag.\n    \"\"\"\n\n    # Get the previous moments\n    if th_prev is None:\n        th_prev = np.zeros_like(th)\n    if tp_prev is None:\n        tp_prev = np.zeros_like(tp)\n\n    def try_index(x, n):\n        if n &lt; 0 or n &gt;= len(x):\n            return 0.0\n        else:\n            return x[n]\n\n    # Get the HOMO and LUMO errors\n    error_homo = (\n        max(\n            abs(try_index(mo, n - 1) - try_index(mo_prev, n - 1))\n            for mo, mo_prev, n in zip(mo_energy[0], mo_energy_prev[0], self.nocc[0])\n        ),\n        max(\n            abs(try_index(mo, n - 1) - try_index(mo_prev, n - 1))\n            for mo, mo_prev, n in zip(mo_energy[1], mo_energy_prev[1], self.nocc[1])\n        ),\n    )\n    error_lumo = (\n        max(\n            abs(try_index(mo, n) - try_index(mo_prev, n))\n            for mo, mo_prev, n in zip(mo_energy[0], mo_energy_prev[0], self.nocc[0])\n        ),\n        max(\n            abs(try_index(mo, n) - try_index(mo_prev, n))\n            for mo, mo_prev, n in zip(mo_energy[1], mo_energy_prev[1], self.nocc[1])\n        ),\n    )\n\n    # Get the moment errors\n    error_th = (\n        max(abs(self._moment_error(t, t_prev)) for t, t_prev in zip(th[0], th_prev[0])),\n        max(abs(self._moment_error(t, t_prev)) for t, t_prev in zip(th[1], th_prev[1])),\n    )\n    error_tp = (\n        max(abs(self._moment_error(t, t_prev)) for t, t_prev in zip(tp[0], tp_prev[0])),\n        max(abs(self._moment_error(t, t_prev)) for t, t_prev in zip(tp[1], tp_prev[1])),\n    )\n\n    # Print the table\n    style_homo = tuple(logging.rate(e, self.conv_tol, self.conv_tol * 1e2) for e in error_homo)\n    style_lumo = tuple(logging.rate(e, self.conv_tol, self.conv_tol * 1e2) for e in error_lumo)\n    style_th = tuple(\n        logging.rate(e, self.conv_tol_moms, self.conv_tol_moms * 1e2) for e in error_th\n    )\n    style_tp = tuple(\n        logging.rate(e, self.conv_tol_moms, self.conv_tol_moms * 1e2) for e in error_tp\n    )\n    table = logging.Table(title=\"Convergence\")\n    table.add_column(\"Sector\", justify=\"right\")\n    table.add_column(\"\u0394 energy\", justify=\"right\")\n    table.add_column(\"\u0394 moments\", justify=\"right\")\n    for s, spin in enumerate([\"\u03b1\", \"\u03b2\"]):\n        table.add_row(\n            f\"Hole ({spin})\",\n            f\"[{style_homo[s]}]{error_homo[s]:.3g}[/]\",\n            f\"[{style_th[s]}]{error_th[s]:.3g}[/]\",\n        )\n    for s, spin in enumerate([\"\u03b1\", \"\u03b2\"]):\n        table.add_row(\n            f\"Particle ({spin})\",\n            f\"[{style_lumo[s]}]{error_lumo[s]:.3g}[/]\",\n            f\"[{style_tp[s]}]{error_tp[s]:.3g}[/]\",\n        )\n    logging.write(\"\")\n    logging.write(table)\n\n    return self.conv_logical(\n        (\n            max(max(error_homo), max(error_lumo)) &lt; self.conv_tol,\n            max(max(error_th), max(error_tp)) &lt; self.conv_tol_moms,\n        )\n    )\n</code></pre>"},{"location":"reference/pbc/uhf/evgw/#momentGW.pbc.uhf.evgw.evKUGW.remove_unphysical_poles","title":"<code>momentGW.pbc.uhf.evgw.evKUGW.remove_unphysical_poles(gf)</code>","text":"<p>Remove unphysical poles from the Green's function to stabilise iterations, according to the threshold <code>self.weight_tol</code>.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>tuple of tuple of dyson.Lehmann</code> <p>Green's function at each k-point for each spin channel.</p> required <p>Returns:</p> Name Type Description <code>gf_out</code> <code>tuple of tuple of dyson.Lehmann</code> <p>Green's function at each k-point for each spin channel, with potentially fewer poles.</p> Source code in <code>momentGW/pbc/uhf/evgw.py</code> <pre><code>def remove_unphysical_poles(self, gf):\n    \"\"\"\n    Remove unphysical poles from the Green's function to stabilise\n    iterations, according to the threshold `self.weight_tol`.\n\n    Parameters\n    ----------\n    gf : tuple of tuple of dyson.Lehmann\n        Green's function at each k-point for each spin channel.\n\n    Returns\n    -------\n    gf_out : tuple of tuple of dyson.Lehmann\n        Green's function at each k-point for each spin channel, with\n        potentially fewer poles.\n    \"\"\"\n    gf = [[g for g in gs] for gs in gf]\n    for s in range(2):\n        for k, g in enumerate(gf[s]):\n            gf[s][k] = g.physical(weight=self.weight_tol)\n    return (tuple(gf[0]), tuple(gf[1]))\n</code></pre>"},{"location":"reference/pbc/uhf/fock/","title":"Fock","text":"<p>Fock matrix and static self-energy parts with periodic boundary conditions and unrestricted references.</p>"},{"location":"reference/pbc/uhf/fock/#momentGW.pbc.uhf.fock.FockLoop","title":"<code>momentGW.pbc.uhf.fock.FockLoop</code>","text":"<p>             Bases: <code>FockLoop</code></p> <p>Self-consistent loop for the density matrix via the Hartree--Fock self-consistent field for spin-unrestricted periodic systems.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseKUGW</code> <p>GW object.</p> required <code>gf</code> <code>tuple of tuple of dyson.Lehmann</code> <p>Initial Green's function object at each k-point for each spin channel. If <code>None</code>, use <code>gw.init_gf()</code>. Default value is <code>None</code>.</p> required <code>se</code> <code>tuple of tuple of dyson.Lehmann</code> <p>Initial self-energy object at each k-point for each spin channel. If passed, use as dynamic part of the self-energy. If <code>None</code>, self-energy is assumed to be static and fully defined by the Fock matrix. Default value is <code>None</code>.</p> required <code>fock_diis_space</code> <code>int</code> <p>DIIS space size for the Fock matrix. Default value is <code>10</code>.</p> required <code>fock_diis_min_space</code> <code>int</code> <p>Minimum DIIS space size for the Fock matrix. Default value is <code>1</code>.</p> required <code>conv_tol_nelec</code> <code>float</code> <p>Convergence tolerance for the number of electrons. Default value is <code>1e-6</code>.</p> required <code>conv_tol_rdm1</code> <code>float</code> <p>Convergence tolerance for the density matrix. Default value is <code>1e-8</code>.</p> required <code>max_cycle_inner</code> <code>int</code> <p>Maximum number of inner iterations. Default value is <code>100</code>.</p> required <code>max_cycle_outer</code> <code>int</code> <p>Maximum number of outer iterations. Default value is <code>20</code>.</p> required"},{"location":"reference/pbc/uhf/fock/#momentGW.pbc.uhf.fock.FockLoop.naux","title":"<code>momentGW.pbc.uhf.fock.FockLoop.naux</code>  <code>property</code>","text":"<p>Get the number of auxiliary states.</p>"},{"location":"reference/pbc/uhf/fock/#momentGW.pbc.uhf.fock.FockLoop.nqmo","title":"<code>momentGW.pbc.uhf.fock.FockLoop.nqmo</code>  <code>property</code>","text":"<p>Get the number of quasiparticle MOs.</p>"},{"location":"reference/pbc/uhf/fock/#momentGW.pbc.uhf.fock.FockLoop.nelec","title":"<code>momentGW.pbc.uhf.fock.FockLoop.nelec</code>  <code>property</code>","text":"<p>Get the number of electrons.</p>"},{"location":"reference/pbc/uhf/fock/#momentGW.pbc.uhf.fock.FockLoop.auxiliary_shift","title":"<code>momentGW.pbc.uhf.fock.FockLoop.auxiliary_shift(fock, se=None)</code>","text":"<p>Optimise a shift in the auxiliary energies to best satisfy the electron number.</p> <p>Parameters:</p> Name Type Description Default <code>fock</code> <code>ndarray</code> <p>Fock matrix at each k-point for each spin channel.</p> required <code>se</code> <code>tuple of tuple of dyson.Lehmann</code> <p>Self-energy at each k-point for each spin channel. If <code>None</code>, use <code>self.se</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>se</code> <code>tuple of tuple of dyson.Lehmann</code> <p>Self-energy at each k-point for each spin channel.</p> Notes <p>If there is no dynamic part of the self-energy (<code>self.se</code> is <code>None</code>), this method returns <code>None</code>.</p> Source code in <code>momentGW/pbc/uhf/fock.py</code> <pre><code>def auxiliary_shift(self, fock, se=None):\n    \"\"\"\n    Optimise a shift in the auxiliary energies to best satisfy the\n    electron number.\n\n    Parameters\n    ----------\n    fock : numpy.ndarray\n        Fock matrix at each k-point for each spin channel.\n    se : tuple of tuple of dyson.Lehmann, optional\n        Self-energy at each k-point for each spin channel. If\n        `None`, use `self.se`. Default value is `None`.\n\n    Returns\n    -------\n    se : tuple of tuple of dyson.Lehmann\n        Self-energy at each k-point for each spin channel.\n\n    Notes\n    -----\n    If there is no dynamic part of the self-energy (`self.se` is\n    `None`), this method returns `None`.\n    \"\"\"\n\n    # Get the self-energy\n    if se is None:\n        se = self.se\n    if se is None:\n        return None\n\n    # Optimise the shift in the auxiliary energies\n    se_\u03b1, opt_\u03b1 = minimize_chempot(\n        se[0],\n        fock[0],\n        sum(self.nelec[0]),\n        x0=se[0][0].chempot,\n        tol=self.conv_tol_nelec,\n        maxiter=self.max_cycle_inner,\n        occupancy=1,\n    )\n    se_\u03b2, opt_\u03b2 = minimize_chempot(\n        se[1],\n        fock[1],\n        sum(self.nelec[1]),\n        x0=se[1][0].chempot,\n        tol=self.conv_tol_nelec,\n        maxiter=self.max_cycle_inner,\n        occupancy=1,\n    )\n    se = (se_\u03b1, se_\u03b2)\n\n    return se\n</code></pre>"},{"location":"reference/pbc/uhf/fock/#momentGW.pbc.uhf.fock.FockLoop.search_chempot","title":"<code>momentGW.pbc.uhf.fock.FockLoop.search_chempot(gf=None)</code>","text":"<p>Search for a chemical potential for a given Green's function.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function for each spin channel. If <code>None</code>, use <code>self.gf</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>chempot</code> <code>tuple of float</code> <p>Chemical potential for each spin channel.</p> <code>nerr</code> <code>tuple of float</code> <p>Error in the number of electrons for each spin channel.</p> Source code in <code>momentGW/pbc/uhf/fock.py</code> <pre><code>def search_chempot(self, gf=None):\n    \"\"\"Search for a chemical potential for a given Green's function.\n\n    Parameters\n    ----------\n    gf : tuple of dyson.Lehmann, optional\n        Green's function for each spin channel. If `None`, use\n        `self.gf`. Default value is `None`.\n\n    Returns\n    -------\n    chempot : tuple of float\n        Chemical potential for each spin channel.\n    nerr : tuple of float\n        Error in the number of electrons for each spin channel.\n    \"\"\"\n\n    # Get the Green's function\n    if gf is None:\n        gf = self.gf\n\n    # Search for the chemical potential\n    chempot_\u03b1, nerr_\u03b1 = search_chempot(\n        [g.energies for g in gf[0]],\n        [g.couplings for g in gf[0]],\n        self.nmo[0],\n        sum(self.nelec[0]),\n        occupancy=1,\n    )\n    chempot_\u03b2, nerr_\u03b2 = search_chempot(\n        [g.energies for g in gf[1]],\n        [g.couplings for g in gf[1]],\n        self.nmo[1],\n        sum(self.nelec[1]),\n        occupancy=1,\n    )\n    chempot = (chempot_\u03b1, chempot_\u03b2)\n    nerr = abs(nerr_\u03b1) + abs(nerr_\u03b2)\n\n    return chempot, nerr\n</code></pre>"},{"location":"reference/pbc/uhf/fock/#momentGW.pbc.uhf.fock.FockLoop.solve_dyson","title":"<code>momentGW.pbc.uhf.fock.FockLoop.solve_dyson(fock, se=None)</code>","text":"<p>Solve the Dyson equation for a given Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>fock</code> <code>ndarray</code> <p>Fock matrix at each k-point for each spin channel.</p> required <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy at each k-point. If <code>None</code>, use <code>self.se</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function at each k-point.</p> <code>nerr</code> <code>float</code> <p>Error in the number of electrons.</p> Notes <p>If there is no dynamic part of the self-energy (<code>self.se</code> is <code>None</code>), this method simply diagonalises the Fock matrix and returns the Lehmann representation of the resulting zeroth-order Green's function.</p> Source code in <code>momentGW/pbc/uhf/fock.py</code> <pre><code>def solve_dyson(self, fock, se=None):\n    \"\"\"Solve the Dyson equation for a given Fock matrix.\n\n    Parameters\n    ----------\n    fock : numpy.ndarray\n        Fock matrix at each k-point for each spin channel.\n    se : tuple of dyson.Lehmann, optional\n        Self-energy at each k-point. If `None`, use `self.se`.\n        Default value is `None`.\n\n    Returns\n    -------\n    gf : tuple of dyson.Lehmann\n        Green's function at each k-point.\n    nerr : float\n        Error in the number of electrons.\n\n    Notes\n    -----\n    If there is no dynamic part of the self-energy (`self.se` is\n    `None`), this method simply diagonalises the Fock matrix and\n    returns the Lehmann representation of the resulting zeroth-order\n    Green's function.\n    \"\"\"\n\n    if se is None:\n        se = self.se\n\n    # Diagonalise the (extended) Fock matrix\n    if se is None:\n        e, c = np.linalg.eigh(fock)\n    else:\n        e_\u03b1, c_\u03b1 = zip(*[s.diagonalise_matrix(f, chempot=0.0) for s, f in zip(se[0], fock[0])])\n        e_\u03b2, c_\u03b2 = zip(*[s.diagonalise_matrix(f, chempot=0.0) for s, f in zip(se[1], fock[1])])\n        e = (e_\u03b1, e_\u03b2)\n        c = (c_\u03b1, c_\u03b2)\n\n    # Broadcast the eigenvalues and eigenvectors in case of\n    # hybrid parallelisation introducing non-determinism\n    e = [\n        [mpi_helper.bcast(ek, root=0) for ek in e[0]],\n        [mpi_helper.bcast(ek, root=0) for ek in e[1]],\n    ]\n    c = [\n        [mpi_helper.bcast(ck, root=0) for ck in c[0]],\n        [mpi_helper.bcast(ck, root=0) for ck in c[1]],\n    ]\n\n    # Construct the Green's function\n    gf = [\n        [Lehmann(ek, ck[: self.nmo[0]], chempot=0.0) for ek, ck in zip(e[0], c[0])],\n        [Lehmann(ek, ck[: self.nmo[1]], chempot=0.0) for ek, ck in zip(e[1], c[1])],\n    ]\n\n    # Search for the chemical potential\n    chempot, nerr = self.search_chempot(gf)\n    for k in self.kpts.loop(1):\n        gf[0][k].chempot = chempot[0]\n        gf[1][k].chempot = chempot[1]\n\n    return tuple(tuple(gf_s) for gf_s in gf), nerr\n</code></pre>"},{"location":"reference/pbc/uhf/fock/#momentGW.pbc.uhf.fock.FockLoop.kernel","title":"<code>momentGW.pbc.uhf.fock.FockLoop.kernel(integrals=None)</code>","text":"<p>Driver for the Fock loop.</p> <p>Parameters:</p> Name Type Description Default <code>integrals</code> <code>KUIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>converged</code> <code>bool</code> <p>Whether the loop has converged.</p> <code>gf</code> <code>tuple of tuple of dyson.Lehmann</code> <p>Green's function object at each k-point for each spin channel.</p> <code>se</code> <code>tuple of tuple of dyson.Lehmann</code> <p>Self-energy object at each k-point for each spin channel.</p> Source code in <code>momentGW/pbc/uhf/fock.py</code> <pre><code>@logging.with_timer(\"Fock loop\")\n@logging.with_status(\"Running Fock loop\")\ndef kernel(self, integrals=None):\n    \"\"\"Driver for the Fock loop.\n\n    Parameters\n    ----------\n    integrals : KUIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    converged : bool\n        Whether the loop has converged.\n    gf : tuple of tuple of dyson.Lehmann\n        Green's function object at each k-point for each spin\n        channel.\n    se : tuple of tuple of dyson.Lehmann\n        Self-energy object at each k-point for each spin channel.\n    \"\"\"\n    return super().kernel(integrals)\n</code></pre>"},{"location":"reference/pbc/uhf/fsgw/","title":"Fsgw","text":"<p>Spin-unrestricted Fock matrix self-consistent GW via self-energy moment constraints for periodic systems.</p>"},{"location":"reference/pbc/uhf/fsgw/#momentGW.pbc.uhf.fsgw.fsKUGW","title":"<code>momentGW.pbc.uhf.fsgw.fsKUGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>KUGW</code>, <code>fsKGW</code>, <code>fsUGW</code></p> <p>Spin-unrestricted Fock matrix self-consistent GW via self-energy moment constraints for periodic systems.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>KSCF</code> <p>PySCF periodic mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>fc</code> <code>bool</code> <p>If <code>True</code>, apply finite size corrections. Default value is <code>False</code>.</p> required <code>max_cycle</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>50</code>.</p> required <code>conv_tol</code> <code>float</code> <p>Convergence threshold in the change in the HOMO and LUMO. Default value is <code>1e-8</code>.</p> required <code>conv_tol_moms</code> <code>float</code> <p>Convergence threshold in the change in the moments. Default value is <code>1e-8</code>.</p> required <code>conv_logical</code> <code>callable</code> <p>Function that takes an iterable of booleans as input indicating whether the individual <code>conv_tol</code>, <code>conv_tol_moms</code> have been satisfied, respectively, and returns a boolean indicating overall convergence. For example, the function <code>all</code> requires both metrics to be met, and <code>any</code> requires just one. Default value is <code>all</code>.</p> required <code>diis_space</code> <code>int</code> <p>Size of the DIIS extrapolation space. Default value is <code>8</code>.</p> required <code>damping</code> <code>float</code> <p>Damping parameter. Default value is <code>0.0</code>.</p> required <code>solver</code> <code>BaseGW</code> <p>Solver to use to obtain the self-energy. Compatible with any <code>BaseGW</code>-like class. Default value is <code>momentGW.gw.GW</code>.</p> required <code>solver_options</code> <code>dict</code> <p>Keyword arguments to pass to the solver. Default value is an empty <code>dict</code>.</p> required Source code in <code>momentGW/pbc/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Options\n    self.fc = False\n\n    # Attributes\n    self._kpts = KPoints(self.cell, getattr(mf, \"kpts\", np.zeros((1, 3))))\n</code></pre>"},{"location":"reference/pbc/uhf/fsgw/#momentGW.pbc.uhf.fsgw.fsKUGW.name","title":"<code>momentGW.pbc.uhf.fsgw.fsKUGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/pbc/uhf/gw/","title":"Gw","text":"<p>Spin-unrestricted one-shot GW via self-energy moment constraints for periodic systems.</p>"},{"location":"reference/pbc/uhf/gw/#momentGW.pbc.uhf.gw.KUGW","title":"<code>momentGW.pbc.uhf.gw.KUGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>BaseKUGW</code>, <code>KGW</code>, <code>UGW</code></p> <p>Spin-unrestricted one-shot GW via self-energy moment constraints for periodic systems.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>KSCF</code> <p>PySCF periodic mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.pbc.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>fc</code> <code>bool</code> <p>If <code>True</code>, apply finite size corrections. Default value is <code>False</code>.</p> required Source code in <code>momentGW/pbc/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Options\n    self.fc = False\n\n    # Attributes\n    self._kpts = KPoints(self.cell, getattr(mf, \"kpts\", np.zeros((1, 3))))\n</code></pre>"},{"location":"reference/pbc/uhf/gw/#momentGW.pbc.uhf.gw.KUGW.name","title":"<code>momentGW.pbc.uhf.gw.KUGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/pbc/uhf/gw/#momentGW.pbc.uhf.gw.KUGW.build_se_static","title":"<code>momentGW.pbc.uhf.gw.KUGW.build_se_static(integrals)</code>","text":"<p>Build the static part of the self-energy, including the Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>integrals</code> <code>KUIntegrals</code> <p>Integrals object.</p> required <p>Returns:</p> Name Type Description <code>se_static</code> <code>ndarray</code> <p>Static part of the self-energy at each k-point for each spin channel. If <code>self.diagonal_se</code>, non-diagonal elements are set to zero.</p> Source code in <code>momentGW/pbc/uhf/gw.py</code> <pre><code>@logging.with_timer(\"Static self-energy\")\n@logging.with_status(\"Building static self-energy\")\ndef build_se_static(self, integrals):\n    \"\"\"\n    Build the static part of the self-energy, including the Fock\n    matrix.\n\n    Parameters\n    ----------\n    integrals : KUIntegrals\n        Integrals object.\n\n    Returns\n    -------\n    se_static : numpy.ndarray\n        Static part of the self-energy at each k-point for each spin\n        channel. If `self.diagonal_se`, non-diagonal elements are\n        set to zero.\n    \"\"\"\n    return super().build_se_static(integrals)\n</code></pre>"},{"location":"reference/pbc/uhf/gw/#momentGW.pbc.uhf.gw.KUGW.ao2mo","title":"<code>momentGW.pbc.uhf.gw.KUGW.ao2mo(transform=True)</code>","text":"<p>Get the integrals object.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <code>bool</code> <p>Whether to transform the integrals object.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>integrals</code> <code>KUIntegrals</code> <p>Integrals object.</p> Source code in <code>momentGW/pbc/uhf/gw.py</code> <pre><code>@logging.with_timer(\"Integral construction\")\n@logging.with_status(\"Constructing integrals\")\ndef ao2mo(self, transform=True):\n    \"\"\"Get the integrals object.\n\n    Parameters\n    ----------\n    transform : bool, optional\n        Whether to transform the integrals object.\n\n    Returns\n    -------\n    integrals : KUIntegrals\n        Integrals object.\n    \"\"\"\n\n    # Get the integrals\n    integrals = KUIntegrals(\n        self.with_df,\n        self.kpts,\n        self.mo_coeff,\n        self.mo_occ,\n        compression=self.compression,\n        compression_tol=self.compression_tol,\n        store_full=self.has_fock_loop,\n    )\n\n    # Transform the integrals\n    if transform:\n        integrals.transform()\n\n    return integrals\n</code></pre>"},{"location":"reference/pbc/uhf/gw/#momentGW.pbc.uhf.gw.KUGW.build_se_moments","title":"<code>momentGW.pbc.uhf.gw.KUGW.build_se_moments(nmom_max, integrals, **kwargs)</code>","text":"<p>Build the moments of the self-energy.</p> <p>Parameters:</p> Name Type Description Default <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>integrals</code> <code>KUIntegrals</code> <p>Density-fitted integrals.</p> required <code>See</code> required <p>Returns:</p> Name Type Description <code>se_moments_hole</code> <code>ndarray</code> <p>Moments of the hole self-energy at each k-point for each spin channel. If <code>self.diagonal_se</code>, non-diagonal elements are set to zero.</p> <code>se_moments_part</code> <code>ndarray</code> <p>Moments of the particle self-energy at each k-point for each spin channel. If <code>self.diagonal_se</code>, non-diagonal elements are set to zero.</p> Source code in <code>momentGW/pbc/uhf/gw.py</code> <pre><code>def build_se_moments(self, nmom_max, integrals, **kwargs):\n    \"\"\"Build the moments of the self-energy.\n\n    Parameters\n    ----------\n    nmom_max : int\n        Maximum moment number to calculate.\n    integrals : KUIntegrals\n        Density-fitted integrals.\n\n    See functions in `momentGW.rpa` for `kwargs` options.\n\n    Returns\n    -------\n    se_moments_hole : numpy.ndarray\n        Moments of the hole self-energy at each k-point for each\n        spin channel. If `self.diagonal_se`, non-diagonal elements\n        are set to zero.\n    se_moments_part : numpy.ndarray\n        Moments of the particle self-energy at each k-point for each\n        spin channel. If `self.diagonal_se`, non-diagonal elements\n        are set to zero.\n    \"\"\"\n\n    if self.polarizability.lower() == \"dtda\":\n        tda = dTDA(self, nmom_max, integrals, **kwargs)\n        return tda.kernel()\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pbc/uhf/gw/#momentGW.pbc.uhf.gw.KUGW.solve_dyson","title":"<code>momentGW.pbc.uhf.gw.KUGW.solve_dyson(se_moments_hole, se_moments_part, se_static, integrals=None)</code>","text":"<p>Solve the Dyson equation due to a self-energy resulting from a list of hole and particle moments, along with a static contribution.</p> <p>Also finds a chemical potential best satisfying the physical number of electrons. If <code>self.optimise_chempot</code>, this will shift the self-energy poles relative to the Green's function, which is a partial self-consistency that better conserves the particle number.</p> <p>If <code>self.fock_loop</code>, this function will also require that the outputted Green's function is self-consistent with respect to the corresponding density and Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>se_moments_hole</code> <code>ndarray</code> <p>Moments of the hole self-energy at each k-point for each spin channel.</p> required <code>se_moments_part</code> <code>ndarray</code> <p>Moments of the particle self-energy at each k-point for each spin channel.</p> required <code>se_static</code> <code>ndarray</code> <p>Static part of the self-energy at each k-point for each spin channel.</p> required <code>integrals</code> <code>KUIntegrals</code> <p>Density-fitted integrals. Required if <code>self.fock_loop</code> is <code>True</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>gf</code> <code>list of list of dyson.Lehmann</code> <p>Green's function at each k-point for each spin channel.</p> <code>se</code> <code>list of list of dyson.Lehmann</code> <p>Self-energy at each k-point for each spin channel.</p> Source code in <code>momentGW/pbc/uhf/gw.py</code> <pre><code>def solve_dyson(self, se_moments_hole, se_moments_part, se_static, integrals=None):\n    \"\"\"Solve the Dyson equation due to a self-energy resulting\n    from a list of hole and particle moments, along with a static\n    contribution.\n\n    Also finds a chemical potential best satisfying the physical\n    number of electrons. If `self.optimise_chempot`, this will\n    shift the self-energy poles relative to the Green's function,\n    which is a partial self-consistency that better conserves the\n    particle number.\n\n    If `self.fock_loop`, this function will also require that the\n    outputted Green's function is self-consistent with respect to\n    the corresponding density and Fock matrix.\n\n    Parameters\n    ----------\n    se_moments_hole : numpy.ndarray\n        Moments of the hole self-energy at each k-point for each\n        spin channel.\n    se_moments_part : numpy.ndarray\n        Moments of the particle self-energy at each k-point for\n        each spin channel.\n    se_static : numpy.ndarray\n        Static part of the self-energy at each k-point for each\n        spin channel.\n    integrals : KUIntegrals, optional\n        Density-fitted integrals. Required if `self.fock_loop`\n        is `True`. Default value is `None`.\n\n    Returns\n    -------\n    gf : list of list of dyson.Lehmann\n        Green's function at each k-point for each spin channel.\n    se : list of list of dyson.Lehmann\n        Self-energy at each k-point for each spin channel.\n    \"\"\"\n\n    # Solve the Dyson equation for the moments\n    with logging.with_modifiers(status=\"Solving Dyson equation\", timer=\"Dyson equation\"):\n        se = [[], []]\n        for k in self.kpts.loop(1):\n            solver_occ = MBLSE(se_static[0][k], np.array(se_moments_hole[0][k]))\n            solver_occ.kernel()\n\n            solver_vir = MBLSE(se_static[0][k], np.array(se_moments_part[0][k]))\n            solver_vir.kernel()\n\n            solver = MixedMBLSE(solver_occ, solver_vir)\n            se[0].append(solver.get_self_energy())\n\n            solver_occ = MBLSE(se_static[1][k], np.array(se_moments_hole[1][k]))\n            solver_occ.kernel()\n\n            solver_vir = MBLSE(se_static[1][k], np.array(se_moments_part[1][k]))\n            solver_vir.kernel()\n\n            solver = MixedMBLSE(solver_occ, solver_vir)\n            se[1].append(solver.get_self_energy())\n\n    # Initialise the solver\n    solver = FockLoop(self, se=se, **self.fock_opts)\n\n    # Shift the self-energy poles relative to the Green's function\n    # to better conserve the particle number\n    if self.optimise_chempot:\n        se = solver.auxiliary_shift(se_static)\n\n    # Find the error in the moments\n    error_h, error_p = zip(\n        *(\n            zip(\n                *(\n                    self.moment_error(th, tp, s)\n                    for th, tp, s in zip(se_moments_hole[0], se_moments_part[0], se[0])\n                )\n            ),\n            zip(\n                *(\n                    self.moment_error(th, tp, s)\n                    for th, tp, s in zip(se_moments_hole[1], se_moments_part[1], se[1])\n                )\n            ),\n        )\n    )\n    error = ((sum(error_h[0]), sum(error_p[0])), (sum(error_h[1]), sum(error_p[1])))\n    for s, spin in enumerate([\"\u03b1\", \"\u03b2\"]):\n        logging.write(\n            f\"Error in moments ({spin}):  \"\n            f\"[{logging.rate(sum(error[s]), 1e-12, 1e-8)}]{sum(error[s]):.3e}[/] \"\n            f\"(hole = [{logging.rate(error[s][0], 1e-12, 1e-8)}]{error[s][0]:.3e}[/], \"\n            f\"particle = [{logging.rate(error[s][1], 1e-12, 1e-8)}]{error[s][1]:.3e}[/])\"\n        )\n\n    # Solve the Dyson equation for the self-energy\n    gf, error = solver.solve_dyson(se_static)\n    for g, s in zip(gf, se):\n        s[0].chempot = g[0].chempot\n        s[1].chempot = g[1].chempot\n\n    # Self-consistently renormalise the density matrix\n    if self.fock_loop:\n        logging.write(\"\")\n        solver.gf = gf\n        solver.se = se\n        conv, gf, se = solver.kernel(integrals=integrals)\n        _, error = solver.search_chempot(gf)\n\n    # Print the error in the number of electrons\n    logging.write(\"\")\n    color = logging.rate(\n        abs(error),\n        1e-6,\n        1e-6 if self.fock_loop or self.optimise_chempot else 1e-1,\n    )\n    logging.write(f\"Error in number of electrons ({spin}):  [{color}]{error:.3e}[/]\")\n    for s, spin in enumerate([\"\u03b1\", \"\u03b2\"]):\n        logging.write(f\"Chemical potential (\u0393, {spin}):  {gf[s][0].chempot:.6f}\")\n\n    return tuple(tuple(g) for g in gf), tuple(tuple(s) for s in se)\n</code></pre>"},{"location":"reference/pbc/uhf/gw/#momentGW.pbc.uhf.gw.KUGW.kernel","title":"<code>momentGW.pbc.uhf.gw.KUGW.kernel(nmom_max, moments=None, integrals=None)</code>","text":"<p>Driver for the method.</p> <p>Parameters:</p> Name Type Description Default <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>moments</code> <code>tuple of numpy.ndarray</code> <p>Tuple of (hole, particle) moments at each k-point for each spin channel, if passed then they will be used instead of calculating them. Default value is <code>None</code>.</p> <code>None</code> <code>integrals</code> <code>KUIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>converged</code> <code>bool</code> <p>Whether the solver converged. For single-shot calculations, this is always <code>True</code>.</p> <code>gf</code> <code>tuple of tuple of dyson.Lehmann</code> <p>Green's function object at each k-point for each spin channel.</p> <code>se</code> <code>tuple of tuple of dyson.Lehmann</code> <p>Self-energy object at each k-point for each spin channel.</p> <code>qp_energy</code> <code>NoneType</code> <p>Quasiparticle energies. For most GW methods, this is <code>None</code>.</p> Source code in <code>momentGW/pbc/uhf/gw.py</code> <pre><code>def kernel(\n    self,\n    nmom_max,\n    moments=None,\n    integrals=None,\n):\n    \"\"\"Driver for the method.\n\n    Parameters\n    ----------\n    nmom_max : int\n        Maximum moment number to calculate.\n    moments : tuple of numpy.ndarray, optional\n        Tuple of (hole, particle) moments at each k-point for each\n        spin channel, if passed then they will be used instead of\n        calculating them. Default value is `None`.\n    integrals : KUIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    converged : bool\n        Whether the solver converged. For single-shot calculations,\n        this is always `True`.\n    gf : tuple of tuple of dyson.Lehmann\n        Green's function object at each k-point for each spin\n        channel.\n    se : tuple of tuple of dyson.Lehmann\n        Self-energy object at each k-point for each spin channel.\n    qp_energy : NoneType\n        Quasiparticle energies. For most GW methods, this is `None`.\n    \"\"\"\n    return super().kernel(nmom_max, moments=moments, integrals=integrals)\n</code></pre>"},{"location":"reference/pbc/uhf/gw/#momentGW.pbc.uhf.gw.KUGW.make_rdm1","title":"<code>momentGW.pbc.uhf.gw.KUGW.make_rdm1(gf=None)</code>","text":"<p>Get the first-order reduced density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>tuple of tuple of dyson.Lehmann</code> <p>Green's function at each k-point for each spin channel. If <code>None</code>, use either <code>self.gf</code>, or the mean-field Green's function. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>rdm1</code> <code>ndarray</code> <p>First-order reduced density matrix at each k-point for each spin channel.</p> Source code in <code>momentGW/pbc/uhf/gw.py</code> <pre><code>def make_rdm1(self, gf=None):\n    \"\"\"Get the first-order reduced density matrix.\n\n    Parameters\n    ----------\n    gf : tuple of tuple of dyson.Lehmann, optional\n        Green's function at each k-point for each spin channel. If\n        `None`, use either `self.gf`, or the mean-field Green's\n        function. Default value is `None`.\n\n    Returns\n    -------\n    rdm1 : numpy.ndarray\n        First-order reduced density matrix at each k-point for each\n        spin channel.\n    \"\"\"\n\n    # Get the Green's function\n    if gf is None:\n        gf = self.gf\n    if gf is None:\n        gf = self.init_gf()\n\n    return np.array([[g.occupied().moment(0) for g in gs] for gs in gf])\n</code></pre>"},{"location":"reference/pbc/uhf/gw/#momentGW.pbc.uhf.gw.KUGW.energy_hf","title":"<code>momentGW.pbc.uhf.gw.KUGW.energy_hf(gf=None, integrals=None)</code>","text":"<p>Calculate the one-body (Hartree--Fock) energy.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function at each k-point for each spin channel. If <code>None</code>, use either <code>self.gf</code>, or the mean-field Green's function. Default value is <code>None</code>.</p> <code>None</code> <code>integrals</code> <code>KUIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>e_1b</code> <code>float</code> <p>One-body energy.</p> Source code in <code>momentGW/pbc/uhf/gw.py</code> <pre><code>@logging.with_timer(\"Energy\")\n@logging.with_status(\"Calculating energy\")\ndef energy_hf(self, gf=None, integrals=None):\n    \"\"\"Calculate the one-body (Hartree--Fock) energy.\n\n    Parameters\n    ----------\n    gf : tuple of dyson.Lehmann, optional\n        Green's function at each k-point for each spin channel. If\n        `None`, use either `self.gf`, or the mean-field Green's\n        function. Default value is `None`.\n    integrals : KUIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    e_1b : float\n        One-body energy.\n    \"\"\"\n\n    # Get the Green's function\n    if gf is None:\n        gf = self.gf\n\n    # Get the integrals\n    if integrals is None:\n        integrals = self.ao2mo()\n\n    # Find the Fock matrix\n    with util.SilentSCF(self._scf):\n        h1e = util.einsum(\n            \"kpq,skpi,skqj-&gt;skij\", self._scf.get_hcore(), self.mo_coeff.conj(), self.mo_coeff\n        )\n    rdm1 = self.make_rdm1()\n    fock = integrals.get_fock(rdm1, h1e)\n\n    # Calculate the Hartree--Fock energy at each k-point for each\n    # spin\n    e_1b = sum(\n        energy.hartree_fock(rdm1[0][k], fock[0][k], h1e[0][k]) for k in self.kpts.loop(1)\n    )\n    e_1b += sum(\n        energy.hartree_fock(rdm1[1][k], fock[1][k], h1e[1][k]) for k in self.kpts.loop(1)\n    )\n    e_1b /= self.nkpts\n\n    return e_1b.real\n</code></pre>"},{"location":"reference/pbc/uhf/gw/#momentGW.pbc.uhf.gw.KUGW.energy_gm","title":"<code>momentGW.pbc.uhf.gw.KUGW.energy_gm(gf=None, se=None, g0=True)</code>","text":"<p>Calculate the two-body (Galitskii--Migdal) energy.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>tuple of tuple of dyson.Lehmann</code> <p>Green's function at each k-point for each spin channel. If <code>None</code>, use <code>self.gf</code>. Default value is <code>None</code>.</p> <code>None</code> <code>se</code> <code>tuple of tuple of dyson.Lehmann</code> <p>Self-energy at each k-point for each spin channel. If <code>None</code>, use <code>self.se</code>. Default value is <code>None</code>.</p> <code>None</code> <code>g0</code> <code>bool</code> <p>If <code>True</code>, use the mean-field Green's function. Default value is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>e_2b</code> <code>float</code> <p>Two-body energy.</p> Notes <p>With <code>g0=False</code>, this function scales as :math:<code>\\mathcal{O}(N^4)</code> with system size, whereas with <code>g0=True</code>, it scales as :math:<code>\\mathcal{O}(N^3)</code>.</p> Source code in <code>momentGW/pbc/uhf/gw.py</code> <pre><code>@logging.with_timer(\"Energy\")\n@logging.with_status(\"Calculating energy\")\ndef energy_gm(self, gf=None, se=None, g0=True):\n    r\"\"\"Calculate the two-body (Galitskii--Migdal) energy.\n\n    Parameters\n    ----------\n    gf : tuple of tuple of dyson.Lehmann, optional\n        Green's function at each k-point for each spin channel. If\n        `None`, use `self.gf`. Default value is `None`.\n    se : tuple of tuple of dyson.Lehmann, optional\n        Self-energy at each k-point for each spin channel. If\n        `None`, use `self.se`. Default value is `None`.\n    g0 : bool, optional\n        If `True`, use the mean-field Green's function. Default\n        value is `True`.\n\n    Returns\n    -------\n    e_2b : float\n        Two-body energy.\n\n    Notes\n    -----\n    With `g0=False`, this function scales as\n    :math:`\\mathcal{O}(N^4)` with system size, whereas with\n    `g0=True`, it scales as :math:`\\mathcal{O}(N^3)`.\n    \"\"\"\n\n    # Get the Green's function and self-energy\n    if gf is None:\n        gf = self.gf\n    if se is None:\n        se = self.se\n\n    # Calculate the Galitskii--Migdal energy\n    if g0:\n        e_2b_\u03b1 = sum(\n            energy.galitskii_migdal_g0(self.mo_energy[0][k], self.mo_occ[0][k], se[0][k])\n            for k in self.kpts.loop(1)\n        )\n        e_2b_\u03b2 = sum(\n            energy.galitskii_migdal_g0(self.mo_energy[1][k], self.mo_occ[1][k], se[1][k])\n            for k in self.kpts.loop(1)\n        )\n    else:\n        e_2b_\u03b1 = sum(energy.galitskii_migdal(gf[0][k], se[0][k]) for k in self.kpts.loop(1))\n        e_2b_\u03b2 = sum(energy.galitskii_migdal(gf[1][k], se[1][k]) for k in self.kpts.loop(1))\n\n    # Add the parts\n    e_2b = (e_2b_\u03b1 + e_2b_\u03b2) / 2\n\n    return e_2b.real\n</code></pre>"},{"location":"reference/pbc/uhf/gw/#momentGW.pbc.uhf.gw.KUGW.interpolate","title":"<code>momentGW.pbc.uhf.gw.KUGW.interpolate(mf, nmom_max)</code>","text":"<p>Interpolate the object to a new k-point grid, represented by a new mean-field object.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>KSCF</code> <p>Mean-field object on new k-point mesh.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <p>Returns:</p> Name Type Description <code>other</code> <code>__class__</code> <p>Interpolated object.</p> Source code in <code>momentGW/pbc/uhf/gw.py</code> <pre><code>@logging.with_timer(\"Interpolation\")\n@logging.with_status(\"Interpolating in k-space\")\ndef interpolate(self, mf, nmom_max):\n    \"\"\"\n    Interpolate the object to a new k-point grid, represented by a\n    new mean-field object.\n\n    Parameters\n    ----------\n    mf : pyscf.pbc.scf.KSCF\n        Mean-field object on new k-point mesh.\n    nmom_max : int\n        Maximum moment number to calculate.\n\n    Returns\n    -------\n    other : __class__\n        Interpolated object.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pbc/uhf/gw/#momentGW.pbc.uhf.gw.KUGW.init_gf","title":"<code>momentGW.pbc.uhf.gw.KUGW.init_gf(mo_energy=None)</code>","text":"<p>Initialise the mean-field Green's function.</p> <p>Parameters:</p> Name Type Description Default <code>mo_energy</code> <code>ndarray</code> <p>Molecular orbital energies at each k-point for each spin channel. Default value is <code>self.mo_energy</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>gf</code> <code>tuple of tuple of dyson.Lehmann</code> <p>Mean-field Green's function at each k-point for each spin channel.</p> Source code in <code>momentGW/pbc/uhf/gw.py</code> <pre><code>def init_gf(self, mo_energy=None):\n    \"\"\"Initialise the mean-field Green's function.\n\n    Parameters\n    ----------\n    mo_energy : numpy.ndarray, optional\n        Molecular orbital energies at each k-point for each spin\n        channel. Default value is `self.mo_energy`.\n\n    Returns\n    -------\n    gf : tuple of tuple of dyson.Lehmann\n        Mean-field Green's function at each k-point for each spin\n        channel.\n    \"\"\"\n\n    if mo_energy is None:\n        mo_energy = self.mo_energy\n\n    gf = [[], []]\n    for s in range(2):\n        for k in self.kpts.loop(1):\n            gf[s].append(Lehmann(mo_energy[s][k], np.eye(self.nmo[s])))\n\n        ws = [g.energies for g in gf[s]]\n        vs = [g.couplings for g in gf[s]]\n        chempot = search_chempot_unconstrained(\n            ws, vs, self.nmo[s], sum(self.nocc[s]), occupancy=1\n        )[0]\n\n        for k in self.kpts.loop(1):\n            gf[s][k].chempot = chempot\n\n        gf[s] = tuple(gf[s])\n\n    return tuple(gf)\n</code></pre>"},{"location":"reference/pbc/uhf/ints/","title":"Ints","text":"<p>Integral helpers with periodic boundary conditions and unrestricted reference.</p>"},{"location":"reference/pbc/uhf/ints/#momentGW.pbc.uhf.ints.KUIntegrals","title":"<code>momentGW.pbc.uhf.ints.KUIntegrals(with_df, kpts, mo_coeff, mo_occ, compression='ia', compression_tol=1e-10, store_full=False)</code>","text":"<p>             Bases: <code>UIntegrals</code>, <code>KIntegrals</code></p> <p>Container for the density-fitted integrals required for KUGW methods.</p> <p>Parameters:</p> Name Type Description Default <code>with_df</code> <code>DF</code> <p>Density fitting object.</p> required <code>mo_coeff</code> <code>ndarray</code> <p>Molecular orbital coefficients at each k-point for each spin channel.</p> required <code>mo_occ</code> <code>ndarray</code> <p>Molecular orbital occupations at each k-point for each spin channel.</p> required <code>compression</code> <code>str</code> <p>Compression scheme to use. Default value is <code>'ia'</code>. See <code>momentGW.gw</code> for more details.</p> <code>'ia'</code> <code>compression_tol</code> <code>float</code> <p>Compression tolerance. Default value is <code>1e-10</code>. See <code>momentGW.gw</code> for more details.</p> <code>1e-10</code> <code>store_full</code> <code>bool</code> <p>Store the full MO integrals in memory. Default value is <code>False</code>.</p> <code>False</code> Source code in <code>momentGW/pbc/uhf/ints.py</code> <pre><code>def __init__(\n    self,\n    with_df,\n    kpts,\n    mo_coeff,\n    mo_occ,\n    compression=\"ia\",\n    compression_tol=1e-10,\n    store_full=False,\n):\n    # Parameters\n    self.with_df = with_df\n    self.mo_coeff = mo_coeff\n    self.mo_occ = mo_occ\n\n    # Options\n    self.compression = compression\n    self.compression_tol = compression_tol\n    self.store_full = store_full\n\n    # Attributes\n    self.kpts = kpts\n    self._spins = {\n        0: _KIntegrals_\u03b1(\n            self.with_df,\n            self.kpts,\n            self.mo_coeff[0],\n            self.mo_occ[0],\n            compression=self.compression,\n            compression_tol=self.compression_tol,\n            store_full=self.store_full,\n        ),\n        1: _KIntegrals_\u03b2(\n            self.with_df,\n            self.kpts,\n            self.mo_coeff[1],\n            self.mo_occ[1],\n            compression=self.compression,\n            compression_tol=self.compression_tol,\n            store_full=self.store_full,\n        ),\n    }\n    self._madelung = None\n</code></pre>"},{"location":"reference/pbc/uhf/ints/#momentGW.pbc.uhf.ints.KUIntegrals.get_compression_metric","title":"<code>momentGW.pbc.uhf.ints.KUIntegrals.get_compression_metric()</code>","text":"<p>Return the compression metric.</p> <p>Returns:</p> Name Type Description <code>rot</code> <code>ndarray</code> <p>Rotation matrix into the compressed auxiliary space.</p> Source code in <code>momentGW/pbc/uhf/ints.py</code> <pre><code>@logging.with_status(\"Computing compression metric\")\ndef get_compression_metric(self):\n    \"\"\"\n    Return the compression metric.\n\n    Returns\n    -------\n    rot : numpy.ndarray\n        Rotation matrix into the compressed auxiliary space.\n    \"\"\"\n\n    # Get the compression sectors\n    compression = self._parse_compression()\n    if not compression:\n        return None\n\n    # Initialise the inner product matrix\n    prod = np.zeros((len(self.kpts), self.naux_full, self.naux_full), dtype=complex)\n\n    # Loop over required blocks\n    for key in sorted(compression):\n        for s, spin in enumerate([\"\u03b1\", \"\u03b2\"]):\n            with logging.with_status(f\"{key} ({spin}) sector\"):\n                # Get the coefficients\n                ci, cj = [\n                    {\n                        \"o\": [c[:, o &gt; 0] for c, o in zip(self.mo_coeff[s], self.mo_occ[s])],\n                        \"v\": [c[:, o == 0] for c, o in zip(self.mo_coeff[s], self.mo_occ[s])],\n                        \"i\": [\n                            c[:, o &gt; 0] for c, o in zip(self.mo_coeff_w[s], self.mo_occ_w[s])\n                        ],\n                        \"a\": [\n                            c[:, o == 0] for c, o in zip(self.mo_coeff_w[s], self.mo_occ_w[s])\n                        ],\n                    }[k]\n                    for k in key\n                ]\n                ni = [c.shape[-1] for c in ci]\n                nj = [c.shape[-1] for c in cj]\n\n                for q, ki in self.kpts.loop(2):\n                    kj = self.kpts.member(self.kpts.wrap_around(self.kpts[ki] - self.kpts[q]))\n\n                    # Build the (L|xy) array\n                    Lxy = np.zeros((self.naux_full, ni[ki] * nj[kj]), dtype=complex)\n                    b1 = 0\n                    for block in self.with_df.sr_loop((ki, kj), compact=False):\n                        if block[2] == -1:\n                            raise NotImplementedError(\"Low dimensional integrals\")\n                        block = block[0] + block[1] * 1.0j\n                        block = block.reshape(self.naux_full, self.nao, self.nao)\n                        b0, b1 = b1, b1 + block.shape[0]\n                        progress = ki * len(self.kpts) ** 2 + kj * len(self.kpts) + b0\n                        progress /= len(self.kpts) ** 2 + self.naux_full\n\n                        with logging.with_status(\n                            f\"block [{ki}, {kj}, {b0}:{b1}] ({progress:.1%})\"\n                        ):\n                            # TODO optimise\n                            tmp = util.einsum(\"Lpq,pi,qj-&gt;Lij\", block, ci[ki].conj(), cj[kj])\n                            tmp = tmp.reshape(b1 - b0, -1)\n                            Lxy[b0:b1] = tmp\n\n                    # Update the inner product matrix\n                    prod[q] += np.dot(Lxy, Lxy.T.conj()) / len(self.kpts)\n\n    prod *= 0.5\n\n    # Diagonalise the inner product matrix\n    rot = np.empty((len(self.kpts),), dtype=object)\n    if mpi_helper.rank == 0:\n        for q in self.kpts.loop(1):\n            e, v = np.linalg.eigh(prod[q])\n            mask = np.abs(e) &gt; self.compression_tol\n            rot[q] = v[:, mask]\n    else:\n        for q in self.kpts.loop(1):\n            rot[q] = np.zeros((0,), dtype=complex)\n    del prod\n\n    # Print the compression status\n    naux_total = sum(r.shape[-1] for r in rot)\n    naux_full_total = self.naux_full * len(self.kpts)\n    if naux_total == naux_full_total:\n        logging.write(\"No compression found for auxiliary space\")\n        rot = None\n    else:\n        percent = 100 * naux_total / naux_full_total\n        style = logging.rate(percent, 80, 95)\n        logging.write(\n            f\"Compressed auxiliary space from {naux_full_total} to {naux_total} \"\n            f\"([{style}]{percent:.1f}%)[/]\"\n        )\n\n    return rot\n</code></pre>"},{"location":"reference/pbc/uhf/ints/#momentGW.pbc.uhf.ints.KUIntegrals.update_coeffs","title":"<code>momentGW.pbc.uhf.ints.KUIntegrals.update_coeffs(mo_coeff_g=None, mo_coeff_w=None, mo_occ_w=None)</code>","text":"<p>Update the MO coefficients for the Green's function and the screened Coulomb interaction.</p> <p>Parameters:</p> Name Type Description Default <code>mo_coeff_g</code> <code>ndarray</code> <p>Coefficients corresponding to the Green's function at each k-point for each spin channel. Default value is <code>None</code>.</p> <code>None</code> <code>mo_coeff_w</code> <code>ndarray</code> <p>Coefficients corresponding to the screened Coulomb interaction at each k-point for each spin channel. Default value is <code>None</code>.</p> <code>None</code> <code>mo_occ_w</code> <code>ndarray</code> <p>Occupations corresponding to the screened Coulomb interaction at each k-point for each spin channel. Default value is <code>None</code>.</p> <code>None</code> Notes <p>If <code>mo_coeff_g</code> is <code>None</code>, the Green's function is assumed to remain in the basis in which it was originally defined, and vice-versa for <code>mo_coeff_w</code> and <code>mo_occ_w</code>. At least one of <code>mo_coeff_g</code> and <code>mo_coeff_w</code> must be provided.</p> Source code in <code>momentGW/pbc/uhf/ints.py</code> <pre><code>def update_coeffs(self, mo_coeff_g=None, mo_coeff_w=None, mo_occ_w=None):\n    \"\"\"\n    Update the MO coefficients for the Green's function and the\n    screened Coulomb interaction.\n\n    Parameters\n    ----------\n    mo_coeff_g : numpy.ndarray, optional\n        Coefficients corresponding to the Green's function at each\n        k-point for each spin channel. Default value is `None`.\n    mo_coeff_w : numpy.ndarray, optional\n        Coefficients corresponding to the screened Coulomb\n        interaction at each k-point for each spin channel. Default\n        value is `None`.\n    mo_occ_w : numpy.ndarray, optional\n        Occupations corresponding to the screened Coulomb\n        interaction at each k-point for each spin channel. Default\n        value is `None`.\n\n    Notes\n    -----\n    If `mo_coeff_g` is `None`, the Green's function is assumed to\n    remain in the basis in which it was originally defined, and\n    vice-versa for `mo_coeff_w` and `mo_occ_w`. At least one of\n    `mo_coeff_g` and `mo_coeff_w` must be provided.\n    \"\"\"\n    return super().update_coeffs(\n        mo_coeff_g=mo_coeff_g,\n        mo_coeff_w=mo_coeff_w,\n        mo_occ_w=mo_occ_w,\n    )\n</code></pre>"},{"location":"reference/pbc/uhf/ints/#momentGW.pbc.uhf.ints.KUIntegrals.get_j","title":"<code>momentGW.pbc.uhf.ints.KUIntegrals.get_j(dm, basis='mo')</code>","text":"<p>Build the J matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix at each k-point for each spin channel.</p> required <code>basis</code> <code>str</code> <p>Basis in which to build the J matrix. One of <code>(\"ao\", \"mo\")</code>. Default value is <code>\"mo\"</code>.</p> <code>'mo'</code> <p>Returns:</p> Name Type Description <code>vj</code> <code>ndarray</code> <p>J matrix at each k-point for each spin channel.</p> Source code in <code>momentGW/pbc/uhf/ints.py</code> <pre><code>def get_j(self, dm, basis=\"mo\"):\n    \"\"\"Build the J matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix at each k-point for each spin channel.\n    basis : str, optional\n        Basis in which to build the J matrix. One of\n        `(\"ao\", \"mo\")`. Default value is `\"mo\"`.\n\n    Returns\n    -------\n    vj : numpy.ndarray\n        J matrix at each k-point for each spin channel.\n    \"\"\"\n    return super().get_j(dm, basis=basis)\n</code></pre>"},{"location":"reference/pbc/uhf/ints/#momentGW.pbc.uhf.ints.KUIntegrals.get_k","title":"<code>momentGW.pbc.uhf.ints.KUIntegrals.get_k(dm, basis='mo')</code>","text":"<p>Build the K matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix at each k-point for each spin channel.</p> required <code>basis</code> <code>str</code> <p>Basis in which to build the K matrix. One of <code>(\"ao\", \"mo\")</code>. Default value is <code>\"mo\"</code>.</p> <code>'mo'</code> <p>Returns:</p> Name Type Description <code>vk</code> <code>ndarray</code> <p>K matrix for each spin channel.</p> Source code in <code>momentGW/pbc/uhf/ints.py</code> <pre><code>def get_k(self, dm, basis=\"mo\"):\n    \"\"\"Build the K matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix at each k-point for each spin channel.\n    basis : str, optional\n        Basis in which to build the K matrix. One of\n        `(\"ao\", \"mo\")`. Default value is `\"mo\"`.\n\n    Returns\n    -------\n    vk : numpy.ndarray\n        K matrix for each spin channel.\n    \"\"\"\n    return super().get_k(dm, basis=basis)\n</code></pre>"},{"location":"reference/pbc/uhf/ints/#momentGW.pbc.uhf.ints.KUIntegrals.get_jk","title":"<code>momentGW.pbc.uhf.ints.KUIntegrals.get_jk(dm, **kwargs)</code>","text":"<p>Build the J and K matrices.</p> <p>Returns:</p> Name Type Description <code>vj</code> <code>ndarray</code> <p>J matrix at each k-point for each spin channel.</p> <code>vk</code> <code>ndarray</code> <p>K matrix at each k-point for each spin channel.</p> Notes <p>See <code>get_j</code> and <code>get_k</code> for more information.</p> Source code in <code>momentGW/pbc/uhf/ints.py</code> <pre><code>def get_jk(self, dm, **kwargs):\n    \"\"\"Build the J and K matrices.\n\n    Returns\n    -------\n    vj : numpy.ndarray\n        J matrix at each k-point for each spin channel.\n    vk : numpy.ndarray\n        K matrix at each k-point for each spin channel.\n\n    Notes\n    -----\n    See `get_j` and `get_k` for more information.\n    \"\"\"\n    return super().get_jk(dm, **kwargs)\n</code></pre>"},{"location":"reference/pbc/uhf/ints/#momentGW.pbc.uhf.ints.KUIntegrals.get_veff","title":"<code>momentGW.pbc.uhf.ints.KUIntegrals.get_veff(dm, j=None, k=None, **kwargs)</code>","text":"<p>Build the effective potential.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix at each k-point for each spin channel.</p> required <code>j</code> <code>ndarray</code> <p>J matrix at each k-point for each spin channel. If <code>None</code>, compute it. Default value is <code>None</code>.</p> <code>None</code> <code>k</code> <code>ndarray</code> <p>K matrix at each k-point for each spin channel. If <code>None</code>, compute it. Default value is <code>None</code>.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for <code>get_jk</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>veff</code> <code>ndarray</code> <p>Effective potential at each k-point for each spin channel.</p> Notes <p>See <code>get_jk</code> for more information.</p> Source code in <code>momentGW/pbc/uhf/ints.py</code> <pre><code>def get_veff(self, dm, j=None, k=None, **kwargs):\n    \"\"\"Build the effective potential.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix at each k-point for each spin channel.\n    j : numpy.ndarray, optional\n        J matrix at each k-point for each spin channel. If `None`,\n        compute it. Default value is `None`.\n    k : numpy.ndarray, optional\n        K matrix at each k-point for each spin channel. If `None`,\n        compute it. Default value is `None`.\n    **kwargs : dict, optional\n        Additional keyword arguments for `get_jk`.\n\n    Returns\n    -------\n    veff : numpy.ndarray\n        Effective potential at each k-point for each spin channel.\n\n    Notes\n    -----\n    See `get_jk` for more information.\n    \"\"\"\n    return super().get_veff(dm, j=j, k=k, **kwargs)\n</code></pre>"},{"location":"reference/pbc/uhf/ints/#momentGW.pbc.uhf.ints.KUIntegrals.get_fock","title":"<code>momentGW.pbc.uhf.ints.KUIntegrals.get_fock(dm, h1e, **kwargs)</code>","text":"<p>Build the Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix at each k-point for each spin channel.</p> required <code>h1e</code> <code>ndarray</code> <p>Core Hamiltonian matrix at each k-point for each spin channel.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for <code>get_jk</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>fock</code> <code>ndarray</code> <p>Fock matrix at each k-point for each spin channel.</p> Notes <p>See <code>get_jk</code> for more information. The basis of <code>h1e</code> must be the same as <code>dm</code>.</p> Source code in <code>momentGW/pbc/uhf/ints.py</code> <pre><code>def get_fock(self, dm, h1e, **kwargs):\n    \"\"\"Build the Fock matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix at each k-point for each spin channel.\n    h1e : numpy.ndarray\n        Core Hamiltonian matrix at each k-point for each spin\n        channel.\n    **kwargs : dict, optional\n        Additional keyword arguments for `get_jk`.\n\n    Returns\n    -------\n    fock : numpy.ndarray\n        Fock matrix at each k-point for each spin channel.\n\n    Notes\n    -----\n    See `get_jk` for more information. The basis of `h1e` must be\n    the same as `dm`.\n    \"\"\"\n    return super().get_fock(dm, h1e, **kwargs)\n</code></pre>"},{"location":"reference/pbc/uhf/qsgw/","title":"Qsgw","text":"<p>Spin-unrestricted quasiparticle self-consistent GW via self-energy moment constraints for periodic systems.</p>"},{"location":"reference/pbc/uhf/qsgw/#momentGW.pbc.uhf.qsgw.qsKUGW","title":"<code>momentGW.pbc.uhf.qsgw.qsKUGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>KUGW</code>, <code>qsKGW</code>, <code>qsUGW</code></p> <p>Spin-unrestricted quasiparticle self-consistent GW via self-energy moment constraints for periodic systems.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>KSCF</code> <p>PySCF periodic mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>fc</code> <code>bool</code> <p>If <code>True</code>, apply finite size corrections. Default value is <code>False</code>.</p> required <code>max_cycle</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>50</code>.</p> required <code>max_cycle_qp</code> <code>int</code> <p>Maximum number of iterations in the quasiparticle equation loop. Default value is <code>50</code>.</p> required <code>conv_tol</code> <code>float</code> <p>Convergence threshold in the change in the HOMO and LUMO. Default value is <code>1e-8</code>.</p> required <code>conv_tol_moms</code> <code>float</code> <p>Convergence threshold in the change in the moments. Default value is <code>1e-8</code>.</p> required <code>conv_tol_qp</code> <code>float</code> <p>Convergence threshold in the change in the density matrix in the quasiparticle equation loop. Default value is <code>1e-8</code>.</p> required <code>conv_logical</code> <code>callable</code> <p>Function that takes an iterable of booleans as input indicating whether the individual <code>conv_tol</code>, <code>conv_tol_moms</code>, <code>conv_tol_qp</code> have been satisfied, respectively, and returns a boolean indicating overall convergence. For example, the function <code>all</code> requires both metrics to be met, and <code>any</code> requires just one. Default value is <code>all</code>.</p> required <code>diis_space</code> <code>int</code> <p>Size of the DIIS extrapolation space. Default value is <code>8</code>.</p> required <code>diis_space_qp</code> <code>int</code> <p>Size of the DIIS extrapolation space in the quasiparticle loop. Default value is <code>8</code>.</p> required <code>damping</code> <code>float</code> <p>Damping parameter. Default value is <code>0.0</code>.</p> required <code>eta</code> <code>float</code> <p>Small value to regularise the self-energy. Default value is <code>1e-1</code>.</p> required <code>srg</code> <code>float</code> <p>If non-zero, use the similarity renormalisation group approach of Marie and Loos in place of the <code>eta</code> regularisation. For value recommendations refer to their paper (arXiv:2303.05984). Default value is <code>0.0</code>.</p> required <code>solver</code> <code>BaseGW</code> <p>Solver to use to obtain the self-energy. Compatible with any <code>BaseGW</code>-like class. Default value is <code>momentGW.gw.GW</code>.</p> required <code>solver_options</code> <code>dict</code> <p>Keyword arguments to pass to the solver. Default value is an empty <code>dict</code>.</p> required Source code in <code>momentGW/pbc/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Options\n    self.fc = False\n\n    # Attributes\n    self._kpts = KPoints(self.cell, getattr(mf, \"kpts\", np.zeros((1, 3))))\n</code></pre>"},{"location":"reference/pbc/uhf/qsgw/#momentGW.pbc.uhf.qsgw.qsKUGW.name","title":"<code>momentGW.pbc.uhf.qsgw.qsKUGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/pbc/uhf/qsgw/#momentGW.pbc.uhf.qsgw.qsKUGW.project_basis","title":"<code>momentGW.pbc.uhf.qsgw.qsKUGW.project_basis(matrix, ovlp, mo1, mo2)</code>  <code>staticmethod</code>","text":"<p>Project a matrix from one basis to another.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>numpy.ndarray or tuple of dyson.Lehmann</code> <p>Matrix to project at each k-point for each spin channel. Can also be a tuple of <code>dyson.Lehmann</code> objects, in which case the <code>couplings</code> attributes are projected.</p> required <code>ovlp</code> <code>ndarray</code> <p>Overlap matrix in the shared (AO) basis at each k-point.</p> required <code>mo1</code> <code>ndarray</code> <p>First basis, rotates from the shared (AO) basis into the basis of <code>matrix</code> at each k-point for each spin channel.</p> required <code>mo2</code> <code>ndarray</code> <p>Second basis, rotates from the shared (AO) basis into the desired basis of the output at each k-point for each spin channel.</p> required <p>Returns:</p> Name Type Description <code>proj</code> <code>numpy.ndarray or tuple of dyson.Lehmann</code> <p>Matrix projected into the desired basis at each k-point for each spin channel.</p> Source code in <code>momentGW/pbc/uhf/qsgw.py</code> <pre><code>@staticmethod\ndef project_basis(matrix, ovlp, mo1, mo2):\n    \"\"\"\n    Project a matrix from one basis to another.\n\n    Parameters\n    ----------\n    matrix : numpy.ndarray or tuple of dyson.Lehmann\n        Matrix to project at each k-point for each spin channel. Can\n        also be a tuple of `dyson.Lehmann` objects, in which case the\n        `couplings` attributes are projected.\n    ovlp : numpy.ndarray\n        Overlap matrix in the shared (AO) basis at each k-point.\n    mo1 : numpy.ndarray\n        First basis, rotates from the shared (AO) basis into the\n        basis of `matrix` at each k-point for each spin channel.\n    mo2 : numpy.ndarray\n        Second basis, rotates from the shared (AO) basis into the\n        desired basis of the output at each k-point for each spin\n        channel.\n\n    Returns\n    -------\n    proj : numpy.ndarray or tuple of dyson.Lehmann\n        Matrix projected into the desired basis at each k-point\n        for each spin channel.\n    \"\"\"\n\n    # Build the projection matrix\n    proj = util.einsum(\"k...pq,sk...pi,sk...qj-&gt;sk...ij\", ovlp, np.conj(mo1), mo2)\n\n    # Project the matrix\n    if isinstance(matrix, np.ndarray):\n        projected_matrix = util.einsum(\n            \"sk...pq,sk...pi,sk...qj-&gt;sk...ij\", matrix, np.conj(proj), proj\n        )\n    else:\n        projected_matrix = [[], []]\n        for s, ms in enumerate(matrix):\n            for k, m in enumerate(ms):\n                coupling = util.einsum(\"pk,pi-&gt;ik\", m.couplings, np.conj(proj[s][k]))\n                projected_m = m.copy()\n                projected_m.couplings = coupling\n                projected_matrix[s].append(projected_m)\n\n    return projected_matrix\n</code></pre>"},{"location":"reference/pbc/uhf/qsgw/#momentGW.pbc.uhf.qsgw.qsKUGW.self_energy_to_moments","title":"<code>momentGW.pbc.uhf.qsgw.qsKUGW.self_energy_to_moments(se, nmom_max)</code>  <code>staticmethod</code>","text":"<p>Return the hole and particle moments for a self-energy.</p> <p>Parameters:</p> Name Type Description Default <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy to compute the moments of at each k-point for each spin channel.</p> required <p>Returns:</p> Name Type Description <code>th</code> <code>ndarray</code> <p>Hole moments at each k-point for each spin channel.</p> <code>tp</code> <code>ndarray</code> <p>Particle moments at each k-point for each spin channel.</p> Source code in <code>momentGW/pbc/uhf/qsgw.py</code> <pre><code>@staticmethod\ndef self_energy_to_moments(se, nmom_max):\n    \"\"\"\n    Return the hole and particle moments for a self-energy.\n\n    Parameters\n    ----------\n    se : tuple of dyson.Lehmann\n        Self-energy to compute the moments of at each k-point\n        for each spin channel.\n\n    Returns\n    -------\n    th : numpy.ndarray\n        Hole moments at each k-point for each spin channel.\n    tp : numpy.ndarray\n        Particle moments at each k-point for each spin channel.\n    \"\"\"\n    th = np.array([[s.occupied().moment(range(nmom_max + 1)) for s in ses] for ses in se])\n    tp = np.array([[s.virtual().moment(range(nmom_max + 1)) for s in ses] for ses in se])\n    return th, tp\n</code></pre>"},{"location":"reference/pbc/uhf/qsgw/#momentGW.pbc.uhf.qsgw.qsKUGW.build_static_potential","title":"<code>momentGW.pbc.uhf.qsgw.qsKUGW.build_static_potential(mo_energy, se)</code>","text":"<p>Build the static potential approximation to the self-energy.</p> <p>Parameters:</p> Name Type Description Default <code>mo_energy</code> <code>ndarray</code> <p>Molecular orbital energies at each k-point for each spin channel.</p> required <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy to approximate at each k-point for each spin channel.</p> required <p>Returns:</p> Name Type Description <code>se_qp</code> <code>ndarray</code> <p>Static potential approximation to the self-energy at each k-point for each spin channel.</p> Source code in <code>momentGW/pbc/uhf/qsgw.py</code> <pre><code>def build_static_potential(self, mo_energy, se):\n    \"\"\"\n    Build the static potential approximation to the self-energy.\n\n    Parameters\n    ----------\n    mo_energy : numpy.ndarray\n        Molecular orbital energies at each k-point for each spin\n        channel.\n    se : tuple of dyson.Lehmann\n        Self-energy to approximate at each k-point for each spin\n        channel.\n\n    Returns\n    -------\n    se_qp : numpy.ndarray\n        Static potential approximation to the self-energy at each\n        k-point for each spin channel.\n    \"\"\"\n    return np.array(\n        [\n            [qsGW.build_static_potential(self, mo, s) for mo, s in zip(mos, ses)]\n            for mos, ses in zip(mo_energy, se)\n        ]\n    )\n</code></pre>"},{"location":"reference/pbc/uhf/scgw/","title":"Scgw","text":"<p>Spin-unrestricted self-consistent GW via self-energy moment constraints for periodic systems.</p>"},{"location":"reference/pbc/uhf/scgw/#momentGW.pbc.uhf.scgw.scKUGW","title":"<code>momentGW.pbc.uhf.scgw.scKUGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>KUGW</code>, <code>scKGW</code>, <code>scUGW</code></p> <p>Spin-unrestricted self-consistent GW via self-energy moment constraints for periodic systems.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>KSCF</code> <p>PySCF periodic mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>fc</code> <code>bool</code> <p>If <code>True</code>, apply finite size corrections. Default value is <code>False</code>.</p> required <code>g0</code> <code>bool</code> <p>If <code>True</code>, do not self-consistently update the eigenvalues in the Green's function. Default value is <code>False</code>.</p> required <code>w0</code> <code>bool</code> <p>If <code>True</code>, do not self-consistently update the eigenvalues in the screened Coulomb interaction. Default value is <code>False</code>.</p> required <code>max_cycle</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>50</code>.</p> required <code>conv_tol</code> <code>float</code> <p>Convergence threshold in the change in the HOMO and LUMO. Default value is <code>1e-8</code>.</p> required <code>conv_tol_moms</code> <code>float</code> <p>Convergence threshold in the change in the moments. Default value is <code>1e-8</code>.</p> required <code>diis_space</code> <code>int</code> <p>Size of the DIIS extrapolation space. Default value is <code>8</code>.</p> required <code>damping</code> <code>float</code> <p>Damping parameter. Default value is <code>0.0</code>.</p> required Source code in <code>momentGW/pbc/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Options\n    self.fc = False\n\n    # Attributes\n    self._kpts = KPoints(self.cell, getattr(mf, \"kpts\", np.zeros((1, 3))))\n</code></pre>"},{"location":"reference/pbc/uhf/scgw/#momentGW.pbc.uhf.scgw.scKUGW.name","title":"<code>momentGW.pbc.uhf.scgw.scKUGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/pbc/uhf/tda/","title":"Tda","text":"<p>Construct TDA moments with periodic boundary conditions and unrestricted references.</p>"},{"location":"reference/pbc/uhf/tda/#momentGW.pbc.uhf.tda.dTDA","title":"<code>momentGW.pbc.uhf.tda.dTDA(gw, nmom_max, integrals, mo_energy=None, mo_occ=None)</code>","text":"<p>             Bases: <code>dTDA</code>, <code>dTDA</code></p> <p>Compute the self-energy moments using dTDA and numerical integration with periodic boundary conditions and unrestricted references.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseKUGW</code> <p>GW object.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>integrals</code> <code>KUIntegrals</code> <p>Integrals object.</p> required <code>mo_energy</code> <code>dict</code> <p>Molecular orbital energies at each k-point for each spin channel. Keys are \"g\" and \"w\" for the Green's function and screened Coulomb interaction, respectively. If <code>None</code>, use <code>gw.mo_energy</code> for both. Default value is <code>None</code>.</p> <code>None</code> <code>mo_occ</code> <code>dict</code> <p>Molecular orbital occupancies at each k-point for each spin channel. Keys are \"g\" and \"w\" for the Green's function and screened Coulomb interaction, respectively. If <code>None</code>, use <code>gw.mo_occ</code> for both. Default value is <code>None</code>.</p> <code>None</code> Source code in <code>momentGW/tda.py</code> <pre><code>def __init__(\n    self,\n    gw,\n    nmom_max,\n    integrals,\n    mo_energy=None,\n    mo_occ=None,\n):\n    # Attributes\n    self.gw = gw\n    self.nmom_max = nmom_max\n    self.integrals = integrals\n\n    # Get the MO energies for G and W\n    if mo_energy is not None:\n        self.mo_energy_g = mo_energy[\"g\"]\n        self.mo_energy_w = mo_energy[\"w\"]\n    else:\n        self.mo_energy_g = self.mo_energy_w = gw.mo_energy\n\n    # Get the MO occupancies for G and W\n    if mo_occ is not None:\n        self.mo_occ_g = mo_occ[\"g\"]\n        self.mo_occ_w = mo_occ[\"w\"]\n    else:\n        self.mo_occ_g = self.mo_occ_w = gw.mo_occ\n\n    # Options and thresholds\n    self.report_quadrature_error = True\n    if self.gw.compression and \"ia\" in self.gw.compression.split(\",\"):\n        self.compression_tol = gw.compression_tol\n    else:\n        self.compression_tol = None\n</code></pre>"},{"location":"reference/pbc/uhf/tda/#momentGW.pbc.uhf.tda.dTDA.nov","title":"<code>momentGW.pbc.uhf.tda.dTDA.nov</code>  <code>property</code>","text":"<p>Number of ov states in the screened Coulomb interaction.</p>"},{"location":"reference/pbc/uhf/tda/#momentGW.pbc.uhf.tda.dTDA.build_dd_moments","title":"<code>momentGW.pbc.uhf.tda.dTDA.build_dd_moments()</code>","text":"<p>Build the moments of the density-density response.</p> <p>Returns:</p> Name Type Description <code>moments</code> <code>ndarray</code> <p>Moments of the density-density response at each k-point for each spin channel.</p> Source code in <code>momentGW/pbc/uhf/tda.py</code> <pre><code>@logging.with_timer(\"Density-density moments\")\n@logging.with_status(\"Constructing density-density moments\")\ndef build_dd_moments(self):\n    \"\"\"Build the moments of the density-density response.\n\n    Returns\n    -------\n    moments : numpy.ndarray\n        Moments of the density-density response at each k-point\n        for each spin channel.\n    \"\"\"\n\n    # Initialise the moments\n    kpts = self.kpts\n    moments = np.zeros((self.nkpts, self.nkpts, self.nmom_max + 1), dtype=object)\n\n    # Get the zeroth order moment\n    for q in kpts.loop(1):\n        for kj in kpts.loop(1, mpi=True):\n            kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[kj]))\n            moments[q, kb, 0] += (\n                np.concatenate(\n                    [\n                        self.integrals[0].Lia[kj, kb],\n                        self.integrals[1].Lia[kj, kb],\n                    ],\n                    axis=1,\n                )\n                / self.nkpts\n            )\n\n    # Get the higher order moments\n    for i in range(1, self.nmom_max + 1):\n        for q in kpts.loop(1):\n            for kj in kpts.loop(1, mpi=True):\n                kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[kj]))\n\n                d = np.concatenate(\n                    [\n                        util.build_1h1p_energies(\n                            (self.mo_energy_w[0][kj], self.mo_energy_w[0][kb]),\n                            (self.mo_occ_w[0][kj], self.mo_occ_w[0][kb]),\n                        ).ravel(),\n                        util.build_1h1p_energies(\n                            (self.mo_energy_w[1][kj], self.mo_energy_w[1][kb]),\n                            (self.mo_occ_w[1][kj], self.mo_occ_w[1][kb]),\n                        ).ravel(),\n                    ]\n                )\n                moments[q, kb, i] += moments[q, kb, i - 1] * d[None]\n\n            tmp = np.zeros((self.naux[q], self.naux[q]), dtype=complex)\n            for ki in kpts.loop(1, mpi=True):\n                ka = kpts.member(kpts.wrap_around(kpts[q] + kpts[ki]))\n\n                Lia = np.concatenate(\n                    [\n                        self.integrals[0].Lia[ki, ka],\n                        self.integrals[1].Lia[ki, ka],\n                    ],\n                    axis=1,\n                )\n\n                tmp += np.dot(moments[q, ka, i - 1], Lia.T.conj())\n\n            tmp = mpi_helper.allreduce(tmp)\n            tmp /= self.nkpts\n\n            for kj in kpts.loop(1, mpi=True):\n                kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[kj]))\n\n                Lai = np.concatenate(\n                    [\n                        self.integrals[0].Lai[kj, kb],\n                        self.integrals[1].Lai[kj, kb],\n                    ],\n                    axis=1,\n                )\n\n                moments[q, kb, i] += np.dot(tmp, Lai.conj())\n\n    return moments\n</code></pre>"},{"location":"reference/pbc/uhf/tda/#momentGW.pbc.uhf.tda.dTDA.kernel","title":"<code>momentGW.pbc.uhf.tda.dTDA.kernel(exact=False)</code>","text":"<p>Run the polarizability calculation to compute moments of the self-energy.</p> <p>Parameters:</p> Name Type Description Default <code>exact</code> <code>bool</code> <p>Has no effect and is only present for compatibility with <code>dRPA</code>. Default value is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>moments_occ</code> <code>ndarray</code> <p>Moments of the occupied self-energy at each k-point for each spin channel.</p> <code>moments_vir</code> <code>ndarray</code> <p>Moments of the virtual self-energy at each k-point for each spin channel.</p> Source code in <code>momentGW/pbc/uhf/tda.py</code> <pre><code>def kernel(self, exact=False):\n    \"\"\"\n    Run the polarizability calculation to compute moments of the\n    self-energy.\n\n    Parameters\n    ----------\n    exact : bool, optional\n        Has no effect and is only present for compatibility with\n        `dRPA`. Default value is `False`.\n\n    Returns\n    -------\n    moments_occ : numpy.ndarray\n        Moments of the occupied self-energy at each k-point for each\n        spin channel.\n    moments_vir : numpy.ndarray\n        Moments of the virtual self-energy at each k-point for each\n        spin channel.\n    \"\"\"\n    return super().kernel(exact=exact)\n</code></pre>"},{"location":"reference/pbc/uhf/tda/#momentGW.pbc.uhf.tda.dTDA.convolve","title":"<code>momentGW.pbc.uhf.tda.dTDA.convolve(eta, mo_energy_g=None, mo_occ_g=None)</code>","text":"<p>Handle the convolution of the moments of the Green's function and screened Coulomb interaction.</p> <p>Parameters:</p> Name Type Description Default <code>eta</code> <code>ndarray</code> <p>Moments of the density-density response partly transformed into moments of the screened Coulomb interaction, at each k-point for each spin channel.</p> required <code>mo_energy_g</code> <code>ndarray</code> <p>Energies of the Green's function at each k-point for each spin channel. If <code>None</code>, use <code>self.mo_energy_g</code>. Default value is <code>None</code>.</p> <code>None</code> <code>mo_occ_g</code> <code>ndarray</code> <p>Occupancies of the Green's function at each k-point for each spin channel. If <code>None</code>, use <code>self.mo_occ_g</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>moments_occ</code> <code>ndarray</code> <p>Moments of the occupied self-energy at each k-point for each spin channel.</p> <code>moments_vir</code> <code>ndarray</code> <p>Moments of the virtual self-energy at each k-point for each spin channel.</p> Source code in <code>momentGW/pbc/uhf/tda.py</code> <pre><code>@logging.with_timer(\"Moment convolution\")\n@logging.with_status(\"Convoluting moments\")\ndef convolve(self, eta, mo_energy_g=None, mo_occ_g=None):\n    \"\"\"\n    Handle the convolution of the moments of the Green's function\n    and screened Coulomb interaction.\n\n    Parameters\n    ----------\n    eta : numpy.ndarray\n        Moments of the density-density response partly transformed\n        into moments of the screened Coulomb interaction, at each\n        k-point for each spin channel.\n    mo_energy_g : numpy.ndarray, optional\n        Energies of the Green's function at each k-point for each\n        spin channel. If `None`, use `self.mo_energy_g`. Default\n        value is `None`.\n    mo_occ_g : numpy.ndarray, optional\n        Occupancies of the Green's function at each k-point for each\n        spin channel. If `None`, use `self.mo_occ_g`. Default value\n        is `None`.\n\n    Returns\n    -------\n    moments_occ : numpy.ndarray\n        Moments of the occupied self-energy at each k-point for each\n        spin channel.\n    moments_vir : numpy.ndarray\n        Moments of the virtual self-energy at each k-point for each\n        spin channel.\n    \"\"\"\n    return super().convolve(\n        eta,\n        mo_energy_g=mo_energy_g,\n        mo_occ_g=mo_occ_g,\n    )\n</code></pre>"},{"location":"reference/pbc/uhf/tda/#momentGW.pbc.uhf.tda.dTDA.build_se_moments","title":"<code>momentGW.pbc.uhf.tda.dTDA.build_se_moments(moments_dd)</code>","text":"<p>Build the moments of the self-energy via convolution.</p> <p>Parameters:</p> Name Type Description Default <code>moments_dd</code> <code>ndarray</code> <p>Moments of the density-density response at each k-point.</p> required <p>Returns:</p> Name Type Description <code>moments_occ</code> <code>ndarray</code> <p>Moments of the occupied self-energy at each k-point for each spin channel.</p> <code>moments_vir</code> <code>ndarray</code> <p>Moments of the virtual self-energy at each k-point for each spin channel.</p> Source code in <code>momentGW/pbc/uhf/tda.py</code> <pre><code>@logging.with_timer(\"Self-energy moments\")\n@logging.with_status(\"Constructing self-energy moments\")\ndef build_se_moments(self, moments_dd):\n    \"\"\"Build the moments of the self-energy via convolution.\n\n    Parameters\n    ----------\n    moments_dd : numpy.ndarray\n        Moments of the density-density response at each k-point.\n\n    Returns\n    -------\n    moments_occ : numpy.ndarray\n        Moments of the occupied self-energy at each k-point for each\n        spin channel.\n    moments_vir : numpy.ndarray\n        Moments of the virtual self-energy at each k-point for each\n        spin channel.\n    \"\"\"\n\n    kpts = self.kpts\n\n    # Setup dependent on diagonal SE\n    if self.gw.diagonal_se:\n        pqchar = pchar = qchar = \"p\"\n        eta_shape = lambda s, k: (self.mo_energy_g[s][k].size, self.nmom_max + 1, self.nmo[s])\n    else:\n        pqchar, pchar, qchar = \"pq\", \"p\", \"q\"\n        eta_shape = lambda s, k: (\n            self.mo_energy_g[s][k].size,\n            self.nmom_max + 1,\n            self.nmo[s],\n            self.nmo[s],\n        )\n    eta = np.zeros((2, self.nkpts, self.nkpts), dtype=object)\n\n    # Get the moments in (aux|aux) and rotate to (mo|mo)\n    for n in range(self.nmom_max + 1):\n        for q in kpts.loop(1):\n            eta_aux = 0\n            for kj in kpts.loop(1, mpi=True):\n                kb = kpts.member(kpts.wrap_around(kpts[q] + kpts[kj]))\n                Lia = np.concatenate(\n                    [\n                        self.integrals[0].Lia[kj, kb],\n                        self.integrals[1].Lia[kj, kb],\n                    ],\n                    axis=1,\n                )\n                eta_aux += np.dot(moments_dd[q, kb, n], Lia.T.conj())\n\n            eta_aux = mpi_helper.allreduce(eta_aux)\n            eta_aux /= self.nkpts\n\n            for kp in kpts.loop(1, mpi=True):\n                kx = kpts.member(kpts.wrap_around(kpts[kp] - kpts[q]))\n\n                for s in range(2):\n                    if not isinstance(eta[s, kp, q], np.ndarray):\n                        eta[s, kp, q] = np.zeros(eta_shape(s, kx), dtype=eta_aux.dtype)\n\n                    for x in range(self.mo_energy_g[s][kx].size):\n                        Lp = self.integrals[s].Lpx[kp, kx][:, :, x]\n                        subscript = f\"P{pchar},Q{qchar},PQ-&gt;{pqchar}\"\n                        eta[s, kp, q][x, n] += util.einsum(subscript, Lp, Lp.conj(), eta_aux)\n\n    # Construct the self-energy moments\n    moments_occ = [None, None]\n    moments_vir = [None, None]\n    moments_occ[0], moments_vir[0] = self.convolve(\n        eta[0], mo_energy_g=self.mo_energy_g[0], mo_occ_g=self.mo_occ_g[0]\n    )\n    moments_occ[1], moments_vir[1] = self.convolve(\n        eta[1], mo_energy_g=self.mo_energy_g[1], mo_occ_g=self.mo_occ_g[1]\n    )\n\n    return tuple(moments_occ), tuple(moments_vir)\n</code></pre>"},{"location":"reference/uhf/","title":"Index","text":"<p>Methods for unrestricted references.</p>"},{"location":"reference/uhf/base/","title":"Base","text":"<p>Base class for moment-constained GW solvers with unrestricted references.</p>"},{"location":"reference/uhf/base/#momentGW.uhf.base.BaseUGW","title":"<code>momentGW.uhf.base.BaseUGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>BaseGW</code></p> <p>Base class for moment-constrained GW solvers with unrestricted references.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>SCF</code> <p>PySCF mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required Source code in <code>momentGW/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Attributes\n    self.converged = None\n    self.se = None\n    self.gf = None\n    self._qp_energy = None\n</code></pre>"},{"location":"reference/uhf/evgw/","title":"Evgw","text":"<p>Spin-unrestricted eigenvalue self-consistent GW via self-energy moment constraints for molecular systems.</p>"},{"location":"reference/uhf/evgw/#momentGW.uhf.evgw.evUGW","title":"<code>momentGW.uhf.evgw.evUGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>UGW</code>, <code>evGW</code></p> <p>Spin-unrestricted eigenvalue self-consistent GW via self-energy moment constraints for molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>SCF</code> <p>PySCF mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>g0</code> <code>bool</code> <p>If <code>True</code>, do not self-consistently update the eigenvalues in the Green's function. Default value is <code>False</code>.</p> required <code>w0</code> <code>bool</code> <p>If <code>True</code>, do not self-consistently update the eigenvalues in the screened Coulomb interaction. Default value is <code>False</code>.</p> required <code>max_cycle</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>50</code>.</p> required <code>conv_tol</code> <code>float</code> <p>Convergence threshold in the change in the HOMO and LUMO. Default value is <code>1e-8</code>.</p> required <code>conv_tol_moms</code> <code>float</code> <p>Convergence threshold in the change in the moments. Default value is <code>1e-8</code>.</p> required <code>conv_logical</code> <code>callable</code> <p>Function that takes an iterable of booleans as input indicating whether the individual <code>conv_tol</code> and <code>conv_tol_moms</code> have been satisfied, respectively, and returns a boolean indicating overall convergence. For example, the function <code>all</code> requires both metrics to be met, and <code>any</code> requires just one. Default value is <code>all</code>.</p> required <code>diis_space</code> <code>int</code> <p>Size of the DIIS extrapolation space. Default value is <code>8</code>.</p> required <code>damping</code> <code>float</code> <p>Damping parameter. Default value is <code>0.0</code>.</p> required <code>weight_tol</code> <code>float</code> <p>Threshold in physical weight of Green's function poles, below which they are considered zero. Default value is <code>1e-11</code>.</p> required Source code in <code>momentGW/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Attributes\n    self.converged = None\n    self.se = None\n    self.gf = None\n    self._qp_energy = None\n</code></pre>"},{"location":"reference/uhf/evgw/#momentGW.uhf.evgw.evUGW.name","title":"<code>momentGW.uhf.evgw.evUGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/uhf/evgw/#momentGW.uhf.evgw.evUGW.check_convergence","title":"<code>momentGW.uhf.evgw.evUGW.check_convergence(mo_energy, mo_energy_prev, th, th_prev, tp, tp_prev)</code>","text":"<p>Check for convergence, and print a summary of changes.</p> <p>Parameters:</p> Name Type Description Default <code>mo_energy</code> <code>ndarray</code> <p>Molecular orbital energies for each spin channel.</p> required <code>mo_energy_prev</code> <code>ndarray</code> <p>Molecular orbital energies from the previous iteration for each spin channel.</p> required <code>th</code> <code>ndarray</code> <p>Moments of the occupied self-energy for each spin channel.</p> required <code>th_prev</code> <code>ndarray</code> <p>Moments of the occupied self-energy from the previous iteration for each spin channel.</p> required <code>tp</code> <code>ndarray</code> <p>Moments of the virtual self-energy for each spin channel.</p> required <code>tp_prev</code> <code>ndarray</code> <p>Moments of the virtual self-energy from the previous iteration for each spin channel.</p> required <p>Returns:</p> Name Type Description <code>conv</code> <code>bool</code> <p>Convergence flag.</p> Source code in <code>momentGW/uhf/evgw.py</code> <pre><code>def check_convergence(self, mo_energy, mo_energy_prev, th, th_prev, tp, tp_prev):\n    \"\"\"Check for convergence, and print a summary of changes.\n\n    Parameters\n    ----------\n    mo_energy : numpy.ndarray\n        Molecular orbital energies for each spin channel.\n    mo_energy_prev : numpy.ndarray\n        Molecular orbital energies from the previous iteration for\n        each spin channel.\n    th : numpy.ndarray\n        Moments of the occupied self-energy for each spin channel.\n    th_prev : numpy.ndarray\n        Moments of the occupied self-energy from the previous\n        iteration for each spin channel.\n    tp : numpy.ndarray\n        Moments of the virtual self-energy for each spin channel.\n    tp_prev : numpy.ndarray\n        Moments of the virtual self-energy from the previous\n        iteration for each spin channel.\n\n    Returns\n    -------\n    conv : bool\n        Convergence flag.\n    \"\"\"\n\n    # Get the previous moments\n    if th_prev is None:\n        th_prev = np.zeros_like(th)\n    if tp_prev is None:\n        tp_prev = np.zeros_like(tp)\n\n    # Get the HOMO and LUMO errors\n    error_homo = (\n        abs(mo_energy[0][self.nocc[0] - 1] - mo_energy_prev[0][self.nocc[0] - 1]),\n        abs(mo_energy[1][self.nocc[1] - 1] - mo_energy_prev[1][self.nocc[1] - 1]),\n    )\n    error_lumo = (\n        abs(mo_energy[0][self.nocc[0]] - mo_energy_prev[0][self.nocc[0]]),\n        abs(mo_energy[1][self.nocc[1]] - mo_energy_prev[1][self.nocc[1]]),\n    )\n\n    # Get the moment errors\n    error_th = (self._moment_error(th[0], th_prev[0]), self._moment_error(th[1], th_prev[1]))\n    error_tp = (self._moment_error(tp[0], tp_prev[0]), self._moment_error(tp[1], tp_prev[1]))\n\n    # Print the table\n    style_homo = tuple(logging.rate(e, self.conv_tol, self.conv_tol * 1e2) for e in error_homo)\n    style_lumo = tuple(logging.rate(e, self.conv_tol, self.conv_tol * 1e2) for e in error_lumo)\n    style_th = tuple(\n        logging.rate(e, self.conv_tol_moms, self.conv_tol_moms * 1e2) for e in error_th\n    )\n    style_tp = tuple(\n        logging.rate(e, self.conv_tol_moms, self.conv_tol_moms * 1e2) for e in error_tp\n    )\n    table = logging.Table(title=\"Convergence\")\n    table.add_column(\"Sector\", justify=\"right\")\n    table.add_column(\"\u0394 energy\", justify=\"right\")\n    table.add_column(\"\u0394 moments\", justify=\"right\")\n    for s, spin in enumerate([\"\u03b1\", \"\u03b2\"]):\n        table.add_row(\n            f\"Hole ({spin})\",\n            f\"[{style_homo[s]}]{error_homo[s]:.3g}[/]\",\n            f\"[{style_th[s]}]{error_th[s]:.3g}[/]\",\n        )\n    for s, spin in enumerate([\"\u03b1\", \"\u03b2\"]):\n        table.add_row(\n            f\"Particle ({spin})\",\n            f\"[{style_lumo[s]}]{error_lumo[s]:.3g}[/]\",\n            f\"[{style_tp[s]}]{error_tp[s]:.3g}[/]\",\n        )\n    logging.write(\"\")\n    logging.write(table)\n\n    return self.conv_logical(\n        (\n            max(max(error_homo), max(error_lumo)) &lt; self.conv_tol,\n            max(max(error_th), max(error_tp)) &lt; self.conv_tol_moms,\n        )\n    )\n</code></pre>"},{"location":"reference/uhf/evgw/#momentGW.uhf.evgw.evUGW.remove_unphysical_poles","title":"<code>momentGW.uhf.evgw.evUGW.remove_unphysical_poles(gf)</code>","text":"<p>Remove unphysical poles from the Green's function to stabilise iterations, according to the threshold <code>self.weight_tol</code>.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function for each spin channel.</p> required <p>Returns:</p> Name Type Description <code>gf_out</code> <code>tuple of dyson.Lehmann</code> <p>Green's function for each spin channel, with potentially fewer poles.</p> Source code in <code>momentGW/uhf/evgw.py</code> <pre><code>def remove_unphysical_poles(self, gf):\n    \"\"\"\n    Remove unphysical poles from the Green's function to stabilise\n    iterations, according to the threshold `self.weight_tol`.\n\n    Parameters\n    ----------\n    gf : tuple of dyson.Lehmann\n        Green's function for each spin channel.\n\n    Returns\n    -------\n    gf_out : tuple of dyson.Lehmann\n        Green's function for each spin channel, with potentially\n        fewer poles.\n    \"\"\"\n    gf_\u03b1 = gf[0].physical(weight=self.weight_tol)\n    gf_\u03b2 = gf[1].physical(weight=self.weight_tol)\n    return (gf_\u03b1, gf_\u03b2)\n</code></pre>"},{"location":"reference/uhf/fock/","title":"Fock","text":"<p>Fock matrix self-consistent loop for unrestricted references.</p>"},{"location":"reference/uhf/fock/#momentGW.uhf.fock.FockLoop","title":"<code>momentGW.uhf.fock.FockLoop</code>","text":"<p>             Bases: <code>FockLoop</code></p> <p>Self-consistent loop for the density matrix via the Hartree--Fock self-consistent field for spin-unrestricted molecular systems.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseUGW</code> <p>GW object.</p> required <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Initial Green's function object for each spin channel. If <code>None</code>, use <code>gw.init_gf()</code>. Default value is <code>None</code>.</p> required <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Initial self-energy object for each spin channel. If passed, use as dynamic part of the self-energy. If <code>None</code>, self-energy is assumed to be static and fully defined by the Fock matrix. Default value is <code>None</code>.</p> required <code>fock_diis_space</code> <code>int</code> <p>DIIS space size for the Fock matrix. Default value is <code>10</code>.</p> required <code>fock_diis_min_space</code> <code>int</code> <p>Minimum DIIS space size for the Fock matrix. Default value is <code>1</code>.</p> required <code>conv_tol_nelec</code> <code>float</code> <p>Convergence tolerance for the number of electrons. Default value is <code>1e-6</code>.</p> required <code>conv_tol_rdm1</code> <code>float</code> <p>Convergence tolerance for the density matrix. Default value is <code>1e-8</code>.</p> required <code>max_cycle_inner</code> <code>int</code> <p>Maximum number of inner iterations. Default value is <code>100</code>.</p> required <code>max_cycle_outer</code> <code>int</code> <p>Maximum number of outer iterations. Default value is <code>20</code>.</p> required"},{"location":"reference/uhf/fock/#momentGW.uhf.fock.FockLoop.naux","title":"<code>momentGW.uhf.fock.FockLoop.naux</code>  <code>property</code>","text":"<p>Get the number of auxiliary states.</p>"},{"location":"reference/uhf/fock/#momentGW.uhf.fock.FockLoop.nqmo","title":"<code>momentGW.uhf.fock.FockLoop.nqmo</code>  <code>property</code>","text":"<p>Get the number of quasiparticle MOs.</p>"},{"location":"reference/uhf/fock/#momentGW.uhf.fock.FockLoop.nelec","title":"<code>momentGW.uhf.fock.FockLoop.nelec</code>  <code>property</code>","text":"<p>Get the number of electrons.</p>"},{"location":"reference/uhf/fock/#momentGW.uhf.fock.FockLoop.auxiliary_shift","title":"<code>momentGW.uhf.fock.FockLoop.auxiliary_shift(fock, se=None)</code>","text":"<p>Optimise a shift in the auxiliary energies to best satisfy the electron number.</p> <p>Parameters:</p> Name Type Description Default <code>fock</code> <code>ndarray</code> <p>Fock matrix for each spin channel.</p> required <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy for each spin channel. If <code>None</code>, use <code>self.se</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy for each spin channel.</p> Notes <p>If there is no dynamic part of the self-energy (<code>self.se</code> is <code>None</code>), this method returns <code>None</code>.</p> Source code in <code>momentGW/uhf/fock.py</code> <pre><code>def auxiliary_shift(self, fock, se=None):\n    \"\"\"\n    Optimise a shift in the auxiliary energies to best satisfy the\n    electron number.\n\n    Parameters\n    ----------\n    fock : numpy.ndarray\n        Fock matrix for each spin channel.\n    se : tuple of dyson.Lehmann, optional\n        Self-energy for each spin channel. If `None`, use `self.se`.\n        Default value is `None`.\n\n    Returns\n    -------\n    se : tuple of dyson.Lehmann\n        Self-energy for each spin channel.\n\n    Notes\n    -----\n    If there is no dynamic part of the self-energy (`self.se` is\n    `None`), this method returns `None`.\n    \"\"\"\n\n    # Get the self-energy\n    if se is None:\n        se = self.se\n    if se is None:\n        return None\n\n    # Optimise the shift in the auxiliary energies\n    se_\u03b1, opt_\u03b1 = minimize_chempot(\n        se[0],\n        fock[0],\n        self.nelec[0],\n        x0=se[0].chempot,\n        tol=self.conv_tol_nelec,\n        maxiter=self.max_cycle_inner,\n        occupancy=1,\n    )\n    se_\u03b2, opt_\u03b2 = minimize_chempot(\n        se[1],\n        fock[1],\n        self.nelec[1],\n        x0=se[1].chempot,\n        tol=self.conv_tol_nelec,\n        maxiter=self.max_cycle_inner,\n        occupancy=1,\n    )\n    se = (se_\u03b1, se_\u03b2)\n\n    return se\n</code></pre>"},{"location":"reference/uhf/fock/#momentGW.uhf.fock.FockLoop.search_chempot","title":"<code>momentGW.uhf.fock.FockLoop.search_chempot(gf=None)</code>","text":"<p>Search for a chemical potential for a given Green's function.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function for each spin channel. If <code>None</code>, use <code>self.gf</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>chempot</code> <code>tuple of float</code> <p>Chemical potential for each spin channel.</p> <code>nerr</code> <code>tuple of float</code> <p>Error in the number of electrons for each spin channel.</p> Source code in <code>momentGW/uhf/fock.py</code> <pre><code>def search_chempot(self, gf=None):\n    \"\"\"Search for a chemical potential for a given Green's function.\n\n    Parameters\n    ----------\n    gf : tuple of dyson.Lehmann, optional\n        Green's function for each spin channel. If `None`, use\n        `self.gf`. Default value is `None`.\n\n    Returns\n    -------\n    chempot : tuple of float\n        Chemical potential for each spin channel.\n    nerr : tuple of float\n        Error in the number of electrons for each spin channel.\n    \"\"\"\n\n    # Get the Green's function\n    if gf is None:\n        gf = self.gf\n\n    # Search for the chemical potential\n    chempot_\u03b1, nerr_\u03b1 = search_chempot(\n        gf[0].energies,\n        gf[0].couplings,\n        self.nmo[0],\n        self.nelec[0],\n        occupancy=1,\n    )\n    chempot_\u03b2, nerr_\u03b2 = search_chempot(\n        gf[1].energies,\n        gf[1].couplings,\n        self.nmo[1],\n        self.nelec[1],\n        occupancy=1,\n    )\n    chempot = (chempot_\u03b1, chempot_\u03b2)\n    nerr = abs(nerr_\u03b1) + abs(nerr_\u03b2)\n\n    return chempot, nerr\n</code></pre>"},{"location":"reference/uhf/fock/#momentGW.uhf.fock.FockLoop.solve_dyson","title":"<code>momentGW.uhf.fock.FockLoop.solve_dyson(fock, se=None)</code>","text":"<p>Solve the Dyson equation for a given Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>fock</code> <code>ndarray</code> <p>Fock matrix for each spin channel.</p> required <code>se</code> <code>Lehmann</code> <p>Self-energy for each spin channel. If <code>None</code>, use <code>self.se</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function for each spin channel.</p> <code>nerr</code> <code>float</code> <p>Error in the number of electrons.</p> Notes <p>If there is no dynamic part of the self-energy (<code>self.se</code> is <code>None</code>), this method simply diagonalises the Fock matrix and returns the Lehmann representation of the resulting zeroth-order Green's function.</p> Source code in <code>momentGW/uhf/fock.py</code> <pre><code>def solve_dyson(self, fock, se=None):\n    \"\"\"Solve the Dyson equation for a given Fock matrix.\n\n    Parameters\n    ----------\n    fock : numpy.ndarray\n        Fock matrix for each spin channel.\n    se : dyson.Lehmann, optional\n        Self-energy for each spin channel. If `None`, use `self.se`.\n        Default value is `None`.\n\n    Returns\n    -------\n    gf : tuple of dyson.Lehmann\n        Green's function for each spin channel.\n    nerr : float\n        Error in the number of electrons.\n\n    Notes\n    -----\n    If there is no dynamic part of the self-energy (`self.se` is\n    `None`), this method simply diagonalises the Fock matrix and\n    returns the Lehmann representation of the resulting zeroth-order\n    Green's function.\n    \"\"\"\n\n    # Get the self-energy\n    if se is None:\n        se = self.se\n\n    # Diagonalise the (extended) Fock matrix\n    if se is None:\n        e, c = np.linalg.eigh(fock)\n    else:\n        e_\u03b1, c_\u03b1 = se[0].diagonalise_matrix(fock[0], chempot=0.0)\n        e_\u03b2, c_\u03b2 = se[1].diagonalise_matrix(fock[1], chempot=0.0)\n        e = (e_\u03b1, e_\u03b2)\n        c = (c_\u03b1, c_\u03b2)\n\n    # Broadcast the eigenvalues and eigenvectors in case of\n    # hybrid parallelisation introducing non-determinism\n    e = (mpi_helper.bcast(e[0], root=0), mpi_helper.bcast(e[1], root=0))\n    c = (mpi_helper.bcast(c[0], root=0), mpi_helper.bcast(c[1], root=0))\n\n    # Construct the Green's function\n    gf = [\n        Lehmann(e[0], c[0][: self.nmo[0]], chempot=se[0].chempot if se is not None else 0.0),\n        Lehmann(e[1], c[1][: self.nmo[1]], chempot=se[1].chempot if se is not None else 0.0),\n    ]\n\n    # Search for the chemical potential\n    chempot, nerr = self.search_chempot(gf)\n    gf[0].chempot = chempot[0]\n    gf[1].chempot = chempot[1]\n\n    return tuple(gf), nerr\n</code></pre>"},{"location":"reference/uhf/fock/#momentGW.uhf.fock.FockLoop.kernel","title":"<code>momentGW.uhf.fock.FockLoop.kernel(integrals=None)</code>","text":"<p>Driver for the Fock loop.</p> <p>Parameters:</p> Name Type Description Default <code>integrals</code> <code>UIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>converged</code> <code>bool</code> <p>Whether the loop has converged.</p> <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function object for each spin channel.</p> <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy object for each spin channel.</p> Source code in <code>momentGW/uhf/fock.py</code> <pre><code>@logging.with_timer(\"Fock loop\")\n@logging.with_status(\"Running Fock loop\")\ndef kernel(self, integrals=None):\n    \"\"\"Driver for the Fock loop.\n\n    Parameters\n    ----------\n    integrals : UIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    converged : bool\n        Whether the loop has converged.\n    gf : tuple of dyson.Lehmann\n        Green's function object for each spin channel.\n    se : tuple of dyson.Lehmann\n        Self-energy object for each spin channel.\n    \"\"\"\n    return super().kernel(integrals)\n</code></pre>"},{"location":"reference/uhf/fsgw/","title":"Fsgw","text":"<p>Spin-unrestricted Fock matrix self-consistent GW via self-energy moment constraints for molecular systems.</p>"},{"location":"reference/uhf/fsgw/#momentGW.uhf.fsgw.fsUGW","title":"<code>momentGW.uhf.fsgw.fsUGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>UGW</code>, <code>fsGW</code></p> <p>Spin-unrestricted Fock matrix self-consistent GW via self-energy moment constraints for molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>SCF</code> <p>PySCF mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>max_cycle</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>50</code>.</p> required <code>conv_tol</code> <code>float</code> <p>Convergence threshold in the change in the HOMO and LUMO. Default value is <code>1e-8</code>.</p> required <code>conv_tol_moms</code> <code>float</code> <p>Convergence threshold in the change in the moments. Default value is <code>1e-8</code>.</p> required <code>conv_logical</code> <code>callable</code> <p>Function that takes an iterable of booleans as input indicating whether the individual <code>conv_tol</code>, <code>conv_tol_moms</code> have been satisfied, respectively, and returns a boolean indicating overall convergence. For example, the function <code>all</code> requires both metrics to be met, and <code>any</code> requires just one. Default value is <code>all</code>.</p> required <code>diis_space</code> <code>int</code> <p>Size of the DIIS extrapolation space. Default value is <code>8</code>.</p> required <code>damping</code> <code>float</code> <p>Damping parameter. Default value is <code>0.0</code>.</p> required <code>solver</code> <code>BaseGW</code> <p>Solver to use to obtain the self-energy. Compatible with any <code>BaseGW</code>-like class. Default value is <code>momentGW.gw.GW</code>.</p> required <code>solver_options</code> <code>dict</code> <p>Keyword arguments to pass to the solver. Default value is an empty <code>dict</code>.</p> required Source code in <code>momentGW/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Attributes\n    self.converged = None\n    self.se = None\n    self.gf = None\n    self._qp_energy = None\n</code></pre>"},{"location":"reference/uhf/fsgw/#momentGW.uhf.fsgw.fsUGW.name","title":"<code>momentGW.uhf.fsgw.fsUGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/uhf/gw/","title":"Gw","text":"<p>Spin-unrestricted one-shot GW via self-energy moment constraints for molecular systems.</p>"},{"location":"reference/uhf/gw/#momentGW.uhf.gw.UGW","title":"<code>momentGW.uhf.gw.UGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>BaseUGW</code>, <code>GW</code></p> <p>Spin-unrestricted one-shot GW via self-energy moment constraints for molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>SCF</code> <p>PySCF mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required Notes <p>This approach is described in [1]_.</p> References <p>.. [1] C. J. C. Scott, O. J. Backhouse, and G. H. Booth, 158, 12,     2023.</p> Source code in <code>momentGW/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Attributes\n    self.converged = None\n    self.se = None\n    self.gf = None\n    self._qp_energy = None\n</code></pre>"},{"location":"reference/uhf/gw/#momentGW.uhf.gw.UGW.name","title":"<code>momentGW.uhf.gw.UGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/uhf/gw/#momentGW.uhf.gw.UGW.build_se_static","title":"<code>momentGW.uhf.gw.UGW.build_se_static(integrals)</code>","text":"<p>Build the static part of the self-energy, including the Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>integrals</code> <code>UIntegrals</code> <p>Integrals object.</p> required <p>Returns:</p> Name Type Description <code>se_static</code> <code>ndarray</code> <p>Static part of the self-energy for each spin channel. If <code>self.diagonal_se</code>, non-diagonal elements are set to zero.</p> Source code in <code>momentGW/uhf/gw.py</code> <pre><code>@logging.with_timer(\"Static self-energy\")\n@logging.with_status(\"Building static self-energy\")\ndef build_se_static(self, integrals):\n    \"\"\"\n    Build the static part of the self-energy, including the Fock\n    matrix.\n\n    Parameters\n    ----------\n    integrals : UIntegrals\n        Integrals object.\n\n    Returns\n    -------\n    se_static : numpy.ndarray\n        Static part of the self-energy for each spin channel. If\n        `self.diagonal_se`, non-diagonal elements are set to zero.\n    \"\"\"\n    return super().build_se_static(integrals)\n</code></pre>"},{"location":"reference/uhf/gw/#momentGW.uhf.gw.UGW.build_se_moments","title":"<code>momentGW.uhf.gw.UGW.build_se_moments(nmom_max, integrals, **kwargs)</code>","text":"<p>Build the moments of the self-energy.</p> <p>Parameters:</p> Name Type Description Default <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>integrals</code> <code>UIntegrals</code> <p>Integrals object.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments passed to polarizability class.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>se_moments_hole</code> <code>tuple of numpy.ndarray</code> <p>Moments of the hole self-energy for each spin channel. If <code>self.diagonal_se</code>, non-diagonal elements are set to zero.</p> <code>se_moments_part</code> <code>tuple of numpy.ndarray</code> <p>Moments of the particle self-energy for each spin channel. If <code>self.diagonal_se</code>, non-diagonal elements are set to zero.</p> See Also <p>momentGW.uhf.rpa.dRPA momentGW.uhf.tda.dTDA</p> Source code in <code>momentGW/uhf/gw.py</code> <pre><code>def build_se_moments(self, nmom_max, integrals, **kwargs):\n    \"\"\"Build the moments of the self-energy.\n\n    Parameters\n    ----------\n    nmom_max : int\n        Maximum moment number to calculate.\n    integrals : UIntegrals\n        Integrals object.\n    **kwargs : dict, optional\n       Additional keyword arguments passed to polarizability class.\n\n    Returns\n    -------\n    se_moments_hole : tuple of numpy.ndarray\n        Moments of the hole self-energy for each spin channel. If\n        `self.diagonal_se`, non-diagonal elements are set to zero.\n    se_moments_part : tuple of numpy.ndarray\n        Moments of the particle self-energy for each spin channel.\n        If `self.diagonal_se`, non-diagonal elements are set to\n        zero.\n\n    See Also\n    --------\n    momentGW.uhf.rpa.dRPA\n    momentGW.uhf.tda.dTDA\n    \"\"\"\n\n    if self.polarizability.lower() == \"dtda\":\n        tda = dTDA(self, nmom_max, integrals, **kwargs)\n        return tda.kernel()\n\n    elif self.polarizability.lower() == \"drpa\":\n        rpa = dRPA(self, nmom_max, integrals, **kwargs)\n        return rpa.kernel()\n\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/uhf/gw/#momentGW.uhf.gw.UGW.ao2mo","title":"<code>momentGW.uhf.gw.UGW.ao2mo(transform=True)</code>","text":"<p>Get the integrals object.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <code>bool</code> <p>Whether to transform the integrals object.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>integrals</code> <code>UIntegrals</code> <p>Integrals object.</p> See Also <p>momentGW.uhf.ints.UIntegrals</p> Source code in <code>momentGW/uhf/gw.py</code> <pre><code>@logging.with_timer(\"Integral construction\")\n@logging.with_status(\"Constructing integrals\")\ndef ao2mo(self, transform=True):\n    \"\"\"Get the integrals object.\n\n    Parameters\n    ----------\n    transform : bool, optional\n        Whether to transform the integrals object.\n\n    Returns\n    -------\n    integrals : UIntegrals\n        Integrals object.\n\n    See Also\n    --------\n    momentGW.uhf.ints.UIntegrals\n    \"\"\"\n\n    # Get the integrals\n    integrals = UIntegrals(\n        self.with_df,\n        self.mo_coeff,\n        self.mo_occ,\n        compression=self.compression,\n        compression_tol=self.compression_tol,\n        store_full=self.fock_loop,\n    )\n\n    # Transform the integrals\n    if transform:\n        integrals.transform()\n\n    return integrals\n</code></pre>"},{"location":"reference/uhf/gw/#momentGW.uhf.gw.UGW.solve_dyson","title":"<code>momentGW.uhf.gw.UGW.solve_dyson(se_moments_hole, se_moments_part, se_static, integrals=None)</code>","text":"<p>Solve the Dyson equation due to a self-energy resulting from a list of hole and particle moments, along with a static contribution for each spin channel.</p> <p>Also finds a chemical potential best satisfying the physical number of electrons. If <code>self.optimise_chempot</code>, this will shift the self-energy poles relative to the Green's function, which is a partial self-consistency that better conserves the particle number.</p> <p>If <code>self.fock_loop</code>, this function will also require that the outputted Green's function is self-consistent with respect to the corresponding density and Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>se_moments_hole</code> <code>tuple of numpy.ndarray</code> <p>Moments of the hole self-energy for each spin channel.</p> required <code>se_moments_part</code> <code>tuple of numpy.ndarray</code> <p>Moments of the particle self-energy for each spin channel.</p> required <code>se_static</code> <code>tuple of numpy.ndarray</code> <p>Static part of the self-energy for each spin channel.</p> required <code>integrals</code> <code>UIntegrals</code> <p>Integrals object. Required if <code>self.fock_loop</code> is <code>True</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function for each spin channel.</p> <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy for each spin channel.</p> See Also <p>momentGW.uhf.fock.FockLoop</p> Source code in <code>momentGW/uhf/gw.py</code> <pre><code>def solve_dyson(self, se_moments_hole, se_moments_part, se_static, integrals=None):\n    \"\"\"\n    Solve the Dyson equation due to a self-energy resulting from a\n    list of hole and particle moments, along with a static\n    contribution for each spin channel.\n\n    Also finds a chemical potential best satisfying the physical\n    number of electrons. If `self.optimise_chempot`, this will\n    shift the self-energy poles relative to the Green's function,\n    which is a partial self-consistency that better conserves the\n    particle number.\n\n    If `self.fock_loop`, this function will also require that the\n    outputted Green's function is self-consistent with respect to\n    the corresponding density and Fock matrix.\n\n    Parameters\n    ----------\n    se_moments_hole : tuple of numpy.ndarray\n        Moments of the hole self-energy for each spin channel.\n    se_moments_part : tuple of numpy.ndarray\n        Moments of the particle self-energy for each spin channel.\n    se_static : tuple of numpy.ndarray\n        Static part of the self-energy for each spin channel.\n    integrals : UIntegrals\n        Integrals object. Required if `self.fock_loop` is `True`.\n        Default value is `None`.\n\n    Returns\n    -------\n    gf : tuple of dyson.Lehmann\n        Green's function for each spin channel.\n    se : tuple of dyson.Lehmann\n        Self-energy for each spin channel.\n\n    See Also\n    --------\n    momentGW.uhf.fock.FockLoop\n    \"\"\"\n\n    # Solve the Dyson equation for the moments\n    with logging.with_modifiers(status=\"Solving Dyson equation\", timer=\"Dyson equation\"):\n        solver_occ = MBLSE(se_static[0], np.array(se_moments_hole[0]))\n        solver_occ.kernel()\n\n        solver_vir = MBLSE(se_static[0], np.array(se_moments_part[0]))\n        solver_vir.kernel()\n\n        solver = MixedMBLSE(solver_occ, solver_vir)\n        se_\u03b1 = solver.get_self_energy()\n\n        solver_occ = MBLSE(se_static[1], np.array(se_moments_hole[1]))\n        solver_occ.kernel()\n\n        solver_vir = MBLSE(se_static[1], np.array(se_moments_part[1]))\n        solver_vir.kernel()\n\n        solver = MixedMBLSE(solver_occ, solver_vir)\n        se_\u03b2 = solver.get_self_energy()\n\n        se = (se_\u03b1, se_\u03b2)\n\n    # Initialise the solver\n    solver = FockLoop(self, se=se, **self.fock_opts)\n\n    # Shift the self-energy poles relative to the Green's function\n    # to better conserve the particle number\n    if self.optimise_chempot:\n        se = solver.auxiliary_shift(se_static)\n\n    # Find the error in the moments\n    error = (\n        self.moment_error(se_moments_hole[0], se_moments_part[0], se[0]),\n        self.moment_error(se_moments_hole[1], se_moments_part[1], se[1]),\n    )\n    for s, spin in enumerate([\"\u03b1\", \"\u03b2\"]):\n        logging.write(\n            f\"Error in moments ({spin}):  \"\n            f\"[{logging.rate(sum(error[s]), 1e-12, 1e-8)}]{sum(error[s]):.3e}[/] \"\n            f\"(hole = [{logging.rate(error[s][0], 1e-12, 1e-8)}]{error[s][0]:.3e}[/], \"\n            f\"particle = [{logging.rate(error[s][1], 1e-12, 1e-8)}]{error[s][1]:.3e}[/])\"\n        )\n\n    # Solve the Dyson equation for the self-energy\n    gf, error = solver.solve_dyson(se_static)\n    se[0].chempot = gf[0].chempot\n    se[1].chempot = gf[1].chempot\n\n    # Self-consistently renormalise the density matrix\n    if self.fock_loop:\n        logging.write(\"\")\n        solver.gf = gf\n        solver.se = se\n        conv, gf, se = solver.kernel(integrals=integrals)\n        _, error = solver.search_chempot(gf)\n\n    # Print the error in the number of electrons\n    logging.write(\"\")\n    color = logging.rate(\n        abs(error),\n        1e-6,\n        1e-6 if self.fock_loop or self.optimise_chempot else 1e-1,\n    )\n    logging.write(f\"Error in number of electrons:  [{color}]{error:.3e}[/]\")\n    for s, spin in enumerate([\"\u03b1\", \"\u03b2\"]):\n        logging.write(f\"Chemical potential ({spin}):  {gf[s].chempot:.6f}\")\n\n    return tuple(gf), tuple(se)\n</code></pre>"},{"location":"reference/uhf/gw/#momentGW.uhf.gw.UGW.kernel","title":"<code>momentGW.uhf.gw.UGW.kernel(nmom_max, moments=None, integrals=None)</code>","text":"<p>Driver for the method.</p> <p>Parameters:</p> Name Type Description Default <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>moments</code> <code>tuple of numpy.ndarray</code> <p>Tuple of (hole, particle) moments for each spin channel, if passed then they will be used instead of calculating them. Default value is <code>None</code>.</p> <code>None</code> <code>integrals</code> <code>UIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>converged</code> <code>bool</code> <p>Whether the solver converged. For single-shot calculations, this is always <code>True</code>.</p> <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function object for each spin channel.</p> <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy object for each spin channel.</p> <code>qp_energy</code> <code>NoneType</code> <p>Quasiparticle energies. For most GW methods, this is <code>None</code>.</p> Source code in <code>momentGW/uhf/gw.py</code> <pre><code>def kernel(\n    self,\n    nmom_max,\n    moments=None,\n    integrals=None,\n):\n    \"\"\"Driver for the method.\n\n    Parameters\n    ----------\n    nmom_max : int\n        Maximum moment number to calculate.\n    moments : tuple of numpy.ndarray, optional\n        Tuple of (hole, particle) moments for each spin channel, if\n        passed then they will be used instead of calculating them.\n        Default value is `None`.\n    integrals : UIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    converged : bool\n        Whether the solver converged. For single-shot calculations,\n        this is always `True`.\n    gf : tuple of dyson.Lehmann\n        Green's function object for each spin channel.\n    se : tuple of dyson.Lehmann\n        Self-energy object for each spin channel.\n    qp_energy : NoneType\n        Quasiparticle energies. For most GW methods, this is `None`.\n    \"\"\"\n    return super().kernel(nmom_max, moments=moments, integrals=integrals)\n</code></pre>"},{"location":"reference/uhf/gw/#momentGW.uhf.gw.UGW.make_rdm1","title":"<code>momentGW.uhf.gw.UGW.make_rdm1(gf=None)</code>","text":"<p>Get the first-order reduced density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function for each spin channel. If <code>None</code>, use either <code>self.gf</code>, or the mean-field Green's function. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>rdm1</code> <code>ndarray</code> <p>First-order reduced density matrix for each spin channel.</p> Source code in <code>momentGW/uhf/gw.py</code> <pre><code>def make_rdm1(self, gf=None):\n    \"\"\"Get the first-order reduced density matrix.\n\n    Parameters\n    ----------\n    gf : tuple of dyson.Lehmann, optional\n        Green's function for each spin channel. If `None`, use\n        either `self.gf`, or the mean-field Green's function.\n        Default value is `None`.\n\n    Returns\n    -------\n    rdm1 : numpy.ndarray\n        First-order reduced density matrix for each spin channel.\n    \"\"\"\n\n    if gf is None:\n        gf = self.gf\n    if gf is None:\n        gf = self.init_gf()\n\n    return (gf[0].occupied().moment(0), gf[1].occupied().moment(0))\n</code></pre>"},{"location":"reference/uhf/gw/#momentGW.uhf.gw.UGW.energy_hf","title":"<code>momentGW.uhf.gw.UGW.energy_hf(gf=None, integrals=None)</code>","text":"<p>Calculate the one-body (Hartree--Fock) energy.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function for each spin channel. If <code>None</code>, use either <code>self.gf</code>, or the mean-field Green's function. Default value is <code>None</code>.</p> <code>None</code> <code>integrals</code> <code>UIntegrals</code> <p>Integrals object. If <code>None</code>, generate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>e_1b</code> <code>float</code> <p>One-body energy.</p> Source code in <code>momentGW/uhf/gw.py</code> <pre><code>@logging.with_timer(\"Energy\")\n@logging.with_status(\"Calculating energy\")\ndef energy_hf(self, gf=None, integrals=None):\n    \"\"\"Calculate the one-body (Hartree--Fock) energy.\n\n    Parameters\n    ----------\n    gf : tuple of dyson.Lehmann, optional\n        Green's function for each spin channel. If `None`, use\n        either `self.gf`, or the mean-field Green's function.\n        Default value is `None`.\n    integrals : UIntegrals, optional\n        Integrals object. If `None`, generate from scratch. Default\n        value is `None`.\n\n    Returns\n    -------\n    e_1b : float\n        One-body energy.\n    \"\"\"\n\n    # Get the Green's function\n    if gf is None:\n        gf = self.gf\n\n    # Get the integrals\n    if integrals is None:\n        integrals = self.ao2mo()\n\n    # Form the Fock matrix\n    with util.SilentSCF(self._scf):\n        h1e = tuple(\n            util.einsum(\"pq,pi,qj-&gt;ij\", self._scf.get_hcore(), c.conj(), c)\n            for c in self.mo_coeff\n        )\n    rdm1 = self.make_rdm1(gf=gf)\n    fock = integrals.get_fock(rdm1, h1e)\n\n    # Calculate the energy parts\n    e_1b = energy.hartree_fock(rdm1[0], fock[0], h1e[0])\n    e_1b += energy.hartree_fock(rdm1[1], fock[1], h1e[1])\n\n    return e_1b\n</code></pre>"},{"location":"reference/uhf/gw/#momentGW.uhf.gw.UGW.energy_gm","title":"<code>momentGW.uhf.gw.UGW.energy_gm(gf=None, se=None, g0=True)</code>","text":"<p>Calculate the two-body (Galitskii--Migdal) energy.</p> <p>Parameters:</p> Name Type Description Default <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Green's function for each spin channel. If <code>None</code>, use <code>self.gf</code>. Default value is <code>None</code>.</p> <code>None</code> <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy for each spin channel. If <code>None</code>, use <code>self.se</code>. Default value is <code>None</code>.</p> <code>None</code> <code>g0</code> <code>bool</code> <p>If <code>True</code>, use the mean-field Green's function. Default value is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>e_2b</code> <code>float</code> <p>Two-body energy.</p> Source code in <code>momentGW/uhf/gw.py</code> <pre><code>@logging.with_timer(\"Energy\")\n@logging.with_status(\"Calculating energy\")\ndef energy_gm(self, gf=None, se=None, g0=True):\n    r\"\"\"Calculate the two-body (Galitskii--Migdal) energy.\n\n    Parameters\n    ----------\n    gf : tuple of dyson.Lehmann, optional\n        Green's function for each spin channel. If `None`, use\n        `self.gf`. Default value is `None`.\n    se : tuple of dyson.Lehmann, optional\n        Self-energy for each spin channel. If `None`, use `self.se`.\n        Default value is `None`.\n    g0 : bool, optional\n        If `True`, use the mean-field Green's function. Default\n        value is `True`.\n\n    Returns\n    -------\n    e_2b : float\n        Two-body energy.\n    \"\"\"\n\n    # Get the Green's function and self-energy\n    if gf is None:\n        gf = self.gf\n    if se is None:\n        se = self.se\n\n    # Calculate the Galitskii--Migdal energy\n    if g0:\n        e_2b_\u03b1 = energy.galitskii_migdal_g0(self.mo_energy[0], self.mo_occ[0], se[0])\n        e_2b_\u03b2 = energy.galitskii_migdal_g0(self.mo_energy[1], self.mo_occ[1], se[1])\n    else:\n        e_2b_\u03b1 = energy.galitskii_migdal(gf[0], se[0])\n        e_2b_\u03b2 = energy.galitskii_migdal(gf[1], se[1])\n\n    # Add the parts\n    e_2b = (e_2b_\u03b1 + e_2b_\u03b2) / 2\n\n    return e_2b\n</code></pre>"},{"location":"reference/uhf/gw/#momentGW.uhf.gw.UGW.init_gf","title":"<code>momentGW.uhf.gw.UGW.init_gf(mo_energy=None)</code>","text":"<p>Initialise the mean-field Green's function.</p> <p>Parameters:</p> Name Type Description Default <code>mo_energy</code> <code>tuple of numpy.ndarray</code> <p>Molecular orbital energies for each spin channel. Default value is <code>self.mo_energy</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>gf</code> <code>tuple of dyson.Lehmann</code> <p>Mean-field Green's function for each spin channel.</p> Source code in <code>momentGW/uhf/gw.py</code> <pre><code>def init_gf(self, mo_energy=None):\n    \"\"\"Initialise the mean-field Green's function.\n\n    Parameters\n    ----------\n    mo_energy : tuple of numpy.ndarray, optional\n        Molecular orbital energies for each spin channel. Default\n        value is `self.mo_energy`.\n\n    Returns\n    -------\n    gf : tuple of dyson.Lehmann\n        Mean-field Green's function for each spin channel.\n    \"\"\"\n\n    # Get the MO energies\n    if mo_energy is None:\n        mo_energy = self.mo_energy\n\n    # Build the Green's functions\n    gf = [\n        Lehmann(mo_energy[0], np.eye(self.nmo[0])),\n        Lehmann(mo_energy[1], np.eye(self.nmo[1])),\n    ]\n\n    # Find the chemical potentials\n    gf[0].chempot, _ = search_chempot(\n        gf[0].energies,\n        gf[0].couplings,\n        self.nmo[0],\n        self.nocc[0],\n        occupancy=1,\n    )\n    gf[1].chempot, _ = search_chempot(\n        gf[1].energies,\n        gf[1].couplings,\n        self.nmo[1],\n        self.nocc[1],\n        occupancy=1,\n    )\n\n    return tuple(gf)\n</code></pre>"},{"location":"reference/uhf/ints/","title":"Ints","text":"<p>Integral helpers with unrestricted reference.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals","title":"<code>momentGW.uhf.ints.UIntegrals(with_df, mo_coeff, mo_occ, compression='ia', compression_tol=1e-10, store_full=False)</code>","text":"<p>             Bases: <code>Integrals</code></p> <p>Container for the density-fitted integrals required for UGW methods.</p> <p>Parameters:</p> Name Type Description Default <code>with_df</code> <code>DF</code> <p>Density fitting object.</p> required <code>mo_coeff</code> <code>ndarray</code> <p>Molecular orbital coefficients for each spin channel.</p> required <code>mo_occ</code> <code>ndarray</code> <p>Molecular orbital occupations for each spin channel.</p> required <code>compression</code> <code>str</code> <p>Compression scheme to use. Default value is <code>'ia'</code>. See <code>momentGW.gw</code> for more details.</p> <code>'ia'</code> <code>compression_tol</code> <code>float</code> <p>Compression tolerance. Default value is <code>1e-10</code>. See <code>momentGW.gw</code> for more details.</p> <code>1e-10</code> <code>store_full</code> <code>bool</code> <p>Store the full MO integrals in memory. Default value is <code>False</code>.</p> <code>False</code> Source code in <code>momentGW/uhf/ints.py</code> <pre><code>def __init__(\n    self,\n    with_df,\n    mo_coeff,\n    mo_occ,\n    compression=\"ia\",\n    compression_tol=1e-10,\n    store_full=False,\n):\n    # Parameters\n    self.with_df = with_df\n    self.mo_coeff = mo_coeff\n    self.mo_occ = mo_occ\n\n    # Options\n    self.compression = compression\n    self.compression_tol = compression_tol\n    self.store_full = store_full\n\n    # Attributes\n    self._spins = {\n        0: _Integrals_\u03b1(\n            self.with_df,\n            self.mo_coeff[0],\n            self.mo_occ[0],\n            compression=self.compression,\n            compression_tol=self.compression_tol,\n            store_full=self.store_full,\n        ),\n        1: _Integrals_\u03b2(\n            self.with_df,\n            self.mo_coeff[1],\n            self.mo_occ[1],\n            compression=self.compression,\n            compression_tol=self.compression_tol,\n            store_full=self.store_full,\n        ),\n    }\n</code></pre>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.Lpq","title":"<code>momentGW.uhf.ints.UIntegrals.Lpq</code>  <code>property</code>","text":"<p>Get the full uncompressed <code>(aux, MO, MO)</code> integrals.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.Lpx","title":"<code>momentGW.uhf.ints.UIntegrals.Lpx</code>  <code>property</code>","text":"<p>Get the compressed <code>(aux, MO, MO)</code> integrals.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.Lia","title":"<code>momentGW.uhf.ints.UIntegrals.Lia</code>  <code>property</code>","text":"<p>Get the compressed <code>(aux, occ, vir)</code> integrals.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.mo_coeff_g","title":"<code>momentGW.uhf.ints.UIntegrals.mo_coeff_g</code>  <code>property</code>","text":"<p>Get the MO coefficients for the Green's function.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.mo_coeff_w","title":"<code>momentGW.uhf.ints.UIntegrals.mo_coeff_w</code>  <code>property</code>","text":"<p>Get the MO coefficients for the screened Coulomb interaction.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.mo_occ_w","title":"<code>momentGW.uhf.ints.UIntegrals.mo_occ_w</code>  <code>property</code>","text":"<p>Get the MO occupation numbers for the screened Coulomb interaction.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.nmo","title":"<code>momentGW.uhf.ints.UIntegrals.nmo</code>  <code>property</code>","text":"<p>Get the number of MOs.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.nocc","title":"<code>momentGW.uhf.ints.UIntegrals.nocc</code>  <code>property</code>","text":"<p>Get the number of occupied MOs.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.nvir","title":"<code>momentGW.uhf.ints.UIntegrals.nvir</code>  <code>property</code>","text":"<p>Get the number of virtual MOs.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.nmo_g","title":"<code>momentGW.uhf.ints.UIntegrals.nmo_g</code>  <code>property</code>","text":"<p>Get the number of MOs for the Green's function.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.nmo_w","title":"<code>momentGW.uhf.ints.UIntegrals.nmo_w</code>  <code>property</code>","text":"<p>Get the number of MOs for the screened Coulomb interaction.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.nocc_w","title":"<code>momentGW.uhf.ints.UIntegrals.nocc_w</code>  <code>property</code>","text":"<p>Get the number of occupied MOs for the screened Coulomb interaction.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.nvir_w","title":"<code>momentGW.uhf.ints.UIntegrals.nvir_w</code>  <code>property</code>","text":"<p>Get the number of virtual MOs for the screened Coulomb interaction.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.naux","title":"<code>momentGW.uhf.ints.UIntegrals.naux</code>  <code>property</code>","text":"<p>Get the number of auxiliary basis functions, after the compression.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.naux_full","title":"<code>momentGW.uhf.ints.UIntegrals.naux_full</code>  <code>property</code>","text":"<p>Get the number of auxiliary basis functions, before the compression.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.is_bare","title":"<code>momentGW.uhf.ints.UIntegrals.is_bare</code>  <code>property</code>","text":"<p>Get a boolean flag indicating whether the integrals have no self-consistencies.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.dtype","title":"<code>momentGW.uhf.ints.UIntegrals.dtype</code>  <code>property</code>","text":"<p>Get the dtype of the integrals.</p>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.get_compression_metric","title":"<code>momentGW.uhf.ints.UIntegrals.get_compression_metric()</code>","text":"<p>Return the compression metric.</p> <p>Returns:</p> Name Type Description <code>rot</code> <code>ndarray</code> <p>Rotation matrix into the compressed auxiliary space.</p> Source code in <code>momentGW/uhf/ints.py</code> <pre><code>@logging.with_status(\"Computing compression metric\")\ndef get_compression_metric(self):\n    \"\"\"\n    Return the compression metric.\n\n    Returns\n    -------\n    rot : numpy.ndarray\n        Rotation matrix into the compressed auxiliary space.\n    \"\"\"\n\n    # Get the compression sectors\n    compression = self._parse_compression()\n    if not compression:\n        return None\n\n    # Initialise the inner product matrix\n    prod = np.zeros((self.naux_full, self.naux_full))\n\n    # Loop over required blocks\n    for key in sorted(compression):\n        for s, spin in enumerate([\"\u03b1\", \"\u03b2\"]):\n            with logging.with_status(f\"{key} ({spin}) sector\"):\n                # Get the coefficients\n                ci, cj = [\n                    {\n                        \"o\": self.mo_coeff[s][:, self.mo_occ[s] &gt; 0],\n                        \"v\": self.mo_coeff[s][:, self.mo_occ[s] == 0],\n                        \"i\": self.mo_coeff_w[s][:, self.mo_occ_w[s] &gt; 0],\n                        \"a\": self.mo_coeff_w[s][:, self.mo_occ_w[s] == 0],\n                    }[k]\n                    for k in key\n                ]\n                ni, nj = ci.shape[-1], cj.shape[-1]\n                coeffs = np.concatenate((ci, cj), axis=1)\n\n                # Loop over the blocks\n                for p0, p1 in mpi_helper.prange(0, ni * nj, self.with_df.blockdim):\n                    i0, j0 = divmod(p0, nj)\n                    i1, j1 = divmod(p1, nj)\n\n                    # Build the (L|xy) array\n                    Lxy = np.zeros((self.naux_full, p1 - p0))\n                    b1 = 0\n                    for block in self.with_df.loop():\n                        b0, b1 = b1, b1 + block.shape[0]\n                        progress = (p0 * self.naux_full + b0) / (ni * nj * self.naux_full)\n                        with logging.with_status(\n                            f\"block [{p0}:{p1}, {b0}:{b1}] ({progress:.1%})\"\n                        ):\n                            tmp = _ao2mo.nr_e2(\n                                block,\n                                coeffs,\n                                (i0, i1 + 1, ni, ni + nj),\n                                aosym=\"s2\",\n                                mosym=\"s1\",\n                            )\n                            tmp = tmp.reshape(b1 - b0, -1)\n                            Lxy[b0:b1] = tmp[:, j0 : j0 + (p1 - p0)]\n\n                    # Update the inner product matrix\n                    prod += np.dot(Lxy, Lxy.T)\n\n    # Reduce the inner product matrix\n    prod = mpi_helper.allreduce(prod, root=0)\n    prod *= 0.5\n\n    # Diagonalise the inner product matrix\n    if mpi_helper.rank == 0:\n        e, v = np.linalg.eigh(prod)\n        mask = np.abs(e) &gt; self.compression_tol\n        rot = v[:, mask]\n    else:\n        rot = np.zeros((0,))\n    del prod\n\n    # Broadcast the rotation matrix in case of hybrid parallelism\n    # introducing non-determinism\n    rot = mpi_helper.bcast(rot, root=0)\n\n    # Print the compression status\n    if rot.shape[-1] == self.naux_full:\n        logging.write(\"No compression found for auxiliary space\")\n        rot = None\n    else:\n        percent = 100 * rot.shape[-1] / self.naux_full\n        style = logging.rate(percent, 80, 95)\n        logging.write(\n            f\"Compressed auxiliary space from {self.naux_full} to {rot.shape[1]} \"\n            f\"([{style}]{percent:.1f}%)[/]\"\n        )\n\n    return rot\n</code></pre>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.transform","title":"<code>momentGW.uhf.ints.UIntegrals.transform(do_Lpq=None, do_Lpx=True, do_Lia=True)</code>","text":"<p>Transform the integrals in-place.</p> <p>Parameters:</p> Name Type Description Default <code>do_Lpq</code> <code>bool</code> <p>Whether to compute the full <code>(aux, MO, MO)</code> array. Default value is <code>True</code> if <code>store_full</code> is <code>True</code>, <code>False</code> otherwise.</p> <code>None</code> <code>do_Lpx</code> <code>bool</code> <p>Whether to compute the compressed <code>(aux, MO, MO)</code> array. Default value is <code>True</code>.</p> <code>True</code> <code>do_Lia</code> <code>bool</code> <p>Whether to compute the compressed <code>(aux, occ, vir)</code> array. Default value is <code>True</code>.</p> <code>True</code> Source code in <code>momentGW/uhf/ints.py</code> <pre><code>def transform(self, do_Lpq=None, do_Lpx=True, do_Lia=True):\n    \"\"\"\n    Transform the integrals in-place.\n\n    Parameters\n    ----------\n    do_Lpq : bool, optional\n        Whether to compute the full ``(aux, MO, MO)`` array. Default\n        value is `True` if `store_full` is `True`, `False`\n        otherwise.\n    do_Lpx : bool, optional\n        Whether to compute the compressed ``(aux, MO, MO)`` array.\n        Default value is `True`.\n    do_Lia : bool, optional\n        Whether to compute the compressed ``(aux, occ, vir)`` array.\n        Default value is `True`.\n    \"\"\"\n\n    # Get the compression metric\n    if self._spins[0]._rot is None:\n        self._spins[0]._rot = self._spins[1]._rot = self.get_compression_metric()\n\n    # Transform the integrals\n    self._spins[0].transform(do_Lpq=do_Lpq, do_Lpx=do_Lpx, do_Lia=do_Lia)\n    self._spins[1].transform(do_Lpq=do_Lpq, do_Lpx=do_Lpx, do_Lia=do_Lia)\n</code></pre>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.update_coeffs","title":"<code>momentGW.uhf.ints.UIntegrals.update_coeffs(mo_coeff_g=None, mo_coeff_w=None, mo_occ_w=None)</code>","text":"<p>Update the MO coefficients for the Green's function and the screened Coulomb interaction.</p> <p>Parameters:</p> Name Type Description Default <code>mo_coeff_g</code> <code>ndarray</code> <p>Coefficients corresponding to the Green's function for each spin. Default value is <code>None</code>.</p> <code>None</code> <code>mo_coeff_w</code> <code>ndarray</code> <p>Coefficients corresponding to the screened Coulomb interaction for each spin. Default value is <code>None</code>.</p> <code>None</code> <code>mo_occ_w</code> <code>ndarray</code> <p>Occupations corresponding to the screened Coulomb interaction for each spin. Default value is <code>None</code>.</p> <code>None</code> Notes <p>If <code>mo_coeff_g</code> is <code>None</code>, the Green's function is assumed to remain in the basis in which it was originally defined, and vice-versa for <code>mo_coeff_w</code> and <code>mo_occ_w</code>. At least one of <code>mo_coeff_g</code> and <code>mo_coeff_w</code> must be provided.</p> Source code in <code>momentGW/uhf/ints.py</code> <pre><code>def update_coeffs(self, mo_coeff_g=None, mo_coeff_w=None, mo_occ_w=None):\n    \"\"\"\n    Update the MO coefficients for the Green's function and the\n    screened Coulomb interaction.\n\n    Parameters\n    ----------\n    mo_coeff_g : numpy.ndarray, optional\n        Coefficients corresponding to the Green's function for each\n        spin. Default value is `None`.\n    mo_coeff_w : numpy.ndarray, optional\n        Coefficients corresponding to the screened Coulomb\n        interaction for each spin. Default value is `None`.\n    mo_occ_w : numpy.ndarray, optional\n        Occupations corresponding to the screened Coulomb\n        interaction for each spin. Default value is `None`.\n\n    Notes\n    -----\n    If `mo_coeff_g` is `None`, the Green's function is assumed to\n    remain in the basis in which it was originally defined, and\n    vice-versa for `mo_coeff_w` and `mo_occ_w`. At least one of\n    `mo_coeff_g` and `mo_coeff_w` must be provided.\n    \"\"\"\n\n    # Check the input\n    if any((mo_coeff_w is not None, mo_occ_w is not None)):\n        assert mo_coeff_w is not None and mo_occ_w is not None\n\n    # Update the Green's function coefficients\n    if mo_coeff_g is not None:\n        self._spins[0]._mo_coeff_g = mo_coeff_g[0]\n        self._spins[1]._mo_coeff_g = mo_coeff_g[1]\n\n    # Update the screened Coulomb interaction coefficients\n    do_all = False\n    rot = None\n    if mo_coeff_w is not None:\n        self._spins[0]._mo_coeff_w = mo_coeff_w[0]\n        self._spins[1]._mo_coeff_w = mo_coeff_w[1]\n        self._spins[0]._mo_occ_w = mo_occ_w[0]\n        self._spins[1]._mo_occ_w = mo_occ_w[1]\n        if \"ia\" in self._parse_compression():\n            do_all = True\n            rot = self.get_compression_metric()\n\n    # Set the compression metric\n    self._spins[0]._rot = rot\n    self._spins[1]._rot = rot\n\n    # Transform the integrals\n    self.transform(\n        do_Lpq=self.store_full and do_all,\n        do_Lpx=mo_coeff_g is not None or do_all,\n        do_Lia=mo_coeff_w is not None or do_all,\n    )\n</code></pre>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.get_j","title":"<code>momentGW.uhf.ints.UIntegrals.get_j(dm, basis='mo')</code>","text":"<p>Build the J matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix for each spin channel.</p> required <code>basis</code> <code>str</code> <p>Basis in which to build the J matrix. One of <code>(\"ao\", \"mo\")</code>. Default value is <code>\"mo\"</code>.</p> <code>'mo'</code> <p>Returns:</p> Name Type Description <code>vj</code> <code>ndarray</code> <p>J matrix for each spin channel.</p> Source code in <code>momentGW/uhf/ints.py</code> <pre><code>def get_j(self, dm, basis=\"mo\"):\n    \"\"\"Build the J matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix for each spin channel.\n    basis : str, optional\n        Basis in which to build the J matrix. One of\n        `(\"ao\", \"mo\")`. Default value is `\"mo\"`.\n\n    Returns\n    -------\n    vj : numpy.ndarray\n        J matrix for each spin channel.\n    \"\"\"\n\n    # Calculate Coulomb term each pair of spins\n    vj_\u03b1\u03b1 = self._spins[0].get_j(dm[0], basis=basis, other=self._spins[0])\n    vj_\u03b1\u03b2 = self._spins[0].get_j(dm[1], basis=basis, other=self._spins[1])\n    vj_\u03b2\u03b2 = self._spins[1].get_j(dm[1], basis=basis, other=self._spins[1])\n    vj_\u03b2\u03b1 = self._spins[1].get_j(dm[0], basis=basis, other=self._spins[0])\n\n    # Build the J matrix for each spin\n    vj = np.array([vj_\u03b1\u03b1 + vj_\u03b1\u03b2, vj_\u03b2\u03b2 + vj_\u03b2\u03b1])\n\n    return vj\n</code></pre>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.get_k","title":"<code>momentGW.uhf.ints.UIntegrals.get_k(dm, basis='mo')</code>","text":"<p>Build the K matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix for each spin channel.</p> required <code>basis</code> <code>str</code> <p>Basis in which to build the K matrix. One of <code>(\"ao\", \"mo\")</code>. Default value is <code>\"mo\"</code>.</p> <code>'mo'</code> <p>Returns:</p> Name Type Description <code>vk</code> <code>ndarray</code> <p>K matrix for each spin channel.</p> Source code in <code>momentGW/uhf/ints.py</code> <pre><code>def get_k(self, dm, basis=\"mo\"):\n    \"\"\"Build the K matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix for each spin channel.\n    basis : str, optional\n        Basis in which to build the K matrix. One of\n        `(\"ao\", \"mo\")`. Default value is `\"mo\"`.\n\n    Returns\n    -------\n    vk : numpy.ndarray\n        K matrix for each spin channel.\n    \"\"\"\n\n    # Calculate exchange term each spin\n    vk_\u03b1\u03b1 = self._spins[0].get_k(dm[0], basis=basis)\n    vk_\u03b2\u03b2 = self._spins[1].get_k(dm[1], basis=basis)\n    vk = np.array([vk_\u03b1\u03b1, vk_\u03b2\u03b2])\n\n    return vk\n</code></pre>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.get_jk","title":"<code>momentGW.uhf.ints.UIntegrals.get_jk(dm, **kwargs)</code>","text":"<p>Build the J and K matrices.</p> <p>Returns:</p> Name Type Description <code>vj</code> <code>ndarray</code> <p>J matrix for each spin channel.</p> <code>vk</code> <code>ndarray</code> <p>K matrix for each spin channel.</p> Notes <p>See <code>get_j</code> and <code>get_k</code> for more information.</p> Source code in <code>momentGW/uhf/ints.py</code> <pre><code>def get_jk(self, dm, **kwargs):\n    \"\"\"Build the J and K matrices.\n\n    Returns\n    -------\n    vj : numpy.ndarray\n        J matrix for each spin channel.\n    vk : numpy.ndarray\n        K matrix for each spin channel.\n\n    Notes\n    -----\n    See `get_j` and `get_k` for more information.\n    \"\"\"\n    return super().get_jk(dm, **kwargs)\n</code></pre>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.get_veff","title":"<code>momentGW.uhf.ints.UIntegrals.get_veff(dm, j=None, k=None, **kwargs)</code>","text":"<p>Build the effective potential.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix for each spin channel.</p> required <code>j</code> <code>ndarray</code> <p>J matrix for each spin channel. If <code>None</code>, compute it. Default value is <code>None</code>.</p> <code>None</code> <code>k</code> <code>ndarray</code> <p>K matrix for each spin channel. If <code>None</code>, compute it. Default value is <code>None</code>.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for <code>get_jk</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>veff</code> <code>ndarray</code> <p>Effective potential for each spin channel.</p> Notes <p>See <code>get_jk</code> for more information.</p> Source code in <code>momentGW/uhf/ints.py</code> <pre><code>def get_veff(self, dm, j=None, k=None, **kwargs):\n    \"\"\"Build the effective potential.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix for each spin channel.\n    j : numpy.ndarray, optional\n        J matrix for each spin channel. If `None`, compute it.\n        Default value is `None`.\n    k : numpy.ndarray, optional\n        K matrix for each spin channel. If `None`, compute it.\n        Default value is `None`.\n    **kwargs : dict, optional\n        Additional keyword arguments for `get_jk`.\n\n    Returns\n    -------\n    veff : numpy.ndarray\n        Effective potential for each spin channel.\n\n    Notes\n    -----\n    See `get_jk` for more information.\n    \"\"\"\n    if j is None and k is None:\n        vj, vk = self.get_jk(dm, **kwargs)\n    elif j is None:\n        vj, vk = self.get_j(dm, **kwargs), k\n    elif k is None:\n        vj, vk = j, self.get_k(dm, **kwargs)\n    return vj - vk\n</code></pre>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.get_fock","title":"<code>momentGW.uhf.ints.UIntegrals.get_fock(dm, h1e, **kwargs)</code>","text":"<p>Build the Fock matrix.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>ndarray</code> <p>Density matrix for each spin channel.</p> required <code>h1e</code> <code>ndarray</code> <p>Core Hamiltonian matrix for each spin channel.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for <code>get_jk</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>fock</code> <code>ndarray</code> <p>Fock matrix for each spin channel.</p> Notes <p>See <code>get_jk</code> for more information. The basis of <code>h1e</code> must be the same as <code>dm</code>.</p> Source code in <code>momentGW/uhf/ints.py</code> <pre><code>def get_fock(self, dm, h1e, **kwargs):\n    \"\"\"Build the Fock matrix.\n\n    Parameters\n    ----------\n    dm : numpy.ndarray\n        Density matrix for each spin channel.\n    h1e : numpy.ndarray\n        Core Hamiltonian matrix for each spin channel.\n    **kwargs : dict, optional\n        Additional keyword arguments for `get_jk`.\n\n    Returns\n    -------\n    fock : numpy.ndarray\n        Fock matrix for each spin channel.\n\n    Notes\n    -----\n    See `get_jk` for more information. The basis of `h1e` must be\n    the same as `dm`.\n    \"\"\"\n    return super().get_fock(dm, h1e, **kwargs)\n</code></pre>"},{"location":"reference/uhf/ints/#momentGW.uhf.ints.UIntegrals.__getitem__","title":"<code>momentGW.uhf.ints.UIntegrals.__getitem__(key)</code>","text":"<p>Get the integrals for one spin.</p> Source code in <code>momentGW/uhf/ints.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"Get the integrals for one spin.\"\"\"\n    return self._spins[key]\n</code></pre>"},{"location":"reference/uhf/qsgw/","title":"Qsgw","text":"<p>Spin-unrestricted quasiparticle self-consistent GW via self-energy moment constraints for molecular systems.</p>"},{"location":"reference/uhf/qsgw/#momentGW.uhf.qsgw.qsUGW","title":"<code>momentGW.uhf.qsgw.qsUGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>UGW</code>, <code>qsGW</code></p> <p>Spin-unrestricted quasiparticle self-consistent GW via self-energy moment constraints for molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>SCF</code> <p>PySCF mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>max_cycle</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>50</code>.</p> required <code>max_cycle_qp</code> <code>int</code> <p>Maximum number of iterations in the quasiparticle equation loop. Default value is <code>50</code>.</p> required <code>conv_tol</code> <code>float</code> <p>Convergence threshold in the change in the HOMO and LUMO. Default value is <code>1e-8</code>.</p> required <code>conv_tol_moms</code> <code>float</code> <p>Convergence threshold in the change in the moments. Default value is <code>1e-8</code>.</p> required <code>conv_tol_qp</code> <code>float</code> <p>Convergence threshold in the change in the density matrix in the quasiparticle equation loop. Default value is <code>1e-8</code>.</p> required <code>conv_logical</code> <code>callable</code> <p>Function that takes an iterable of booleans as input indicating whether the individual <code>conv_tol</code>, <code>conv_tol_moms</code>, <code>conv_tol_qp</code> have been satisfied, respectively, and returns a boolean indicating overall convergence. For example, the function <code>all</code> requires both metrics to be met, and <code>any</code> requires just one. Default value is <code>all</code>.</p> required <code>diis_space</code> <code>int</code> <p>Size of the DIIS extrapolation space. Default value is <code>8</code>.</p> required <code>diis_space_qp</code> <code>int</code> <p>Size of the DIIS extrapolation space in the quasiparticle loop. Default value is <code>8</code>.</p> required <code>damping</code> <code>float</code> <p>Damping parameter. Default value is <code>0.0</code>.</p> required <code>eta</code> <code>float</code> <p>Small value to regularise the self-energy. Default value is <code>1e-1</code>.</p> required <code>srg</code> <code>float</code> <p>If non-zero, use the similarity renormalisation group approach of Marie and Loos in place of the <code>eta</code> regularisation. For value recommendations refer to their paper (arXiv:2303.05984). Default value is <code>0.0</code>.</p> required <code>solver</code> <code>BaseGW</code> <p>Solver to use to obtain the self-energy. Compatible with any <code>BaseGW</code>-like class. Default value is <code>momentGW.gw.GW</code>.</p> required <code>solver_options</code> <code>dict</code> <p>Keyword arguments to pass to the solver. Default value is an empty <code>dict</code>.</p> required Source code in <code>momentGW/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Attributes\n    self.converged = None\n    self.se = None\n    self.gf = None\n    self._qp_energy = None\n</code></pre>"},{"location":"reference/uhf/qsgw/#momentGW.uhf.qsgw.qsUGW.name","title":"<code>momentGW.uhf.qsgw.qsUGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/uhf/qsgw/#momentGW.uhf.qsgw.qsUGW.project_basis","title":"<code>momentGW.uhf.qsgw.qsUGW.project_basis(matrix, ovlp, mo1, mo2)</code>  <code>staticmethod</code>","text":"<p>Project a matrix from one basis to another.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>numpy.ndarray or tuple of dyson.Lehmann</code> <p>Matrix to project for each spin channel. Can also be a tuple of <code>dyson.Lehmann</code> objects, in which case the <code>couplings</code> attributes are projected.</p> required <code>ovlp</code> <code>ndarray</code> <p>Overlap matrix in the shared (AO) basis.</p> required <code>mo1</code> <code>ndarray</code> <p>First basis, rotates from the shared (AO) basis into the basis of <code>matrix</code> for each spin channel.</p> required <code>mo2</code> <code>ndarray</code> <p>Second basis, rotates from the shared (AO) basis into the desired basis of the output for each spin channel.</p> required <p>Returns:</p> Name Type Description <code>proj</code> <code>numpy.ndarray or tuple of dyson.Lehmann</code> <p>Matrix projected into the desired basis for each spin channel.</p> Source code in <code>momentGW/uhf/qsgw.py</code> <pre><code>@staticmethod\ndef project_basis(matrix, ovlp, mo1, mo2):\n    \"\"\"Project a matrix from one basis to another.\n\n    Parameters\n    ----------\n    matrix : numpy.ndarray or tuple of dyson.Lehmann\n        Matrix to project for each spin channel. Can also be a tuple\n        of `dyson.Lehmann` objects, in which case the `couplings`\n        attributes are projected.\n    ovlp : numpy.ndarray\n        Overlap matrix in the shared (AO) basis.\n    mo1 : numpy.ndarray\n        First basis, rotates from the shared (AO) basis into the\n        basis of `matrix` for each spin channel.\n    mo2 : numpy.ndarray\n        Second basis, rotates from the shared (AO) basis into the\n        desired basis of the output for each spin channel.\n\n    Returns\n    -------\n    proj : numpy.ndarray or tuple of dyson.Lehmann\n        Matrix projected into the desired basis for each spin\n        channel.\n    \"\"\"\n\n    # Build the projection matrix\n    proj = util.einsum(\"pq,spi,sqj-&gt;sij\", ovlp, np.conj(mo1), mo2)\n\n    # Project the matrix\n    if isinstance(matrix, np.ndarray):\n        projected_matrix = util.einsum(\n            \"s...pq,s...pi,s...qj-&gt;s...ij\", matrix, np.conj(proj), proj\n        )\n    else:\n        projected_matrix = []\n        for s, m in enumerate(matrix):\n            coupling = util.einsum(\"pk,pi-&gt;ik\", m.couplings, np.conj(proj[s]))\n            projected_m = m.copy()\n            projected_m.couplings = coupling\n            projected_matrix.append(projected_m)\n        projected_matrix = tuple(projected_matrix)\n\n    return projected_matrix\n</code></pre>"},{"location":"reference/uhf/qsgw/#momentGW.uhf.qsgw.qsUGW.self_energy_to_moments","title":"<code>momentGW.uhf.qsgw.qsUGW.self_energy_to_moments(se, nmom_max)</code>  <code>staticmethod</code>","text":"<p>Return the hole and particle moments for a self-energy.</p> <p>Parameters:</p> Name Type Description Default <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy to compute the moments of for each spin channel.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <p>Returns:</p> Name Type Description <code>th</code> <code>ndarray</code> <p>Hole moments for each spin channel.</p> <code>tp</code> <code>ndarray</code> <p>Particle moments for each spin channel.</p> Source code in <code>momentGW/uhf/qsgw.py</code> <pre><code>@staticmethod\ndef self_energy_to_moments(se, nmom_max):\n    \"\"\"\n    Return the hole and particle moments for a self-energy.\n\n    Parameters\n    ----------\n    se : tuple of dyson.Lehmann\n        Self-energy to compute the moments of for each spin channel.\n    nmom_max : int\n        Maximum moment number to calculate.\n\n    Returns\n    -------\n    th : numpy.ndarray\n        Hole moments for each spin channel.\n    tp : numpy.ndarray\n        Particle moments for each spin channel.\n    \"\"\"\n    th = np.array([s.occupied().moment(range(nmom_max + 1)) for s in se])\n    tp = np.array([s.virtual().moment(range(nmom_max + 1)) for s in se])\n    return th, tp\n</code></pre>"},{"location":"reference/uhf/qsgw/#momentGW.uhf.qsgw.qsUGW.build_static_potential","title":"<code>momentGW.uhf.qsgw.qsUGW.build_static_potential(mo_energy, se)</code>","text":"<p>Build the static potential approximation to the self-energy.</p> <p>Parameters:</p> Name Type Description Default <code>mo_energy</code> <code>ndarray</code> <p>Molecular orbital energies for each spin channel.</p> required <code>se</code> <code>tuple of dyson.Lehmann</code> <p>Self-energy to approximate for each spin channel.</p> required <p>Returns:</p> Name Type Description <code>se_qp</code> <code>ndarray</code> <p>Static potential approximation to the self-energy for each spin channel.</p> Source code in <code>momentGW/uhf/qsgw.py</code> <pre><code>def build_static_potential(self, mo_energy, se):\n    \"\"\"Build the static potential approximation to the self-energy.\n\n    Parameters\n    ----------\n    mo_energy : numpy.ndarray\n        Molecular orbital energies for each spin channel.\n    se : tuple of dyson.Lehmann\n        Self-energy to approximate for each spin channel.\n\n    Returns\n    -------\n    se_qp : numpy.ndarray\n        Static potential approximation to the self-energy for each\n        spin channel.\n    \"\"\"\n    return np.array([qsGW.build_static_potential(self, e, s) for e, s in zip(mo_energy, se)])\n</code></pre>"},{"location":"reference/uhf/rpa/","title":"Rpa","text":"<p>Construct RPA moments with unrestricted references.</p>"},{"location":"reference/uhf/rpa/#momentGW.uhf.rpa.dRPA","title":"<code>momentGW.uhf.rpa.dRPA(gw, nmom_max, integrals, mo_energy=None, mo_occ=None)</code>","text":"<p>             Bases: <code>dTDA</code>, <code>dRPA</code></p> <p>Compute the self-energy moments using dRPA and numerical integration with unrestricted references.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseUGW</code> <p>GW object.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>integrals</code> <code>UIntegrals</code> <p>Integrals object.</p> required <code>mo_energy</code> <code>dict</code> <p>Molecular orbital energies for each spin. Keys are \"g\" and \"w\" for the Green's function and screened Coulomb interaction, respectively. If <code>None</code>, use <code>gw.mo_energy</code> for both. Default value is <code>None</code>.</p> <code>None</code> <code>mo_occ</code> <code>dict</code> <p>Molecular orbital occupancies for each spin. Keys are \"g\" and \"w\" for the Green's function and screened Coulomb interaction, respectively. If <code>None</code>, use <code>gw.mo_occ</code> for both. Default value is <code>None</code>.</p> <code>None</code> Source code in <code>momentGW/tda.py</code> <pre><code>def __init__(\n    self,\n    gw,\n    nmom_max,\n    integrals,\n    mo_energy=None,\n    mo_occ=None,\n):\n    # Attributes\n    self.gw = gw\n    self.nmom_max = nmom_max\n    self.integrals = integrals\n\n    # Get the MO energies for G and W\n    if mo_energy is not None:\n        self.mo_energy_g = mo_energy[\"g\"]\n        self.mo_energy_w = mo_energy[\"w\"]\n    else:\n        self.mo_energy_g = self.mo_energy_w = gw.mo_energy\n\n    # Get the MO occupancies for G and W\n    if mo_occ is not None:\n        self.mo_occ_g = mo_occ[\"g\"]\n        self.mo_occ_w = mo_occ[\"w\"]\n    else:\n        self.mo_occ_g = self.mo_occ_w = gw.mo_occ\n\n    # Options and thresholds\n    self.report_quadrature_error = True\n    if self.gw.compression and \"ia\" in self.gw.compression.split(\",\"):\n        self.compression_tol = gw.compression_tol\n    else:\n        self.compression_tol = None\n</code></pre>"},{"location":"reference/uhf/rpa/#momentGW.uhf.rpa.dRPA.integrate","title":"<code>momentGW.uhf.rpa.dRPA.integrate()</code>","text":"<p>Optimise the quadrature and perform the integration.</p> <p>Returns:</p> Name Type Description <code>integrals</code> <code>: tuple of numpy.ndarray</code> <p>Integral array, include the offset part, for each spin channel.</p> Source code in <code>momentGW/uhf/rpa.py</code> <pre><code>@logging.with_timer(\"Numerical integration\")\n@logging.with_status(\"Performing numerical integration\")\ndef integrate(self):\n    \"\"\"Optimise the quadrature and perform the integration.\n\n    Returns\n    -------\n    integrals: : tuple of numpy.ndarray\n        Integral array, include the offset part, for each spin\n        channel.\n    \"\"\"\n\n    a0, a1 = self.mpi_slice(self.nov[0])\n    b0, b1 = self.mpi_slice(self.nov[1])\n\n    # Construct\n    d_full = (\n        util.build_1h1p_energies(self.mo_energy_w[0], self.mo_occ_w[0]).ravel(),\n        util.build_1h1p_energies(self.mo_energy_w[1], self.mo_occ_w[1]).ravel(),\n    )\n    d = (d_full[0][a0:a1], d_full[1][b0:b1])\n\n    # Calculate diagonal part of ERI\n    diag_eri_\u03b1 = np.zeros((self.nov[0],))\n    diag_eri_\u03b1[a0:a1] = util.einsum(\"np,np-&gt;p\", self.integrals[0].Lia, self.integrals[0].Lia)\n    diag_eri_\u03b1 = mpi_helper.allreduce(diag_eri_\u03b1)\n    diag_eri_\u03b2 = np.zeros((self.nov[1],))\n    diag_eri_\u03b2[b0:b1] = util.einsum(\"np,np-&gt;p\", self.integrals[1].Lia, self.integrals[1].Lia)\n    diag_eri_\u03b2 = mpi_helper.allreduce(diag_eri_\u03b2)\n    diag_eri = (diag_eri_\u03b1, diag_eri_\u03b2)\n\n    # Get the offset integral quadrature\n    quad = (\n        self.optimise_offset_quad(d_full[0], diag_eri[0], name=\"Offset (\u03b1)\"),\n        self.optimise_offset_quad(d_full[1], diag_eri[1], name=\"Offset (\u03b2)\"),\n    )\n\n    # Perform the offset integral\n    offset = (\n        self.eval_offset_integral(quad[0], d[0], Lia=self.integrals[0].Lia),\n        self.eval_offset_integral(quad[1], d[1], Lia=self.integrals[1].Lia),\n    )\n\n    # Get the main integral quadrature\n    quad = (\n        self.optimise_main_quad(d_full[0], diag_eri[0], name=\"Main (\u03b1)\"),\n        self.optimise_main_quad(d_full[1], diag_eri[1], name=\"Main (\u03b2)\"),\n    )\n\n    # Perform the main integral\n    integral = (\n        self.eval_main_integral(quad[0], d[0], Lia=self.integrals[0].Lia),\n        self.eval_main_integral(quad[1], d[1], Lia=self.integrals[1].Lia),\n    )\n\n    # Report quadrature errors\n    if self.report_quadrature_error:\n        a = (\n            np.sum((integral[0][0] - integral[0][2]) ** 2),\n            np.sum((integral[1][0] - integral[1][2]) ** 2),\n        )\n        b = (\n            np.sum((integral[0][0] - integral[0][1]) ** 2),\n            np.sum((integral[1][0] - integral[1][1]) ** 2),\n        )\n        a, b = mpi_helper.allreduce(np.array([a, b]))\n        a, b = a**0.5, b**0.5\n        err = (self.estimate_error_clencur(a[0], b[0]), self.estimate_error_clencur(a[1], b[1]))\n        for s, spin in enumerate([\"\u03b1\", \"\u03b2\"]):\n            style_half = logging.rate(a[s], 1e-4, 1e-3)\n            style_quar = logging.rate(b[s], 1e-8, 1e-6)\n            style_full = logging.rate(err[s], 1e-12, 1e-9)\n            logging.write(\n                f\"Error in integral ({spin}):  [{style_full}]{err[s]:.3e}[/] \"\n                f\"(half = [{style_half}]{a[s]:.3e}[/], quarter = [{style_quar}]{b[s]:.3e}[/])\",\n            )\n\n    return (integral[0][0] + offset[0], integral[1][0] + offset[1])\n</code></pre>"},{"location":"reference/uhf/rpa/#momentGW.uhf.rpa.dRPA.build_dd_moments","title":"<code>momentGW.uhf.rpa.dRPA.build_dd_moments(integral=None)</code>","text":"<p>Build the moments of the density-density response.</p> <p>Parameters:</p> Name Type Description Default <code>integral</code> <code>tuple of numpy.ndarray</code> <p>Integral array, include the offset part, for each spin channel. If <code>None</code>, calculate from scratch. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>moments</code> <code>tuple of numpy.ndarray</code> <p>Moments of the density-density response.</p> Source code in <code>momentGW/uhf/rpa.py</code> <pre><code>@logging.with_timer(\"Density-density moments\")\n@logging.with_status(\"Constructing density-density moments\")\ndef build_dd_moments(self, integral=None):\n    \"\"\"Build the moments of the density-density response.\n\n    Parameters\n    ----------\n    integral : tuple of numpy.ndarray, optional\n        Integral array, include the offset part, for each spin\n        channel. If `None`, calculate from scratch. Default value is\n        `None`.\n\n    Returns\n    -------\n    moments : tuple of numpy.ndarray\n        Moments of the density-density response.\n    \"\"\"\n\n    if integral is None:\n        integral = self.integrate()\n\n    a0, a1 = self.mpi_slice(self.nov[0])\n    b0, b1 = self.mpi_slice(self.nov[1])\n    moments = np.zeros((self.nmom_max + 1, self.naux, (a1 - a0) + (b1 - b0)))\n\n    # Construct energy differences\n    d = np.concatenate(\n        [\n            util.build_1h1p_energies(self.mo_energy_w[0], self.mo_occ_w[0]).ravel()[a0:a1],\n            util.build_1h1p_energies(self.mo_energy_w[1], self.mo_occ_w[1]).ravel()[b0:b1],\n        ]\n    )\n\n    # Calculate (L|ia) D_{ia} and (L|ia) D_{ia}^{-1} intermediates\n    Lia = np.concatenate(\n        [\n            self.integrals[0].Lia,\n            self.integrals[1].Lia,\n        ],\n        axis=1,\n    )\n    Liad = Lia * d[None]\n    Liadinv = Lia / d[None]\n    integral = np.concatenate(integral, axis=1)\n\n    # Construct (A-B)^{-1}\n    u = np.dot(Liadinv, Lia.T) * 2.0\n    u = mpi_helper.allreduce(u)\n    u = np.linalg.inv(np.eye(self.naux) + u)\n\n    # Get the zeroth order moment\n    moments[0] = integral / d[None]\n    tmp = np.linalg.multi_dot((integral, Liadinv.T, u))\n    tmp = mpi_helper.allreduce(tmp)\n    moments[0] -= np.dot(tmp, Liadinv) * 2.0\n    del u, tmp\n\n    # Get the first orer moment\n    moments[1] = Liad\n\n    # Get the higher order moments\n    for i in range(2, self.nmom_max + 1):\n        moments[i] = moments[i - 2] * d[None] ** 2\n        tmp = np.dot(moments[i - 2], Lia.T)\n        tmp = mpi_helper.allreduce(tmp)\n        moments[i] += np.dot(tmp, Liad) * 2.0\n        del tmp\n\n    return moments\n</code></pre>"},{"location":"reference/uhf/rpa/#momentGW.uhf.rpa.dRPA.build_dd_moments_exact","title":"<code>momentGW.uhf.rpa.dRPA.build_dd_moments_exact()</code>","text":"<p>Build the exact moments of the density-density response.</p> Notes <p>Placeholder for future implementation.</p> Source code in <code>momentGW/uhf/rpa.py</code> <pre><code>@logging.with_timer(\"Density-density moments\")\n@logging.with_status(\"Constructing density-density moments\")\ndef build_dd_moments_exact(self):\n    \"\"\"Build the exact moments of the density-density response.\n\n    Notes\n    -----\n    Placeholder for future implementation.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/uhf/scgw/","title":"Scgw","text":"<p>Spin-unrestricted self-consistent GW via self-energy moment constraints for molecular systems.</p>"},{"location":"reference/uhf/scgw/#momentGW.uhf.scgw.scUGW","title":"<code>momentGW.uhf.scgw.scUGW(mf, **kwargs)</code>","text":"<p>             Bases: <code>UGW</code>, <code>scGW</code></p> <p>Spin-unrestricted self-consistent GW via self-energy moment constraints for molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mf</code> <code>SCF</code> <p>PySCF mean-field class.</p> required <code>diagonal_se</code> <code>bool</code> <p>If <code>True</code>, use a diagonal approximation in the self-energy. Default value is <code>False</code>.</p> required <code>polarizability</code> <code>str</code> <p>Type of polarizability to use, can be one of <code>(\"drpa\", \"drpa-exact\", \"dtda\", \"thc-dtda\"). Default value is</code>\"drpa\"`.</p> required <code>npoints</code> <code>int</code> <p>Number of numerical integration points. Default value is <code>48</code>.</p> required <code>optimise_chempot</code> <code>bool</code> <p>If <code>True</code>, optimise the chemical potential by shifting the position of the poles in the self-energy relative to those in the Green's function. Default value is <code>False</code>.</p> required <code>fock_loop</code> <code>bool</code> <p>If <code>True</code>, self-consistently renormalise the density matrix according to the updated Green's function. Default value is <code>False</code>.</p> required <code>fock_opts</code> <code>dict</code> <p>Dictionary of options passed to the Fock loop. For more details see <code>momentGW.fock</code>.</p> required <code>compression</code> <code>str</code> <p>Blocks of the ERIs to use as a metric for compression. Can be one or more of <code>(\"oo\", \"ov\", \"vv\", \"ia\")</code> which can be passed as a comma-separated string. <code>\"oo\"</code>, <code>\"ov\"</code> and <code>\"vv\"</code> refer to compression on the initial ERIs, whereas <code>\"ia\"</code> refers to compression on the ERIs entering RPA, which may change under a self-consistent scheme. Default value is <code>\"ia\"</code>.</p> required <code>compression_tol</code> <code>float</code> <p>Tolerance for the compression. Default value is <code>1e-10</code>.</p> required <code>thc_opts</code> <code>dict</code> <p>Dictionary of options to be used for THC calculations. Current implementation requires a filepath to import the THC integrals.</p> required <code>g0</code> <code>bool</code> <p>If <code>True</code>, do not self-consistently update the eigenvalues in the Green's function. Default value is <code>False</code>.</p> required <code>w0</code> <code>bool</code> <p>If <code>True</code>, do not self-consistently update the eigenvalues in the screened Coulomb interaction. Default value is <code>False</code>.</p> required <code>max_cycle</code> <code>int</code> <p>Maximum number of iterations. Default value is <code>50</code>.</p> required <code>conv_tol</code> <code>float</code> <p>Convergence threshold in the change in the HOMO and LUMO. Default value is <code>1e-8</code>.</p> required <code>conv_tol_moms</code> <code>float</code> <p>Convergence threshold in the change in the moments. Default value is <code>1e-8</code>.</p> required <code>diis_space</code> <code>int</code> <p>Size of the DIIS extrapolation space. Default value is <code>8</code>.</p> required <code>damping</code> <code>float</code> <p>Damping parameter. Default value is <code>0.0</code>.</p> required Source code in <code>momentGW/base.py</code> <pre><code>def __init__(self, mf, **kwargs):\n    super().__init__(mf, **kwargs)\n\n    # Attributes\n    self.converged = None\n    self.se = None\n    self.gf = None\n    self._qp_energy = None\n</code></pre>"},{"location":"reference/uhf/scgw/#momentGW.uhf.scgw.scUGW.name","title":"<code>momentGW.uhf.scgw.scUGW.name</code>  <code>property</code>","text":"<p>Get the method name.</p>"},{"location":"reference/uhf/tda/","title":"Tda","text":"<p>Construct TDA moments with unrestricted references.</p>"},{"location":"reference/uhf/tda/#momentGW.uhf.tda.dTDA","title":"<code>momentGW.uhf.tda.dTDA(gw, nmom_max, integrals, mo_energy=None, mo_occ=None)</code>","text":"<p>             Bases: <code>dTDA</code></p> <p>Compute the self-energy moments using dTDA with unrestricted references.</p> <p>Parameters:</p> Name Type Description Default <code>gw</code> <code>BaseUGW</code> <p>GW object.</p> required <code>nmom_max</code> <code>int</code> <p>Maximum moment number to calculate.</p> required <code>integrals</code> <code>UIntegrals</code> <p>Integrals object.</p> required <code>mo_energy</code> <code>dict</code> <p>Molecular orbital energies for each spin. Keys are \"g\" and \"w\" for the Green's function and screened Coulomb interaction, respectively. If <code>None</code>, use <code>gw.mo_energy</code> for both. Default value is <code>None</code>.</p> <code>None</code> <code>mo_occ</code> <code>dict</code> <p>Molecular orbital occupancies for each spin. Keys are \"g\" and \"w\" for the Green's function and screened Coulomb interaction, respectively. If <code>None</code>, use <code>gw.mo_occ</code> for both. Default value is <code>None</code>.</p> <code>None</code> Source code in <code>momentGW/tda.py</code> <pre><code>def __init__(\n    self,\n    gw,\n    nmom_max,\n    integrals,\n    mo_energy=None,\n    mo_occ=None,\n):\n    # Attributes\n    self.gw = gw\n    self.nmom_max = nmom_max\n    self.integrals = integrals\n\n    # Get the MO energies for G and W\n    if mo_energy is not None:\n        self.mo_energy_g = mo_energy[\"g\"]\n        self.mo_energy_w = mo_energy[\"w\"]\n    else:\n        self.mo_energy_g = self.mo_energy_w = gw.mo_energy\n\n    # Get the MO occupancies for G and W\n    if mo_occ is not None:\n        self.mo_occ_g = mo_occ[\"g\"]\n        self.mo_occ_w = mo_occ[\"w\"]\n    else:\n        self.mo_occ_g = self.mo_occ_w = gw.mo_occ\n\n    # Options and thresholds\n    self.report_quadrature_error = True\n    if self.gw.compression and \"ia\" in self.gw.compression.split(\",\"):\n        self.compression_tol = gw.compression_tol\n    else:\n        self.compression_tol = None\n</code></pre>"},{"location":"reference/uhf/tda/#momentGW.uhf.tda.dTDA.nov","title":"<code>momentGW.uhf.tda.dTDA.nov</code>  <code>property</code>","text":"<p>Get the number of ov states in the screened Coulomb interaction.</p>"},{"location":"reference/uhf/tda/#momentGW.uhf.tda.dTDA.build_dd_moments","title":"<code>momentGW.uhf.tda.dTDA.build_dd_moments()</code>","text":"<p>Build the moments of the density-density response.</p> <p>Returns:</p> Name Type Description <code>moments</code> <code>tuple of numpy.ndarray</code> <p>Moments of the density-density response for each spin channel.</p> Source code in <code>momentGW/uhf/tda.py</code> <pre><code>@logging.with_timer(\"Density-density moments\")\n@logging.with_status(\"Constructing density-density moments\")\ndef build_dd_moments(self):\n    \"\"\"Build the moments of the density-density response.\n\n    Returns\n    -------\n    moments : tuple of numpy.ndarray\n        Moments of the density-density response for each spin\n        channel.\n    \"\"\"\n\n    # Initialise the moments\n    a0, a1 = self.mpi_slice(self.nov[0])\n    b0, b1 = self.mpi_slice(self.nov[1])\n    moments = np.zeros((self.nmom_max + 1, self.naux, (a1 - a0) + (b1 - b0)))\n\n    # Construct energy differences\n    d = np.concatenate(\n        [\n            util.build_1h1p_energies(self.mo_energy_w[0], self.mo_occ_w[0]).ravel()[a0:a1],\n            util.build_1h1p_energies(self.mo_energy_w[1], self.mo_occ_w[1]).ravel()[b0:b1],\n        ]\n    )\n\n    # Get the zeroth order moment\n    moments[0] = np.concatenate([self.integrals[0].Lia, self.integrals[1].Lia], axis=1)\n\n    # Get the higher order moments\n    for i in range(1, self.nmom_max + 1):\n        moments[i] = moments[i - 1] * d[None]\n        tmp = np.dot(moments[i - 1], moments[0].T)\n        tmp = mpi_helper.allreduce(tmp)\n        moments[i] += np.dot(tmp, moments[0])\n        del tmp\n\n    return moments\n</code></pre>"},{"location":"reference/uhf/tda/#momentGW.uhf.tda.dTDA.kernel","title":"<code>momentGW.uhf.tda.dTDA.kernel(exact=False)</code>","text":"<p>Run the polarizability calculation to compute moments of the self-energy.</p> <p>Parameters:</p> Name Type Description Default <code>exact</code> <code>bool</code> <p>Has no effect and is only present for compatibility with <code>dRPA</code>. Default value is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>moments_occ</code> <code>ndarray</code> <p>Moments of the occupied self-energy for each spin channel.</p> <code>moments_vir</code> <code>ndarray</code> <p>Moments of the virtual self-energy for each spin channel.</p> Source code in <code>momentGW/uhf/tda.py</code> <pre><code>def kernel(self, exact=False):\n    \"\"\"\n    Run the polarizability calculation to compute moments of the\n    self-energy.\n\n    Parameters\n    ----------\n    exact : bool, optional\n        Has no effect and is only present for compatibility with\n        `dRPA`. Default value is `False`.\n\n    Returns\n    -------\n    moments_occ : numpy.ndarray\n        Moments of the occupied self-energy for each spin channel.\n    moments_vir : numpy.ndarray\n        Moments of the virtual self-energy for each spin channel.\n    \"\"\"\n    return super().kernel(exact=exact)\n</code></pre>"},{"location":"reference/uhf/tda/#momentGW.uhf.tda.dTDA.convolve","title":"<code>momentGW.uhf.tda.dTDA.convolve(eta, eta_orders=None, mo_energy_g=None, mo_occ_g=None)</code>","text":"<p>Handle the convolution of the moments of the Green's function and screened Coulomb interaction.</p> <p>Parameters:</p> Name Type Description Default <code>eta</code> <code>ndarray</code> <p>Moments of the density-density response partly transformed into moments of the screened Coulomb interaction, for each spin channel.</p> required <code>mo_energy_g</code> <code>ndarray</code> <p>Energies of the Green's function for each spin channel. If <code>None</code>, use <code>self.mo_energy_g</code>. Default value is <code>None</code>.</p> <code>None</code> <code>eta_orders</code> <code>list</code> <p>List of orders for the rotated density-density moments in <code>eta</code>. If <code>None</code>, assume it spans all required orders. Default value is <code>None</code>.</p> <code>None</code> <code>mo_occ_g</code> <code>ndarray</code> <p>Occupancies of the Green's function for each spin channel. If <code>None</code>, use <code>self.mo_occ_g</code>. Default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>moments_occ</code> <code>ndarray</code> <p>Moments of the occupied self-energy for each spin channel.</p> <code>moments_vir</code> <code>ndarray</code> <p>Moments of the virtual self-energy for each spin channel.</p> Source code in <code>momentGW/uhf/tda.py</code> <pre><code>@logging.with_timer(\"Moment convolution\")\n@logging.with_status(\"Convoluting moments\")\ndef convolve(self, eta, eta_orders=None, mo_energy_g=None, mo_occ_g=None):\n    \"\"\"\n    Handle the convolution of the moments of the Green's function\n    and screened Coulomb interaction.\n\n    Parameters\n    ----------\n    eta : numpy.ndarray\n        Moments of the density-density response partly transformed\n        into moments of the screened Coulomb interaction, for each\n        spin channel.\n    mo_energy_g : numpy.ndarray, optional\n        Energies of the Green's function for each spin channel. If\n        `None`, use `self.mo_energy_g`. Default value is `None`.\n    eta_orders : list, optional\n        List of orders for the rotated density-density moments in\n        `eta`. If `None`, assume it spans all required orders.\n        Default value is `None`.\n    mo_occ_g : numpy.ndarray, optional\n        Occupancies of the Green's function for each spin channel.\n        If `None`, use `self.mo_occ_g`. Default value is `None`.\n\n    Returns\n    -------\n    moments_occ : numpy.ndarray\n        Moments of the occupied self-energy for each spin channel.\n    moments_vir : numpy.ndarray\n        Moments of the virtual self-energy for each spin channel.\n    \"\"\"\n    return super().convolve(\n        eta,\n        eta_orders=eta_orders,\n        mo_energy_g=mo_energy_g,\n        mo_occ_g=mo_occ_g,\n    )\n</code></pre>"},{"location":"reference/uhf/tda/#momentGW.uhf.tda.dTDA.build_se_moments","title":"<code>momentGW.uhf.tda.dTDA.build_se_moments(moments_dd)</code>","text":"<p>Build the moments of the self-energy via convolution.</p> <p>Parameters:</p> Name Type Description Default <code>moments_dd</code> <code>ndarray</code> <p>Moments of the density-density response for each spin channel.</p> required <p>Returns:</p> Name Type Description <code>moments_occ</code> <code>ndarray</code> <p>Moments of the occupied self-energy for each spin channel.</p> <code>moments_vir</code> <code>ndarray</code> <p>Moments of the virtual self-energy for each spin channel.</p> Source code in <code>momentGW/uhf/tda.py</code> <pre><code>@logging.with_timer(\"Self-energy moments\")\n@logging.with_status(\"Constructing self-energy moments\")\ndef build_se_moments(self, moments_dd):\n    \"\"\"Build the moments of the self-energy via convolution.\n\n    Parameters\n    ----------\n    moments_dd : numpy.ndarray\n        Moments of the density-density response for each spin\n        channel.\n\n    Returns\n    -------\n    moments_occ : numpy.ndarray\n        Moments of the occupied self-energy for each spin channel.\n    moments_vir : numpy.ndarray\n        Moments of the virtual self-energy for each spin channel.\n    \"\"\"\n\n    # Setup dependent on diagonal SE\n    a0, a1 = self.mpi_slice(self.mo_energy_g[0].size)\n    b0, b1 = self.mpi_slice(self.mo_energy_g[1].size)\n    if self.gw.diagonal_se:\n        eta = [\n            np.zeros((a1 - a0, self.nmo[0])),\n            np.zeros((b1 - b0, self.nmo[1])),\n        ]\n        pq = p = q = \"p\"\n    else:\n        eta = [\n            np.zeros((a1 - a0, self.nmo[0], self.nmo[0])),\n            np.zeros((b1 - b0, self.nmo[1], self.nmo[1])),\n        ]\n        pq, p, q = \"pq\", \"p\", \"q\"\n\n    # Concatenate the integrals\n    Lia = np.concatenate([self.integrals[0].Lia, self.integrals[1].Lia], axis=1)\n\n    # Initialise output moments\n    moments_occ = [\n        np.zeros((self.nmom_max + 1, self.nmo[0], self.nmo[0])),\n        np.zeros((self.nmom_max + 1, self.nmo[1], self.nmo[1])),\n    ]\n    moments_vir = [\n        np.zeros((self.nmom_max + 1, self.nmo[0], self.nmo[0])),\n        np.zeros((self.nmom_max + 1, self.nmo[1], self.nmo[1])),\n    ]\n\n    # Get the moments in (aux|aux) and rotate to (mo|mo)\n    for n in range(self.nmom_max + 1):\n        eta_aux = np.dot(moments_dd[n], Lia.T)\n        eta_aux = mpi_helper.allreduce(eta_aux)\n        for x in range(a1 - a0):\n            Lp = self.integrals[0].Lpx[:, :, x]\n            eta[0][x] = util.einsum(f\"P{p},Q{q},PQ-&gt;{pq}\", Lp, Lp, eta_aux)\n        for x in range(b1 - b0):\n            Lp = self.integrals[1].Lpx[:, :, x]\n            eta[1][x] = util.einsum(f\"P{p},Q{q},PQ-&gt;{pq}\", Lp, Lp, eta_aux)\n\n        # Construct the self-energy moments for this order only\n        # to save memory\n        moments_occ_n, moments_vir_n = self.convolve(\n            eta[0][:, None],\n            eta_orders=[n],\n            mo_energy_g=self.mo_energy_g[0],\n            mo_occ_g=self.mo_occ_g[0],\n        )\n        moments_occ[0] += moments_occ_n\n        moments_vir[0] += moments_vir_n\n        moments_occ_n, moments_vir_n = self.convolve(\n            eta[1][:, None],\n            eta_orders=[n],\n            mo_energy_g=self.mo_energy_g[1],\n            mo_occ_g=self.mo_occ_g[1],\n        )\n        moments_occ[1] += moments_occ_n\n        moments_vir[1] += moments_vir_n\n\n    return tuple(moments_occ), tuple(moments_vir)\n</code></pre>"},{"location":"reference/uhf/tda/#momentGW.uhf.tda.dTDA.build_dp_moments","title":"<code>momentGW.uhf.tda.dTDA.build_dp_moments()</code>","text":"<p>Build the moments of the dynamic polarizability for optical spectra calculations.</p> Notes <p>Placeholder for future implementation.</p> Source code in <code>momentGW/uhf/tda.py</code> <pre><code>@logging.with_timer(\"Dynamic polarizability moments\")\n@logging.with_status(\"Constructing dynamic polarizability moments\")\ndef build_dp_moments(self):\n    \"\"\"\n    Build the moments of the dynamic polarizability for optical\n    spectra calculations.\n\n    Notes\n    -----\n    Placeholder for future implementation.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/uhf/tda/#momentGW.uhf.tda.dTDA.build_dd_moment_inv","title":"<code>momentGW.uhf.tda.dTDA.build_dd_moment_inv()</code>","text":"<p>Build the first inverse (<code>n=-1</code>) moment of the density-density response.</p> Notes <p>Placeholder for future implementation.</p> Source code in <code>momentGW/uhf/tda.py</code> <pre><code>@logging.with_timer(\"Inverse density-density moment\")\n@logging.with_status(\"Constructing inverse density-density moment\")\ndef build_dd_moment_inv(self):\n    r\"\"\"\n    Build the first inverse (`n=-1`) moment of the density-density\n    response.\n\n    Notes\n    -----\n    Placeholder for future implementation.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"}]}