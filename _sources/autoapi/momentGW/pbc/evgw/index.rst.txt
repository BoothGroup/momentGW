:py:mod:`momentGW.pbc.evgw`
===========================

.. py:module:: momentGW.pbc.evgw

.. autoapi-nested-parse::

   Spin-restricted eigenvalue self-consistent GW via self-energy moment
   constraints for periodic systems.



Module Contents
---------------

.. py:class:: evKGW(mf, **kwargs)


   Bases: :py:obj:`momentGW.pbc.gw.KGW`, :py:obj:`momentGW.evgw.evGW`

   Spin-restricted eigenvalue self-consistent GW via self-energy moment
   constraints for periodic systems.

   :param mf: PySCF periodic mean-field class.
   :type mf: pyscf.pbc.scf.KSCF
   :param diagonal_se: If `True`, use a diagonal approximation in the self-energy.
                       Default value is `False`.
   :type diagonal_se: bool, optional
   :param polarizability: Type of polarizability to use, can be one of `("drpa",
                          "drpa-exact", "dtda", "thc-dtda"). Default value is `"drpa"`.
   :type polarizability: str, optional
   :param npoints: Number of numerical integration points. Default value is `48`.
   :type npoints: int, optional
   :param optimise_chempot: If `True`, optimise the chemical potential by shifting the
                            position of the poles in the self-energy relative to those in
                            the Green's function. Default value is `False`.
   :type optimise_chempot: bool, optional
   :param fock_loop: If `True`, self-consistently renormalise the density matrix
                     according to the updated Green's function. Default value is
                     `False`.
   :type fock_loop: bool, optional
   :param fock_opts: Dictionary of options passed to the Fock loop. For more details
                     see `momentGW.fock`.
   :type fock_opts: dict, optional
   :param compression: Blocks of the ERIs to use as a metric for compression. Can be
                       one or more of `("oo", "ov", "vv", "ia")` which can be passed as
                       a comma-separated string. `"oo"`, `"ov"` and `"vv"` refer to
                       compression on the initial ERIs, whereas `"ia"` refers to
                       compression on the ERIs entering RPA, which may change under a
                       self-consistent scheme. Default value is `"ia"`.
   :type compression: str, optional
   :param compression_tol: Tolerance for the compression. Default value is `1e-10`.
   :type compression_tol: float, optional
   :param thc_opts: Dictionary of options to be used for THC calculations. Current
                    implementation requires a filepath to import the THC integrals.
   :type thc_opts: dict, optional
   :param fc: If `True`, apply finite size corrections. Default value is
              `False`.
   :type fc: bool, optional
   :param g0: If `True`, do not self-consistently update the eigenvalues in
              the Green's function. Default value is `False`.
   :type g0: bool, optional
   :param w0: If `True`, do not self-consistently update the eigenvalues in
              the screened Coulomb interaction. Default value is `False`.
   :type w0: bool, optional
   :param max_cycle: Maximum number of iterations. Default value is `50`.
   :type max_cycle: int, optional
   :param conv_tol: Convergence threshold in the change in the HOMO and LUMO.
                    Default value is `1e-8`.
   :type conv_tol: float, optional
   :param conv_tol_moms: Convergence threshold in the change in the moments. Default
                         value is `1e-8`.
   :type conv_tol_moms: float, optional
   :param conv_logical: Function that takes an iterable of booleans as input indicating
                        whether the individual `conv_tol` and `conv_tol_moms` have been
                        satisfied, respectively, and returns a boolean indicating
                        overall convergence. For example, the function `all` requires
                        both metrics to be met, and `any` requires just one. Default
                        value is `all`.
   :type conv_logical: callable, optional
   :param diis_space: Size of the DIIS extrapolation space. Default value is `8`.
   :type diis_space: int, optional
   :param damping: Damping parameter. Default value is `0.0`.
   :type damping: float, optional
   :param weight_tol: Threshold in physical weight of Green's function poles, below
                      which they are considered zero. Default value is `1e-11`.
   :type weight_tol: float, optional

   .. py:property:: name

      Get the method name.

   .. py:property:: cell

      Get the unit cell.

   .. py:property:: mol

      Alias for `self.cell`.

   .. py:property:: nmo

      Get the number of molecular orbitals.

   .. py:property:: kpts

      Get the k-points.

   .. py:property:: nkpts

      Get the number of k-points.

   .. py:property:: qp_energy

      Get the quasiparticle energies.

      .. rubric:: Notes

      For most GW methods, this simply consists of the poles of the
      `self.gf` that best overlap with the MOs, in order. In some
      methods such as qsGW, these two quantities are not the same.

   .. py:property:: has_fock_loop

      Get a boolean indicating whether the solver requires a Fock
      loop.

      .. rubric:: Notes

      For most GW methods, this is simply `self.fock_loop`. In some
      methods such as qsGW, a Fock loop is required with or without
      `self.fock_loop` for the quasiparticle self-consistency, with
      this property acting as a hook to indicate this.

   .. py:property:: with_df

      Get the density fitting object.

   .. py:property:: nao

      Get the number of atomic orbitals.

   .. py:property:: nocc

      Get the number of occupied molecular orbitals.

   .. py:property:: active

      Get the mask to remove frozen orbitals.

   .. py:property:: mo_energy

      Get the molecular orbital energies.

   .. py:property:: mo_energy_with_frozen

      Get the molecular orbital energies with frozen orbitals.

   .. py:property:: mo_coeff

      Get the molecular orbital coefficients.

   .. py:property:: mo_coeff_with_frozen

      Get the molecular orbital coefficients with frozen orbitals.

   .. py:property:: mo_occ

      Get the molecular orbital occupation numbers.

   .. py:property:: mo_occ_with_frozen

      Get the molecular orbital occupation numbers with frozen
      orbitals.

   .. py:method:: check_convergence(mo_energy, mo_energy_prev, th, th_prev, tp, tp_prev)

      Check for convergence, and print a summary of changes.

      :param mo_energy: Molecular orbital energies at each k-point.
      :type mo_energy: numpy.ndarray
      :param mo_energy_prev: Molecular orbital energies from the previous iteration at
                             each k-point.
      :type mo_energy_prev: numpy.ndarray
      :param th: Moments of the occupied self-energy at each k-point.
      :type th: numpy.ndarray
      :param th_prev: Moments of the occupied self-energy from the previous
                      iteration at each k-point.
      :type th_prev: numpy.ndarray
      :param tp: Moments of the virtual self-energy at each k-point.
      :type tp: numpy.ndarray
      :param tp_prev: Moments of the virtual self-energy from the previous
                      iteration at each k-point.
      :type tp_prev: numpy.ndarray

      :returns: **conv** -- Convergence flag.
      :rtype: bool


   .. py:method:: remove_unphysical_poles(gf)

      Remove unphysical poles from the Green's function to stabilise
      iterations, according to the threshold `self.weight_tol`.

      :param gf: Green's function at each k-point.
      :type gf: tuple of dyson.Lehmann

      :returns: **gf_out** -- Green's function at each k-point, with potentially fewer
                poles.
      :rtype: tuple of dyson.Lehmann


   .. py:method:: build_se_static(integrals)

      Build the static part of the self-energy, including the Fock
      matrix.

      :param integrals: Integrals object.
      :type integrals: KIntegrals

      :returns: **se_static** -- Static part of the self-energy at each k-point. If
                `self.diagonal_se`, non-diagonal elements are set to zero.
      :rtype: numpy.ndarray


   .. py:method:: build_se_moments(nmom_max, integrals, **kwargs)

      Build the moments of the self-energy.

      :param nmom_max: Maximum moment number to calculate.
      :type nmom_max: int
      :param integrals: Density-fitted integrals.
      :type integrals: KIntegrals
      :param See functions in `momentGW.rpa` for `kwargs` options.:

      :returns: * **se_moments_hole** (*numpy.ndarray*) -- Moments of the hole self-energy at each k-point. If
                  `self.diagonal_se`, non-diagonal elements are set to zero.
                * **se_moments_part** (*numpy.ndarray*) -- Moments of the particle self-energy at each k-point. If
                  `self.diagonal_se`, non-diagonal elements are set to zero.


   .. py:method:: ao2mo(transform=True)

      Get the integrals object.

      :param transform: Whether to transform the integrals object.
      :type transform: bool, optional

      :returns: **integrals** -- Integrals object.
      :rtype: KIntegrals

      .. seealso:: :obj:`momentGW.pbc.ints.KIntegrals`, :obj:`momentGW.pbc.thc.KIntegrals`


   .. py:method:: solve_dyson(se_moments_hole, se_moments_part, se_static, integrals=None)

      Solve the Dyson equation due to a self-energy resulting
      from a list of hole and particle moments, along with a static
      contribution.

      Also finds a chemical potential best satisfying the physical
      number of electrons. If `self.optimise_chempot`, this will
      shift the self-energy poles relative to the Green's function,
      which is a partial self-consistency that better conserves the
      particle number.

      If `self.fock_loop`, this function will also require that the
      outputted Green's function is self-consistent with respect to
      the corresponding density and Fock matrix.

      :param se_moments_hole: Moments of the hole self-energy at each k-point.
      :type se_moments_hole: numpy.ndarray
      :param se_moments_part: Moments of the particle self-energy at each k-point.
      :type se_moments_part: numpy.ndarray
      :param se_static: Static part of the self-energy at each k-point.
      :type se_static: numpy.ndarray
      :param integrals: Density-fitted integrals. Required if `self.fock_loop`
                        is `True`. Default value is `None`.
      :type integrals: KIntegrals, optional

      :returns: * **gf** (*tuple of dyson.Lehmann*) -- Green's function at each k-point.
                * **se** (*tuple of dyson.Lehmann*) -- Self-energy at each k-point.

      .. seealso:: :obj:`momentGW.pbc.fock.FockLoop`


   .. py:method:: kernel(nmom_max, moments=None, integrals=None)

      Driver for the method.

      :param nmom_max: Maximum moment number to calculate.
      :type nmom_max: int
      :param moments: Tuple of (hole, particle) moments at each k-point, if passed
                      then they will be used instead of calculating them. Default
                      value is `None`.
      :type moments: tuple of numpy.ndarray, optional
      :param integrals: Integrals object. If `None`, generate from scratch. Default
                        value is `None`.
      :type integrals: KIntegrals, optional

      :returns: * **converged** (*bool*) -- Whether the solver converged. For single-shot calculations,
                  this is always `True`.
                * **gf** (*tuple of dyson.Lehmann*) -- Green's function object at each k-point.
                * **se** (*tuple of dyson.Lehmann*) -- Self-energy object at each k-point.
                * **qp_energy** (*NoneType*) -- Quasiparticle energies. For most GW methods, this is `None`.


   .. py:method:: make_rdm1(gf=None)

      Get the first-order reduced density matrix.

      :param gf: Green's function at each k-point. If `None`, use either
                 `self.gf`, or the mean-field Green's function. Default
                 value is `None`.
      :type gf: tuple of dyson.Lehmann, optional

      :returns: **rdm1** -- First-order reduced density matrix at each k-point.
      :rtype: numpy.ndarray


   .. py:method:: energy_hf(gf=None, integrals=None)

      Calculate the one-body (Hartree--Fock) energy.

      :param gf: Green's function at each k-point. If `None`, use either
                 `self.gf`, or the mean-field Green's function. Default
                 value is `None`.
      :type gf: tuple of dyson.Lehmann, optional
      :param integrals: Integrals object. If `None`, generate from scratch. Default
                        value is `None`.
      :type integrals: KIntegrals, optional

      :returns: **e_1b** -- One-body energy.
      :rtype: float


   .. py:method:: energy_gm(gf=None, se=None, g0=True)

      Calculate the two-body (Galitskii--Migdal) energy.

      :param gf: Green's function at each k-point for each spin channel. If
                 `None`, use `self.gf`. Default value is `None`.
      :type gf: tuple of tuple of dyson.Lehmann, optional
      :param se: Self-energy at each k-point for each spin channel. If
                 `None`, use `self.se`. Default value is `None`.
      :type se: tuple of tuple of dyson.Lehmann, optional
      :param g0: If `True`, use the mean-field Green's function. Default
                 value is `True`.
      :type g0: bool, optional

      :returns: **e_2b** -- Two-body energy.
      :rtype: float


   .. py:method:: interpolate(mf, nmom_max)

      Interpolate the object to a new k-point grid, represented by a
      new mean-field object.

      :param mf: Mean-field object on new k-point mesh.
      :type mf: pyscf.pbc.scf.KSCF
      :param nmom_max: Maximum moment number to calculate.
      :type nmom_max: int

      :returns: **other** -- Interpolated object.
      :rtype: __class__


   .. py:method:: init_gf(mo_energy=None)

      Initialise the mean-field Green's function.

      :param mo_energy: Molecular orbital energies at each k-point. Default value is
                        `self.mo_energy`.
      :type mo_energy: numpy.ndarray, optional

      :returns: **gf** -- Mean-field Green's function at each k-point.
      :rtype: tuple of dyson.Lehmann


   .. py:method:: run(*args, **kwargs)

      Alias for `kernel`, instead returning `self`.

      :param \*args: Positional arguments to pass to `kernel`.
      :type \*args: tuple
      :param \*\*kwargs: Keyword arguments to pass to `kernel`.
      :type \*\*kwargs: dict

      :returns: **self** -- The solver object.
      :rtype: BaseGW


   .. py:method:: moment_error(se_moments_hole, se_moments_part, se)

      Return the error in the moments.

      :param se_moments_hole: Moments of the hole self-energy.
      :type se_moments_hole: numpy.ndarray
      :param se_moments_part: Moments of the particle self-energy.
      :type se_moments_part: numpy.ndarray
      :param se: Self-energy object.
      :type se: dyson.Lehmann

      :returns: * **eh** (*float*) -- Error in the hole moments.
                * **ep** (*float*) -- Error in the particle moments.


   .. py:method:: energy_nuc()

      Calculate the nuclear repulsion energy.

      :returns: **e_nuc** -- Nuclear repulsion energy.
      :rtype: float



