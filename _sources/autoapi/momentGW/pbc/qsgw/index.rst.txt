:py:mod:`momentGW.pbc.qsgw`
===========================

.. py:module:: momentGW.pbc.qsgw

.. autoapi-nested-parse::

   Spin-restricted quasiparticle self-consistent GW via self-energy moment
   constraints for periodic systems.



Module Contents
---------------

.. py:class:: qsKGW(mf, **kwargs)


   Bases: :py:obj:`momentGW.pbc.gw.KGW`, :py:obj:`momentGW.qsgw.qsGW`

   Spin-restricted quasiparticle self-consistent GW via self-energy
   moment constraints for periodic systems.

   :param mf: PySCF periodic mean-field class.
   :type mf: pyscf.pbc.scf.KSCF
   :param diagonal_se: If `True`, use a diagonal approximation in the self-energy.
                       Default value is `False`.
   :type diagonal_se: bool, optional
   :param polarizability: Type of polarizability to use, can be one of `("drpa",
                          "drpa-exact", "dtda", "thc-dtda"). Default value is `"drpa"`.
   :type polarizability: str, optional
   :param npoints: Number of numerical integration points. Default value is `48`.
   :type npoints: int, optional
   :param optimise_chempot: If `True`, optimise the chemical potential by shifting the
                            position of the poles in the self-energy relative to those in
                            the Green's function. Default value is `False`.
   :type optimise_chempot: bool, optional
   :param fock_loop: If `True`, self-consistently renormalise the density matrix
                     according to the updated Green's function. Default value is
                     `False`.
   :type fock_loop: bool, optional
   :param fock_opts: Dictionary of options passed to the Fock loop. For more details
                     see `momentGW.fock`.
   :type fock_opts: dict, optional
   :param compression: Blocks of the ERIs to use as a metric for compression. Can be
                       one or more of `("oo", "ov", "vv", "ia")` which can be passed as
                       a comma-separated string. `"oo"`, `"ov"` and `"vv"` refer to
                       compression on the initial ERIs, whereas `"ia"` refers to
                       compression on the ERIs entering RPA, which may change under a
                       self-consistent scheme. Default value is `"ia"`.
   :type compression: str, optional
   :param compression_tol: Tolerance for the compression. Default value is `1e-10`.
   :type compression_tol: float, optional
   :param thc_opts: Dictionary of options to be used for THC calculations. Current
                    implementation requires a filepath to import the THC integrals.
   :type thc_opts: dict, optional
   :param fc: If `True`, apply finite size corrections. Default value is
              `False`.
   :type fc: bool, optional
   :param max_cycle: Maximum number of iterations. Default value is `50`.
   :type max_cycle: int, optional
   :param max_cycle_qp: Maximum number of iterations in the quasiparticle equation
                        loop. Default value is `50`.
   :type max_cycle_qp: int, optional
   :param conv_tol: Convergence threshold in the change in the HOMO and LUMO.
                    Default value is `1e-8`.
   :type conv_tol: float, optional
   :param conv_tol_moms: Convergence threshold in the change in the moments. Default
                         value is `1e-8`.
   :type conv_tol_moms: float, optional
   :param conv_tol_qp: Convergence threshold in the change in the density matrix in
                       the quasiparticle equation loop. Default value is `1e-8`.
   :type conv_tol_qp: float, optional
   :param conv_logical: Function that takes an iterable of booleans as input indicating
                        whether the individual `conv_tol`, `conv_tol_moms`,
                        `conv_tol_qp` have been satisfied, respectively, and returns a
                        boolean indicating overall convergence. For example, the
                        function `all` requires both metrics to be met, and `any`
                        requires just one. Default value is `all`.
   :type conv_logical: callable, optional
   :param diis_space: Size of the DIIS extrapolation space. Default value is `8`.
   :type diis_space: int, optional
   :param diis_space_qp: Size of the DIIS extrapolation space in the quasiparticle
                         loop. Default value is `8`.
   :type diis_space_qp: int, optional
   :param damping: Damping parameter. Default value is `0.0`.
   :type damping: float, optional
   :param eta: Small value to regularise the self-energy. Default value is
               `1e-1`.
   :type eta: float, optional
   :param srg: If non-zero, use the similarity renormalisation group approach
               of Marie and Loos in place of the `eta` regularisation. For
               value recommendations refer to their paper (arXiv:2303.05984).
               Default value is `0.0`.
   :type srg: float, optional
   :param solver: Solver to use to obtain the self-energy. Compatible with any
                  `BaseGW`-like class. Default value is `momentGW.gw.GW`.
   :type solver: BaseGW, optional
   :param solver_options: Keyword arguments to pass to the solver. Default value is an
                          empty `dict`.
   :type solver_options: dict, optional

   .. py:property:: name

      Get the method name.

   .. py:property:: cell

      Get the unit cell.

   .. py:property:: mol

      Alias for `self.cell`.

   .. py:property:: nmo

      Get the number of molecular orbitals.

   .. py:property:: kpts

      Get the k-points.

   .. py:property:: nkpts

      Get the number of k-points.

   .. py:property:: qp_energy

      Get the quasiparticle energies.

      .. rubric:: Notes

      For most GW methods, this simply consists of the poles of the
      `self.gf` that best overlap with the MOs, in order. In some
      methods such as qsGW, these two quantities are not the same.

   .. py:property:: has_fock_loop

      Get a boolean indicating whether the solver requires a Fock
      loop.

      .. rubric:: Notes

      For most GW methods, this is simply `self.fock_loop`. In some
      methods such as qsGW, a Fock loop is required with or without
      `self.fock_loop` for the quasiparticle self-consistency, with
      this property acting as a hook to indicate this.

   .. py:property:: with_df

      Get the density fitting object.

   .. py:property:: nao

      Get the number of atomic orbitals.

   .. py:property:: nocc

      Get the number of occupied molecular orbitals.

   .. py:property:: active

      Get the mask to remove frozen orbitals.

   .. py:property:: mo_energy

      Get the molecular orbital energies.

   .. py:property:: mo_energy_with_frozen

      Get the molecular orbital energies with frozen orbitals.

   .. py:property:: mo_coeff

      Get the molecular orbital coefficients.

   .. py:property:: mo_coeff_with_frozen

      Get the molecular orbital coefficients with frozen orbitals.

   .. py:property:: mo_occ

      Get the molecular orbital occupation numbers.

   .. py:property:: mo_occ_with_frozen

      Get the molecular orbital occupation numbers with frozen
      orbitals.

   .. py:method:: project_basis(matrix, ovlp, mo1, mo2)
      :staticmethod:

      Project a matrix from one basis to another.

      :param matrix: Matrix to project at each k-point. Can also be a tuple of
                     `dyson.Lehmann` objects, in which case the `couplings`
                     attributes are projected.
      :type matrix: numpy.ndarray or tuple of dyson.Lehmann
      :param ovlp: Overlap matrix in the shared (AO) basis at each k-point.
      :type ovlp: numpy.ndarray
      :param mo1: First basis, rotates from the shared (AO) basis into the
                  basis of `matrix` at each k-point.
      :type mo1: numpy.ndarray
      :param mo2: Second basis, rotates from the shared (AO) basis into the
                  desired basis of the output at each k-point.
      :type mo2: numpy.ndarray

      :returns: **proj** -- Matrix projected into the desired basis at each k-point.
      :rtype: numpy.ndarray or tuple of dyson.Lehmann


   .. py:method:: self_energy_to_moments(se, nmom_max)
      :staticmethod:

      Return the hole and particle moments for a self-energy.

      :param se: Self-energy to compute the moments of at each k-point.
      :type se: tuple of dyson.Lehmann

      :returns: * **th** (*numpy.ndarray*) -- Hole moments at each k-point.
                * **tp** (*numpy.ndarray*) -- Particle moments at each k-point.


   .. py:method:: build_static_potential(mo_energy, se)

      Build the static potential approximation to the self-energy.

      :param mo_energy: Molecular orbital energies at each k-point.
      :type mo_energy: numpy.ndarray
      :param se: Self-energy to approximate at each k-point.
      :type se: tuple of dyson.Lehmann

      :returns: **se_qp** -- Static potential approximation to the self-energy at each
                k-point.
      :rtype: numpy.ndarray


   .. py:method:: build_se_static(integrals)

      Build the static part of the self-energy, including the Fock
      matrix.

      :param integrals: Integrals object.
      :type integrals: KIntegrals

      :returns: **se_static** -- Static part of the self-energy at each k-point. If
                `self.diagonal_se`, non-diagonal elements are set to zero.
      :rtype: numpy.ndarray


   .. py:method:: build_se_moments(nmom_max, integrals, **kwargs)

      Build the moments of the self-energy.

      :param nmom_max: Maximum moment number to calculate.
      :type nmom_max: int
      :param integrals: Density-fitted integrals.
      :type integrals: KIntegrals
      :param See functions in `momentGW.rpa` for `kwargs` options.:

      :returns: * **se_moments_hole** (*numpy.ndarray*) -- Moments of the hole self-energy at each k-point. If
                  `self.diagonal_se`, non-diagonal elements are set to zero.
                * **se_moments_part** (*numpy.ndarray*) -- Moments of the particle self-energy at each k-point. If
                  `self.diagonal_se`, non-diagonal elements are set to zero.


   .. py:method:: ao2mo(transform=True)

      Get the integrals object.

      :param transform: Whether to transform the integrals object.
      :type transform: bool, optional

      :returns: **integrals** -- Integrals object.
      :rtype: KIntegrals

      .. seealso:: :obj:`momentGW.pbc.ints.KIntegrals`, :obj:`momentGW.pbc.thc.KIntegrals`


   .. py:method:: solve_dyson(se_moments_hole, se_moments_part, se_static, integrals=None)

      Solve the Dyson equation due to a self-energy resulting
      from a list of hole and particle moments, along with a static
      contribution.

      Also finds a chemical potential best satisfying the physical
      number of electrons. If `self.optimise_chempot`, this will
      shift the self-energy poles relative to the Green's function,
      which is a partial self-consistency that better conserves the
      particle number.

      If `self.fock_loop`, this function will also require that the
      outputted Green's function is self-consistent with respect to
      the corresponding density and Fock matrix.

      :param se_moments_hole: Moments of the hole self-energy at each k-point.
      :type se_moments_hole: numpy.ndarray
      :param se_moments_part: Moments of the particle self-energy at each k-point.
      :type se_moments_part: numpy.ndarray
      :param se_static: Static part of the self-energy at each k-point.
      :type se_static: numpy.ndarray
      :param integrals: Density-fitted integrals. Required if `self.fock_loop`
                        is `True`. Default value is `None`.
      :type integrals: KIntegrals, optional

      :returns: * **gf** (*tuple of dyson.Lehmann*) -- Green's function at each k-point.
                * **se** (*tuple of dyson.Lehmann*) -- Self-energy at each k-point.

      .. seealso:: :obj:`momentGW.pbc.fock.FockLoop`


   .. py:method:: kernel(nmom_max, moments=None, integrals=None)

      Driver for the method.

      :param nmom_max: Maximum moment number to calculate.
      :type nmom_max: int
      :param moments: Tuple of (hole, particle) moments at each k-point, if passed
                      then they will be used instead of calculating them. Default
                      value is `None`.
      :type moments: tuple of numpy.ndarray, optional
      :param integrals: Integrals object. If `None`, generate from scratch. Default
                        value is `None`.
      :type integrals: KIntegrals, optional

      :returns: * **converged** (*bool*) -- Whether the solver converged. For single-shot calculations,
                  this is always `True`.
                * **gf** (*tuple of dyson.Lehmann*) -- Green's function object at each k-point.
                * **se** (*tuple of dyson.Lehmann*) -- Self-energy object at each k-point.
                * **qp_energy** (*NoneType*) -- Quasiparticle energies. For most GW methods, this is `None`.


   .. py:method:: make_rdm1(gf=None)

      Get the first-order reduced density matrix.

      :param gf: Green's function at each k-point. If `None`, use either
                 `self.gf`, or the mean-field Green's function. Default
                 value is `None`.
      :type gf: tuple of dyson.Lehmann, optional

      :returns: **rdm1** -- First-order reduced density matrix at each k-point.
      :rtype: numpy.ndarray


   .. py:method:: energy_hf(gf=None, integrals=None)

      Calculate the one-body (Hartree--Fock) energy.

      :param gf: Green's function at each k-point. If `None`, use either
                 `self.gf`, or the mean-field Green's function. Default
                 value is `None`.
      :type gf: tuple of dyson.Lehmann, optional
      :param integrals: Integrals object. If `None`, generate from scratch. Default
                        value is `None`.
      :type integrals: KIntegrals, optional

      :returns: **e_1b** -- One-body energy.
      :rtype: float


   .. py:method:: energy_gm(gf=None, se=None, g0=True)

      Calculate the two-body (Galitskii--Migdal) energy.

      :param gf: Green's function at each k-point for each spin channel. If
                 `None`, use `self.gf`. Default value is `None`.
      :type gf: tuple of tuple of dyson.Lehmann, optional
      :param se: Self-energy at each k-point for each spin channel. If
                 `None`, use `self.se`. Default value is `None`.
      :type se: tuple of tuple of dyson.Lehmann, optional
      :param g0: If `True`, use the mean-field Green's function. Default
                 value is `True`.
      :type g0: bool, optional

      :returns: **e_2b** -- Two-body energy.
      :rtype: float


   .. py:method:: interpolate(mf, nmom_max)

      Interpolate the object to a new k-point grid, represented by a
      new mean-field object.

      :param mf: Mean-field object on new k-point mesh.
      :type mf: pyscf.pbc.scf.KSCF
      :param nmom_max: Maximum moment number to calculate.
      :type nmom_max: int

      :returns: **other** -- Interpolated object.
      :rtype: __class__


   .. py:method:: init_gf(mo_energy=None)

      Initialise the mean-field Green's function.

      :param mo_energy: Molecular orbital energies at each k-point. Default value is
                        `self.mo_energy`.
      :type mo_energy: numpy.ndarray, optional

      :returns: **gf** -- Mean-field Green's function at each k-point.
      :rtype: tuple of dyson.Lehmann


   .. py:method:: run(*args, **kwargs)

      Alias for `kernel`, instead returning `self`.

      :param \*args: Positional arguments to pass to `kernel`.
      :type \*args: tuple
      :param \*\*kwargs: Keyword arguments to pass to `kernel`.
      :type \*\*kwargs: dict

      :returns: **self** -- The solver object.
      :rtype: BaseGW


   .. py:method:: moment_error(se_moments_hole, se_moments_part, se)

      Return the error in the moments.

      :param se_moments_hole: Moments of the hole self-energy.
      :type se_moments_hole: numpy.ndarray
      :param se_moments_part: Moments of the particle self-energy.
      :type se_moments_part: numpy.ndarray
      :param se: Self-energy object.
      :type se: dyson.Lehmann

      :returns: * **eh** (*float*) -- Error in the hole moments.
                * **ep** (*float*) -- Error in the particle moments.


   .. py:method:: energy_nuc()

      Calculate the nuclear repulsion energy.

      :returns: **e_nuc** -- Nuclear repulsion energy.
      :rtype: float



